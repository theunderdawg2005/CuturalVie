
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Achievement
 * 
 */
export type Achievement = $Result.DefaultSelection<Prisma.$AchievementPayload>
/**
 * Model AfterQuestionInformation
 * 
 */
export type AfterQuestionInformation = $Result.DefaultSelection<Prisma.$AfterQuestionInformationPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model EmailVerification
 * 
 */
export type EmailVerification = $Result.DefaultSelection<Prisma.$EmailVerificationPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Region
 * 
 */
export type Region = $Result.DefaultSelection<Prisma.$RegionPayload>
/**
 * Model Tags
 * 
 */
export type Tags = $Result.DefaultSelection<Prisma.$TagsPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model comment_reaction
 * 
 */
export type comment_reaction = $Result.DefaultSelection<Prisma.$comment_reactionPayload>
/**
 * Model game_type
 * 
 */
export type game_type = $Result.DefaultSelection<Prisma.$game_typePayload>
/**
 * Model password_resets
 * 
 */
export type password_resets = $Result.DefaultSelection<Prisma.$password_resetsPayload>
/**
 * Model puzzle_game
 * 
 */
export type puzzle_game = $Result.DefaultSelection<Prisma.$puzzle_gamePayload>
/**
 * Model puzzle_pieces
 * 
 */
export type puzzle_pieces = $Result.DefaultSelection<Prisma.$puzzle_piecesPayload>
/**
 * Model quiz_game
 * 
 */
export type quiz_game = $Result.DefaultSelection<Prisma.$quiz_gamePayload>
/**
 * Model quiz_game_qa
 * 
 */
export type quiz_game_qa = $Result.DefaultSelection<Prisma.$quiz_game_qaPayload>
/**
 * Model treasure_connection_cards
 * 
 */
export type treasure_connection_cards = $Result.DefaultSelection<Prisma.$treasure_connection_cardsPayload>
/**
 * Model treasure_game
 * 
 */
export type treasure_game = $Result.DefaultSelection<Prisma.$treasure_gamePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const card_type_enum: {
  text: 'text',
  image: 'image'
};

export type card_type_enum = (typeof card_type_enum)[keyof typeof card_type_enum]


export const game_code_enum: {
  puzzle: 'puzzle',
  quiz: 'quiz',
  word: 'word',
  treasure: 'treasure'
};

export type game_code_enum = (typeof game_code_enum)[keyof typeof game_code_enum]


export const reaction_type_enum: {
  Like: 'Like',
  Dislike: 'Dislike'
};

export type reaction_type_enum = (typeof reaction_type_enum)[keyof typeof reaction_type_enum]

}

export type card_type_enum = $Enums.card_type_enum

export const card_type_enum: typeof $Enums.card_type_enum

export type game_code_enum = $Enums.game_code_enum

export const game_code_enum: typeof $Enums.game_code_enum

export type reaction_type_enum = $Enums.reaction_type_enum

export const reaction_type_enum: typeof $Enums.reaction_type_enum

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Achievements
 * const achievements = await prisma.achievement.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Achievements
   * const achievements = await prisma.achievement.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.achievement`: Exposes CRUD operations for the **Achievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Achievements
    * const achievements = await prisma.achievement.findMany()
    * ```
    */
  get achievement(): Prisma.AchievementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.afterQuestionInformation`: Exposes CRUD operations for the **AfterQuestionInformation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AfterQuestionInformations
    * const afterQuestionInformations = await prisma.afterQuestionInformation.findMany()
    * ```
    */
  get afterQuestionInformation(): Prisma.AfterQuestionInformationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailVerification`: Exposes CRUD operations for the **EmailVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailVerifications
    * const emailVerifications = await prisma.emailVerification.findMany()
    * ```
    */
  get emailVerification(): Prisma.EmailVerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.region`: Exposes CRUD operations for the **Region** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.region.findMany()
    * ```
    */
  get region(): Prisma.RegionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **Tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.TagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment_reaction`: Exposes CRUD operations for the **comment_reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comment_reactions
    * const comment_reactions = await prisma.comment_reaction.findMany()
    * ```
    */
  get comment_reaction(): Prisma.comment_reactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.game_type`: Exposes CRUD operations for the **game_type** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Game_types
    * const game_types = await prisma.game_type.findMany()
    * ```
    */
  get game_type(): Prisma.game_typeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password_resets`: Exposes CRUD operations for the **password_resets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_resets
    * const password_resets = await prisma.password_resets.findMany()
    * ```
    */
  get password_resets(): Prisma.password_resetsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.puzzle_game`: Exposes CRUD operations for the **puzzle_game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Puzzle_games
    * const puzzle_games = await prisma.puzzle_game.findMany()
    * ```
    */
  get puzzle_game(): Prisma.puzzle_gameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.puzzle_pieces`: Exposes CRUD operations for the **puzzle_pieces** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Puzzle_pieces
    * const puzzle_pieces = await prisma.puzzle_pieces.findMany()
    * ```
    */
  get puzzle_pieces(): Prisma.puzzle_piecesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz_game`: Exposes CRUD operations for the **quiz_game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quiz_games
    * const quiz_games = await prisma.quiz_game.findMany()
    * ```
    */
  get quiz_game(): Prisma.quiz_gameDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz_game_qa`: Exposes CRUD operations for the **quiz_game_qa** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quiz_game_qas
    * const quiz_game_qas = await prisma.quiz_game_qa.findMany()
    * ```
    */
  get quiz_game_qa(): Prisma.quiz_game_qaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.treasure_connection_cards`: Exposes CRUD operations for the **treasure_connection_cards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Treasure_connection_cards
    * const treasure_connection_cards = await prisma.treasure_connection_cards.findMany()
    * ```
    */
  get treasure_connection_cards(): Prisma.treasure_connection_cardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.treasure_game`: Exposes CRUD operations for the **treasure_game** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Treasure_games
    * const treasure_games = await prisma.treasure_game.findMany()
    * ```
    */
  get treasure_game(): Prisma.treasure_gameDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Achievement: 'Achievement',
    AfterQuestionInformation: 'AfterQuestionInformation',
    Comment: 'Comment',
    EmailVerification: 'EmailVerification',
    Post: 'Post',
    RefreshToken: 'RefreshToken',
    Region: 'Region',
    Tags: 'Tags',
    User: 'User',
    comment_reaction: 'comment_reaction',
    game_type: 'game_type',
    password_resets: 'password_resets',
    puzzle_game: 'puzzle_game',
    puzzle_pieces: 'puzzle_pieces',
    quiz_game: 'quiz_game',
    quiz_game_qa: 'quiz_game_qa',
    treasure_connection_cards: 'treasure_connection_cards',
    treasure_game: 'treasure_game'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "achievement" | "afterQuestionInformation" | "comment" | "emailVerification" | "post" | "refreshToken" | "region" | "tags" | "user" | "comment_reaction" | "game_type" | "password_resets" | "puzzle_game" | "puzzle_pieces" | "quiz_game" | "quiz_game_qa" | "treasure_connection_cards" | "treasure_game"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Achievement: {
        payload: Prisma.$AchievementPayload<ExtArgs>
        fields: Prisma.AchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findFirst: {
            args: Prisma.AchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          findMany: {
            args: Prisma.AchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          create: {
            args: Prisma.AchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          createMany: {
            args: Prisma.AchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AchievementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          delete: {
            args: Prisma.AchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          update: {
            args: Prisma.AchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          deleteMany: {
            args: Prisma.AchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AchievementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>[]
          }
          upsert: {
            args: Prisma.AchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AchievementPayload>
          }
          aggregate: {
            args: Prisma.AchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAchievement>
          }
          groupBy: {
            args: Prisma.AchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AchievementCountArgs<ExtArgs>
            result: $Utils.Optional<AchievementCountAggregateOutputType> | number
          }
        }
      }
      AfterQuestionInformation: {
        payload: Prisma.$AfterQuestionInformationPayload<ExtArgs>
        fields: Prisma.AfterQuestionInformationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AfterQuestionInformationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AfterQuestionInformationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload>
          }
          findFirst: {
            args: Prisma.AfterQuestionInformationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AfterQuestionInformationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload>
          }
          findMany: {
            args: Prisma.AfterQuestionInformationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload>[]
          }
          create: {
            args: Prisma.AfterQuestionInformationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload>
          }
          createMany: {
            args: Prisma.AfterQuestionInformationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AfterQuestionInformationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload>[]
          }
          delete: {
            args: Prisma.AfterQuestionInformationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload>
          }
          update: {
            args: Prisma.AfterQuestionInformationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload>
          }
          deleteMany: {
            args: Prisma.AfterQuestionInformationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AfterQuestionInformationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AfterQuestionInformationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload>[]
          }
          upsert: {
            args: Prisma.AfterQuestionInformationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AfterQuestionInformationPayload>
          }
          aggregate: {
            args: Prisma.AfterQuestionInformationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAfterQuestionInformation>
          }
          groupBy: {
            args: Prisma.AfterQuestionInformationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AfterQuestionInformationGroupByOutputType>[]
          }
          count: {
            args: Prisma.AfterQuestionInformationCountArgs<ExtArgs>
            result: $Utils.Optional<AfterQuestionInformationCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      EmailVerification: {
        payload: Prisma.$EmailVerificationPayload<ExtArgs>
        fields: Prisma.EmailVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          findFirst: {
            args: Prisma.EmailVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          findMany: {
            args: Prisma.EmailVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
          }
          create: {
            args: Prisma.EmailVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          createMany: {
            args: Prisma.EmailVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
          }
          delete: {
            args: Prisma.EmailVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          update: {
            args: Prisma.EmailVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          deleteMany: {
            args: Prisma.EmailVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>[]
          }
          upsert: {
            args: Prisma.EmailVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailVerificationPayload>
          }
          aggregate: {
            args: Prisma.EmailVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailVerification>
          }
          groupBy: {
            args: Prisma.EmailVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<EmailVerificationCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Region: {
        payload: Prisma.$RegionPayload<ExtArgs>
        fields: Prisma.RegionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findFirst: {
            args: Prisma.RegionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          findMany: {
            args: Prisma.RegionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          create: {
            args: Prisma.RegionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          createMany: {
            args: Prisma.RegionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          delete: {
            args: Prisma.RegionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          update: {
            args: Prisma.RegionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          deleteMany: {
            args: Prisma.RegionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RegionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>[]
          }
          upsert: {
            args: Prisma.RegionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionPayload>
          }
          aggregate: {
            args: Prisma.RegionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegion>
          }
          groupBy: {
            args: Prisma.RegionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionCountArgs<ExtArgs>
            result: $Utils.Optional<RegionCountAggregateOutputType> | number
          }
        }
      }
      Tags: {
        payload: Prisma.$TagsPayload<ExtArgs>
        fields: Prisma.TagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findFirst: {
            args: Prisma.TagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          findMany: {
            args: Prisma.TagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          create: {
            args: Prisma.TagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          createMany: {
            args: Prisma.TagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          delete: {
            args: Prisma.TagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          update: {
            args: Prisma.TagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          deleteMany: {
            args: Prisma.TagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>[]
          }
          upsert: {
            args: Prisma.TagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.TagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      comment_reaction: {
        payload: Prisma.$comment_reactionPayload<ExtArgs>
        fields: Prisma.comment_reactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comment_reactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comment_reactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload>
          }
          findFirst: {
            args: Prisma.comment_reactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comment_reactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload>
          }
          findMany: {
            args: Prisma.comment_reactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload>[]
          }
          create: {
            args: Prisma.comment_reactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload>
          }
          createMany: {
            args: Prisma.comment_reactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.comment_reactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload>[]
          }
          delete: {
            args: Prisma.comment_reactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload>
          }
          update: {
            args: Prisma.comment_reactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload>
          }
          deleteMany: {
            args: Prisma.comment_reactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comment_reactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.comment_reactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload>[]
          }
          upsert: {
            args: Prisma.comment_reactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comment_reactionPayload>
          }
          aggregate: {
            args: Prisma.Comment_reactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment_reaction>
          }
          groupBy: {
            args: Prisma.comment_reactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Comment_reactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.comment_reactionCountArgs<ExtArgs>
            result: $Utils.Optional<Comment_reactionCountAggregateOutputType> | number
          }
        }
      }
      game_type: {
        payload: Prisma.$game_typePayload<ExtArgs>
        fields: Prisma.game_typeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.game_typeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.game_typeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload>
          }
          findFirst: {
            args: Prisma.game_typeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.game_typeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload>
          }
          findMany: {
            args: Prisma.game_typeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload>[]
          }
          create: {
            args: Prisma.game_typeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload>
          }
          createMany: {
            args: Prisma.game_typeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.game_typeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload>[]
          }
          delete: {
            args: Prisma.game_typeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload>
          }
          update: {
            args: Prisma.game_typeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload>
          }
          deleteMany: {
            args: Prisma.game_typeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.game_typeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.game_typeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload>[]
          }
          upsert: {
            args: Prisma.game_typeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$game_typePayload>
          }
          aggregate: {
            args: Prisma.Game_typeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGame_type>
          }
          groupBy: {
            args: Prisma.game_typeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Game_typeGroupByOutputType>[]
          }
          count: {
            args: Prisma.game_typeCountArgs<ExtArgs>
            result: $Utils.Optional<Game_typeCountAggregateOutputType> | number
          }
        }
      }
      password_resets: {
        payload: Prisma.$password_resetsPayload<ExtArgs>
        fields: Prisma.password_resetsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.password_resetsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.password_resetsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload>
          }
          findFirst: {
            args: Prisma.password_resetsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.password_resetsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload>
          }
          findMany: {
            args: Prisma.password_resetsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload>[]
          }
          create: {
            args: Prisma.password_resetsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload>
          }
          createMany: {
            args: Prisma.password_resetsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.password_resetsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload>[]
          }
          delete: {
            args: Prisma.password_resetsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload>
          }
          update: {
            args: Prisma.password_resetsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload>
          }
          deleteMany: {
            args: Prisma.password_resetsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.password_resetsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.password_resetsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload>[]
          }
          upsert: {
            args: Prisma.password_resetsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_resetsPayload>
          }
          aggregate: {
            args: Prisma.Password_resetsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword_resets>
          }
          groupBy: {
            args: Prisma.password_resetsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Password_resetsGroupByOutputType>[]
          }
          count: {
            args: Prisma.password_resetsCountArgs<ExtArgs>
            result: $Utils.Optional<Password_resetsCountAggregateOutputType> | number
          }
        }
      }
      puzzle_game: {
        payload: Prisma.$puzzle_gamePayload<ExtArgs>
        fields: Prisma.puzzle_gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.puzzle_gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.puzzle_gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload>
          }
          findFirst: {
            args: Prisma.puzzle_gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.puzzle_gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload>
          }
          findMany: {
            args: Prisma.puzzle_gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload>[]
          }
          create: {
            args: Prisma.puzzle_gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload>
          }
          createMany: {
            args: Prisma.puzzle_gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.puzzle_gameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload>[]
          }
          delete: {
            args: Prisma.puzzle_gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload>
          }
          update: {
            args: Prisma.puzzle_gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload>
          }
          deleteMany: {
            args: Prisma.puzzle_gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.puzzle_gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.puzzle_gameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload>[]
          }
          upsert: {
            args: Prisma.puzzle_gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_gamePayload>
          }
          aggregate: {
            args: Prisma.Puzzle_gameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePuzzle_game>
          }
          groupBy: {
            args: Prisma.puzzle_gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<Puzzle_gameGroupByOutputType>[]
          }
          count: {
            args: Prisma.puzzle_gameCountArgs<ExtArgs>
            result: $Utils.Optional<Puzzle_gameCountAggregateOutputType> | number
          }
        }
      }
      puzzle_pieces: {
        payload: Prisma.$puzzle_piecesPayload<ExtArgs>
        fields: Prisma.puzzle_piecesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.puzzle_piecesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.puzzle_piecesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload>
          }
          findFirst: {
            args: Prisma.puzzle_piecesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.puzzle_piecesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload>
          }
          findMany: {
            args: Prisma.puzzle_piecesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload>[]
          }
          create: {
            args: Prisma.puzzle_piecesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload>
          }
          createMany: {
            args: Prisma.puzzle_piecesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.puzzle_piecesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload>[]
          }
          delete: {
            args: Prisma.puzzle_piecesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload>
          }
          update: {
            args: Prisma.puzzle_piecesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload>
          }
          deleteMany: {
            args: Prisma.puzzle_piecesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.puzzle_piecesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.puzzle_piecesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload>[]
          }
          upsert: {
            args: Prisma.puzzle_piecesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$puzzle_piecesPayload>
          }
          aggregate: {
            args: Prisma.Puzzle_piecesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePuzzle_pieces>
          }
          groupBy: {
            args: Prisma.puzzle_piecesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Puzzle_piecesGroupByOutputType>[]
          }
          count: {
            args: Prisma.puzzle_piecesCountArgs<ExtArgs>
            result: $Utils.Optional<Puzzle_piecesCountAggregateOutputType> | number
          }
        }
      }
      quiz_game: {
        payload: Prisma.$quiz_gamePayload<ExtArgs>
        fields: Prisma.quiz_gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quiz_gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quiz_gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload>
          }
          findFirst: {
            args: Prisma.quiz_gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quiz_gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload>
          }
          findMany: {
            args: Prisma.quiz_gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload>[]
          }
          create: {
            args: Prisma.quiz_gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload>
          }
          createMany: {
            args: Prisma.quiz_gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.quiz_gameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload>[]
          }
          delete: {
            args: Prisma.quiz_gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload>
          }
          update: {
            args: Prisma.quiz_gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload>
          }
          deleteMany: {
            args: Prisma.quiz_gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quiz_gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.quiz_gameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload>[]
          }
          upsert: {
            args: Prisma.quiz_gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_gamePayload>
          }
          aggregate: {
            args: Prisma.Quiz_gameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz_game>
          }
          groupBy: {
            args: Prisma.quiz_gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<Quiz_gameGroupByOutputType>[]
          }
          count: {
            args: Prisma.quiz_gameCountArgs<ExtArgs>
            result: $Utils.Optional<Quiz_gameCountAggregateOutputType> | number
          }
        }
      }
      quiz_game_qa: {
        payload: Prisma.$quiz_game_qaPayload<ExtArgs>
        fields: Prisma.quiz_game_qaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.quiz_game_qaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.quiz_game_qaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload>
          }
          findFirst: {
            args: Prisma.quiz_game_qaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.quiz_game_qaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload>
          }
          findMany: {
            args: Prisma.quiz_game_qaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload>[]
          }
          create: {
            args: Prisma.quiz_game_qaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload>
          }
          createMany: {
            args: Prisma.quiz_game_qaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.quiz_game_qaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload>[]
          }
          delete: {
            args: Prisma.quiz_game_qaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload>
          }
          update: {
            args: Prisma.quiz_game_qaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload>
          }
          deleteMany: {
            args: Prisma.quiz_game_qaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.quiz_game_qaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.quiz_game_qaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload>[]
          }
          upsert: {
            args: Prisma.quiz_game_qaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$quiz_game_qaPayload>
          }
          aggregate: {
            args: Prisma.Quiz_game_qaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz_game_qa>
          }
          groupBy: {
            args: Prisma.quiz_game_qaGroupByArgs<ExtArgs>
            result: $Utils.Optional<Quiz_game_qaGroupByOutputType>[]
          }
          count: {
            args: Prisma.quiz_game_qaCountArgs<ExtArgs>
            result: $Utils.Optional<Quiz_game_qaCountAggregateOutputType> | number
          }
        }
      }
      treasure_connection_cards: {
        payload: Prisma.$treasure_connection_cardsPayload<ExtArgs>
        fields: Prisma.treasure_connection_cardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.treasure_connection_cardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.treasure_connection_cardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload>
          }
          findFirst: {
            args: Prisma.treasure_connection_cardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.treasure_connection_cardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload>
          }
          findMany: {
            args: Prisma.treasure_connection_cardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload>[]
          }
          create: {
            args: Prisma.treasure_connection_cardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload>
          }
          createMany: {
            args: Prisma.treasure_connection_cardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.treasure_connection_cardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload>[]
          }
          delete: {
            args: Prisma.treasure_connection_cardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload>
          }
          update: {
            args: Prisma.treasure_connection_cardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload>
          }
          deleteMany: {
            args: Prisma.treasure_connection_cardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.treasure_connection_cardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.treasure_connection_cardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload>[]
          }
          upsert: {
            args: Prisma.treasure_connection_cardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_connection_cardsPayload>
          }
          aggregate: {
            args: Prisma.Treasure_connection_cardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreasure_connection_cards>
          }
          groupBy: {
            args: Prisma.treasure_connection_cardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Treasure_connection_cardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.treasure_connection_cardsCountArgs<ExtArgs>
            result: $Utils.Optional<Treasure_connection_cardsCountAggregateOutputType> | number
          }
        }
      }
      treasure_game: {
        payload: Prisma.$treasure_gamePayload<ExtArgs>
        fields: Prisma.treasure_gameFieldRefs
        operations: {
          findUnique: {
            args: Prisma.treasure_gameFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.treasure_gameFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload>
          }
          findFirst: {
            args: Prisma.treasure_gameFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.treasure_gameFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload>
          }
          findMany: {
            args: Prisma.treasure_gameFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload>[]
          }
          create: {
            args: Prisma.treasure_gameCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload>
          }
          createMany: {
            args: Prisma.treasure_gameCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.treasure_gameCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload>[]
          }
          delete: {
            args: Prisma.treasure_gameDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload>
          }
          update: {
            args: Prisma.treasure_gameUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload>
          }
          deleteMany: {
            args: Prisma.treasure_gameDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.treasure_gameUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.treasure_gameUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload>[]
          }
          upsert: {
            args: Prisma.treasure_gameUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$treasure_gamePayload>
          }
          aggregate: {
            args: Prisma.Treasure_gameAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreasure_game>
          }
          groupBy: {
            args: Prisma.treasure_gameGroupByArgs<ExtArgs>
            result: $Utils.Optional<Treasure_gameGroupByOutputType>[]
          }
          count: {
            args: Prisma.treasure_gameCountArgs<ExtArgs>
            result: $Utils.Optional<Treasure_gameCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    achievement?: AchievementOmit
    afterQuestionInformation?: AfterQuestionInformationOmit
    comment?: CommentOmit
    emailVerification?: EmailVerificationOmit
    post?: PostOmit
    refreshToken?: RefreshTokenOmit
    region?: RegionOmit
    tags?: TagsOmit
    user?: UserOmit
    comment_reaction?: comment_reactionOmit
    game_type?: game_typeOmit
    password_resets?: password_resetsOmit
    puzzle_game?: puzzle_gameOmit
    puzzle_pieces?: puzzle_piecesOmit
    quiz_game?: quiz_gameOmit
    quiz_game_qa?: quiz_game_qaOmit
    treasure_connection_cards?: treasure_connection_cardsOmit
    treasure_game?: treasure_gameOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    other_Comment: number
    comment_reaction: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_Comment?: boolean | CommentCountOutputTypeCountOther_CommentArgs
    comment_reaction?: boolean | CommentCountOutputTypeCountComment_reactionArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountOther_CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountComment_reactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comment_reactionWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    Comment: number
    Tags: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | PostCountOutputTypeCountCommentArgs
    Tags?: boolean | PostCountOutputTypeCountTagsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
  }


  /**
   * Count Type RegionCountOutputType
   */

  export type RegionCountOutputType = {
    puzzle_game: number
    quiz_game: number
    treasure_game: number
  }

  export type RegionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | RegionCountOutputTypeCountPuzzle_gameArgs
    quiz_game?: boolean | RegionCountOutputTypeCountQuiz_gameArgs
    treasure_game?: boolean | RegionCountOutputTypeCountTreasure_gameArgs
  }

  // Custom InputTypes
  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegionCountOutputType
     */
    select?: RegionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountPuzzle_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: puzzle_gameWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountQuiz_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quiz_gameWhereInput
  }

  /**
   * RegionCountOutputType without action
   */
  export type RegionCountOutputTypeCountTreasure_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: treasure_gameWhereInput
  }


  /**
   * Count Type TagsCountOutputType
   */

  export type TagsCountOutputType = {
    Post: number
  }

  export type TagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Post?: boolean | TagsCountOutputTypeCountPostArgs
  }

  // Custom InputTypes
  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsCountOutputType
     */
    select?: TagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Achievement: number
    Comment: number
    Post: number
    RefreshToken: number
    comment_reaction: number
    password_resets: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Achievement?: boolean | UserCountOutputTypeCountAchievementArgs
    Comment?: boolean | UserCountOutputTypeCountCommentArgs
    Post?: boolean | UserCountOutputTypeCountPostArgs
    RefreshToken?: boolean | UserCountOutputTypeCountRefreshTokenArgs
    comment_reaction?: boolean | UserCountOutputTypeCountComment_reactionArgs
    password_resets?: boolean | UserCountOutputTypeCountPassword_resetsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComment_reactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comment_reactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPassword_resetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_resetsWhereInput
  }


  /**
   * Count Type Game_typeCountOutputType
   */

  export type Game_typeCountOutputType = {
    puzzle_game: number
    quiz_game: number
    treasure_game: number
  }

  export type Game_typeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | Game_typeCountOutputTypeCountPuzzle_gameArgs
    quiz_game?: boolean | Game_typeCountOutputTypeCountQuiz_gameArgs
    treasure_game?: boolean | Game_typeCountOutputTypeCountTreasure_gameArgs
  }

  // Custom InputTypes
  /**
   * Game_typeCountOutputType without action
   */
  export type Game_typeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Game_typeCountOutputType
     */
    select?: Game_typeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Game_typeCountOutputType without action
   */
  export type Game_typeCountOutputTypeCountPuzzle_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: puzzle_gameWhereInput
  }

  /**
   * Game_typeCountOutputType without action
   */
  export type Game_typeCountOutputTypeCountQuiz_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quiz_gameWhereInput
  }

  /**
   * Game_typeCountOutputType without action
   */
  export type Game_typeCountOutputTypeCountTreasure_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: treasure_gameWhereInput
  }


  /**
   * Count Type Puzzle_gameCountOutputType
   */

  export type Puzzle_gameCountOutputType = {
    AfterQuestionInformation: number
    puzzle_pieces: number
  }

  export type Puzzle_gameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AfterQuestionInformation?: boolean | Puzzle_gameCountOutputTypeCountAfterQuestionInformationArgs
    puzzle_pieces?: boolean | Puzzle_gameCountOutputTypeCountPuzzle_piecesArgs
  }

  // Custom InputTypes
  /**
   * Puzzle_gameCountOutputType without action
   */
  export type Puzzle_gameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Puzzle_gameCountOutputType
     */
    select?: Puzzle_gameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Puzzle_gameCountOutputType without action
   */
  export type Puzzle_gameCountOutputTypeCountAfterQuestionInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AfterQuestionInformationWhereInput
  }

  /**
   * Puzzle_gameCountOutputType without action
   */
  export type Puzzle_gameCountOutputTypeCountPuzzle_piecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: puzzle_piecesWhereInput
  }


  /**
   * Count Type Quiz_gameCountOutputType
   */

  export type Quiz_gameCountOutputType = {
    AfterQuestionInformation: number
    quiz_game_qa: number
  }

  export type Quiz_gameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AfterQuestionInformation?: boolean | Quiz_gameCountOutputTypeCountAfterQuestionInformationArgs
    quiz_game_qa?: boolean | Quiz_gameCountOutputTypeCountQuiz_game_qaArgs
  }

  // Custom InputTypes
  /**
   * Quiz_gameCountOutputType without action
   */
  export type Quiz_gameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz_gameCountOutputType
     */
    select?: Quiz_gameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Quiz_gameCountOutputType without action
   */
  export type Quiz_gameCountOutputTypeCountAfterQuestionInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AfterQuestionInformationWhereInput
  }

  /**
   * Quiz_gameCountOutputType without action
   */
  export type Quiz_gameCountOutputTypeCountQuiz_game_qaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quiz_game_qaWhereInput
  }


  /**
   * Count Type Treasure_gameCountOutputType
   */

  export type Treasure_gameCountOutputType = {
    AfterQuestionInformation: number
    treasure_connection_cards: number
  }

  export type Treasure_gameCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AfterQuestionInformation?: boolean | Treasure_gameCountOutputTypeCountAfterQuestionInformationArgs
    treasure_connection_cards?: boolean | Treasure_gameCountOutputTypeCountTreasure_connection_cardsArgs
  }

  // Custom InputTypes
  /**
   * Treasure_gameCountOutputType without action
   */
  export type Treasure_gameCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Treasure_gameCountOutputType
     */
    select?: Treasure_gameCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Treasure_gameCountOutputType without action
   */
  export type Treasure_gameCountOutputTypeCountAfterQuestionInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AfterQuestionInformationWhereInput
  }

  /**
   * Treasure_gameCountOutputType without action
   */
  export type Treasure_gameCountOutputTypeCountTreasure_connection_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: treasure_connection_cardsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Achievement
   */

  export type AggregateAchievement = {
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  export type AchievementAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    stars: number | null
  }

  export type AchievementSumAggregateOutputType = {
    id: number | null
    userId: number | null
    stars: number | null
  }

  export type AchievementMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    description: string | null
    stars: number | null
  }

  export type AchievementMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    description: string | null
    stars: number | null
  }

  export type AchievementCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    stars: number
    _all: number
  }


  export type AchievementAvgAggregateInputType = {
    id?: true
    userId?: true
    stars?: true
  }

  export type AchievementSumAggregateInputType = {
    id?: true
    userId?: true
    stars?: true
  }

  export type AchievementMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    stars?: true
  }

  export type AchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    stars?: true
  }

  export type AchievementCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    stars?: true
    _all?: true
  }

  export type AchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievement to aggregate.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Achievements
    **/
    _count?: true | AchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AchievementMaxAggregateInputType
  }

  export type GetAchievementAggregateType<T extends AchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAchievement[P]>
      : GetScalarType<T[P], AggregateAchievement[P]>
  }




  export type AchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithAggregationInput | AchievementOrderByWithAggregationInput[]
    by: AchievementScalarFieldEnum[] | AchievementScalarFieldEnum
    having?: AchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AchievementCountAggregateInputType | true
    _avg?: AchievementAvgAggregateInputType
    _sum?: AchievementSumAggregateInputType
    _min?: AchievementMinAggregateInputType
    _max?: AchievementMaxAggregateInputType
  }

  export type AchievementGroupByOutputType = {
    id: number
    userId: number
    name: string
    description: string
    stars: number
    _count: AchievementCountAggregateOutputType | null
    _avg: AchievementAvgAggregateOutputType | null
    _sum: AchievementSumAggregateOutputType | null
    _min: AchievementMinAggregateOutputType | null
    _max: AchievementMaxAggregateOutputType | null
  }

  type GetAchievementGroupByPayload<T extends AchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AchievementGroupByOutputType[P]>
            : GetScalarType<T[P], AchievementGroupByOutputType[P]>
        }
      >
    >


  export type AchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    stars?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    stars?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    stars?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["achievement"]>

  export type AchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    stars?: boolean
  }

  export type AchievementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "stars", ExtArgs["result"]["achievement"]>
  export type AchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AchievementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Achievement"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      name: string
      description: string
      stars: number
    }, ExtArgs["result"]["achievement"]>
    composites: {}
  }

  type AchievementGetPayload<S extends boolean | null | undefined | AchievementDefaultArgs> = $Result.GetResult<Prisma.$AchievementPayload, S>

  type AchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AchievementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AchievementCountAggregateInputType | true
    }

  export interface AchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Achievement'], meta: { name: 'Achievement' } }
    /**
     * Find zero or one Achievement that matches the filter.
     * @param {AchievementFindUniqueArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AchievementFindUniqueArgs>(args: SelectSubset<T, AchievementFindUniqueArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Achievement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AchievementFindUniqueOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, AchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AchievementFindFirstArgs>(args?: SelectSubset<T, AchievementFindFirstArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Achievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindFirstOrThrowArgs} args - Arguments to find a Achievement
     * @example
     * // Get one Achievement
     * const achievement = await prisma.achievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, AchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Achievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Achievements
     * const achievements = await prisma.achievement.findMany()
     * 
     * // Get first 10 Achievements
     * const achievements = await prisma.achievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const achievementWithIdOnly = await prisma.achievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AchievementFindManyArgs>(args?: SelectSubset<T, AchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Achievement.
     * @param {AchievementCreateArgs} args - Arguments to create a Achievement.
     * @example
     * // Create one Achievement
     * const Achievement = await prisma.achievement.create({
     *   data: {
     *     // ... data to create a Achievement
     *   }
     * })
     * 
     */
    create<T extends AchievementCreateArgs>(args: SelectSubset<T, AchievementCreateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Achievements.
     * @param {AchievementCreateManyArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AchievementCreateManyArgs>(args?: SelectSubset<T, AchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Achievements and returns the data saved in the database.
     * @param {AchievementCreateManyAndReturnArgs} args - Arguments to create many Achievements.
     * @example
     * // Create many Achievements
     * const achievement = await prisma.achievement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AchievementCreateManyAndReturnArgs>(args?: SelectSubset<T, AchievementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Achievement.
     * @param {AchievementDeleteArgs} args - Arguments to delete one Achievement.
     * @example
     * // Delete one Achievement
     * const Achievement = await prisma.achievement.delete({
     *   where: {
     *     // ... filter to delete one Achievement
     *   }
     * })
     * 
     */
    delete<T extends AchievementDeleteArgs>(args: SelectSubset<T, AchievementDeleteArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Achievement.
     * @param {AchievementUpdateArgs} args - Arguments to update one Achievement.
     * @example
     * // Update one Achievement
     * const achievement = await prisma.achievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AchievementUpdateArgs>(args: SelectSubset<T, AchievementUpdateArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Achievements.
     * @param {AchievementDeleteManyArgs} args - Arguments to filter Achievements to delete.
     * @example
     * // Delete a few Achievements
     * const { count } = await prisma.achievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AchievementDeleteManyArgs>(args?: SelectSubset<T, AchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AchievementUpdateManyArgs>(args: SelectSubset<T, AchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Achievements and returns the data updated in the database.
     * @param {AchievementUpdateManyAndReturnArgs} args - Arguments to update many Achievements.
     * @example
     * // Update many Achievements
     * const achievement = await prisma.achievement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Achievements and only return the `id`
     * const achievementWithIdOnly = await prisma.achievement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AchievementUpdateManyAndReturnArgs>(args: SelectSubset<T, AchievementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Achievement.
     * @param {AchievementUpsertArgs} args - Arguments to update or create a Achievement.
     * @example
     * // Update or create a Achievement
     * const achievement = await prisma.achievement.upsert({
     *   create: {
     *     // ... data to create a Achievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Achievement we want to update
     *   }
     * })
     */
    upsert<T extends AchievementUpsertArgs>(args: SelectSubset<T, AchievementUpsertArgs<ExtArgs>>): Prisma__AchievementClient<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Achievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementCountArgs} args - Arguments to filter Achievements to count.
     * @example
     * // Count the number of Achievements
     * const count = await prisma.achievement.count({
     *   where: {
     *     // ... the filter for the Achievements we want to count
     *   }
     * })
    **/
    count<T extends AchievementCountArgs>(
      args?: Subset<T, AchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AchievementAggregateArgs>(args: Subset<T, AchievementAggregateArgs>): Prisma.PrismaPromise<GetAchievementAggregateType<T>>

    /**
     * Group by Achievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AchievementGroupByArgs['orderBy'] }
        : { orderBy?: AchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Achievement model
   */
  readonly fields: AchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Achievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Achievement model
   */
  interface AchievementFieldRefs {
    readonly id: FieldRef<"Achievement", 'Int'>
    readonly userId: FieldRef<"Achievement", 'Int'>
    readonly name: FieldRef<"Achievement", 'String'>
    readonly description: FieldRef<"Achievement", 'String'>
    readonly stars: FieldRef<"Achievement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Achievement findUnique
   */
  export type AchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findUniqueOrThrow
   */
  export type AchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement findFirst
   */
  export type AchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findFirstOrThrow
   */
  export type AchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievement to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Achievements.
     */
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement findMany
   */
  export type AchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter, which Achievements to fetch.
     */
    where?: AchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Achievements to fetch.
     */
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Achievements.
     */
    cursor?: AchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Achievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Achievements.
     */
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * Achievement create
   */
  export type AchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a Achievement.
     */
    data: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
  }

  /**
   * Achievement createMany
   */
  export type AchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Achievement createManyAndReturn
   */
  export type AchievementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to create many Achievements.
     */
    data: AchievementCreateManyInput | AchievementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement update
   */
  export type AchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a Achievement.
     */
    data: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
    /**
     * Choose, which Achievement to update.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement updateMany
   */
  export type AchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
  }

  /**
   * Achievement updateManyAndReturn
   */
  export type AchievementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * The data used to update Achievements.
     */
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyInput>
    /**
     * Filter which Achievements to update
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Achievement upsert
   */
  export type AchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the Achievement to update in case it exists.
     */
    where: AchievementWhereUniqueInput
    /**
     * In case the Achievement found by the `where` argument doesn't exist, create a new Achievement with this data.
     */
    create: XOR<AchievementCreateInput, AchievementUncheckedCreateInput>
    /**
     * In case the Achievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AchievementUpdateInput, AchievementUncheckedUpdateInput>
  }

  /**
   * Achievement delete
   */
  export type AchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    /**
     * Filter which Achievement to delete.
     */
    where: AchievementWhereUniqueInput
  }

  /**
   * Achievement deleteMany
   */
  export type AchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Achievements to delete
     */
    where?: AchievementWhereInput
    /**
     * Limit how many Achievements to delete.
     */
    limit?: number
  }

  /**
   * Achievement without action
   */
  export type AchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
  }


  /**
   * Model AfterQuestionInformation
   */

  export type AggregateAfterQuestionInformation = {
    _count: AfterQuestionInformationCountAggregateOutputType | null
    _avg: AfterQuestionInformationAvgAggregateOutputType | null
    _sum: AfterQuestionInformationSumAggregateOutputType | null
    _min: AfterQuestionInformationMinAggregateOutputType | null
    _max: AfterQuestionInformationMaxAggregateOutputType | null
  }

  export type AfterQuestionInformationAvgAggregateOutputType = {
    id: number | null
    gameId: number | null
    questionNumber: number | null
  }

  export type AfterQuestionInformationSumAggregateOutputType = {
    id: number | null
    gameId: number | null
    questionNumber: number | null
  }

  export type AfterQuestionInformationMinAggregateOutputType = {
    id: number | null
    gameId: number | null
    questionNumber: number | null
  }

  export type AfterQuestionInformationMaxAggregateOutputType = {
    id: number | null
    gameId: number | null
    questionNumber: number | null
  }

  export type AfterQuestionInformationCountAggregateOutputType = {
    id: number
    gameId: number
    questionNumber: number
    images: number
    texts: number
    _all: number
  }


  export type AfterQuestionInformationAvgAggregateInputType = {
    id?: true
    gameId?: true
    questionNumber?: true
  }

  export type AfterQuestionInformationSumAggregateInputType = {
    id?: true
    gameId?: true
    questionNumber?: true
  }

  export type AfterQuestionInformationMinAggregateInputType = {
    id?: true
    gameId?: true
    questionNumber?: true
  }

  export type AfterQuestionInformationMaxAggregateInputType = {
    id?: true
    gameId?: true
    questionNumber?: true
  }

  export type AfterQuestionInformationCountAggregateInputType = {
    id?: true
    gameId?: true
    questionNumber?: true
    images?: true
    texts?: true
    _all?: true
  }

  export type AfterQuestionInformationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AfterQuestionInformation to aggregate.
     */
    where?: AfterQuestionInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AfterQuestionInformations to fetch.
     */
    orderBy?: AfterQuestionInformationOrderByWithRelationInput | AfterQuestionInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AfterQuestionInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AfterQuestionInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AfterQuestionInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AfterQuestionInformations
    **/
    _count?: true | AfterQuestionInformationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AfterQuestionInformationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AfterQuestionInformationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AfterQuestionInformationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AfterQuestionInformationMaxAggregateInputType
  }

  export type GetAfterQuestionInformationAggregateType<T extends AfterQuestionInformationAggregateArgs> = {
        [P in keyof T & keyof AggregateAfterQuestionInformation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAfterQuestionInformation[P]>
      : GetScalarType<T[P], AggregateAfterQuestionInformation[P]>
  }




  export type AfterQuestionInformationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AfterQuestionInformationWhereInput
    orderBy?: AfterQuestionInformationOrderByWithAggregationInput | AfterQuestionInformationOrderByWithAggregationInput[]
    by: AfterQuestionInformationScalarFieldEnum[] | AfterQuestionInformationScalarFieldEnum
    having?: AfterQuestionInformationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AfterQuestionInformationCountAggregateInputType | true
    _avg?: AfterQuestionInformationAvgAggregateInputType
    _sum?: AfterQuestionInformationSumAggregateInputType
    _min?: AfterQuestionInformationMinAggregateInputType
    _max?: AfterQuestionInformationMaxAggregateInputType
  }

  export type AfterQuestionInformationGroupByOutputType = {
    id: number
    gameId: number
    questionNumber: number
    images: JsonValue
    texts: JsonValue
    _count: AfterQuestionInformationCountAggregateOutputType | null
    _avg: AfterQuestionInformationAvgAggregateOutputType | null
    _sum: AfterQuestionInformationSumAggregateOutputType | null
    _min: AfterQuestionInformationMinAggregateOutputType | null
    _max: AfterQuestionInformationMaxAggregateOutputType | null
  }

  type GetAfterQuestionInformationGroupByPayload<T extends AfterQuestionInformationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AfterQuestionInformationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AfterQuestionInformationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AfterQuestionInformationGroupByOutputType[P]>
            : GetScalarType<T[P], AfterQuestionInformationGroupByOutputType[P]>
        }
      >
    >


  export type AfterQuestionInformationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    questionNumber?: boolean
    images?: boolean
    texts?: boolean
    puzzle_game?: boolean | puzzle_gameDefaultArgs<ExtArgs>
    quiz_game?: boolean | quiz_gameDefaultArgs<ExtArgs>
    treasure_game?: boolean | treasure_gameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["afterQuestionInformation"]>

  export type AfterQuestionInformationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    questionNumber?: boolean
    images?: boolean
    texts?: boolean
    puzzle_game?: boolean | puzzle_gameDefaultArgs<ExtArgs>
    quiz_game?: boolean | quiz_gameDefaultArgs<ExtArgs>
    treasure_game?: boolean | treasure_gameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["afterQuestionInformation"]>

  export type AfterQuestionInformationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    gameId?: boolean
    questionNumber?: boolean
    images?: boolean
    texts?: boolean
    puzzle_game?: boolean | puzzle_gameDefaultArgs<ExtArgs>
    quiz_game?: boolean | quiz_gameDefaultArgs<ExtArgs>
    treasure_game?: boolean | treasure_gameDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["afterQuestionInformation"]>

  export type AfterQuestionInformationSelectScalar = {
    id?: boolean
    gameId?: boolean
    questionNumber?: boolean
    images?: boolean
    texts?: boolean
  }

  export type AfterQuestionInformationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "gameId" | "questionNumber" | "images" | "texts", ExtArgs["result"]["afterQuestionInformation"]>
  export type AfterQuestionInformationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | puzzle_gameDefaultArgs<ExtArgs>
    quiz_game?: boolean | quiz_gameDefaultArgs<ExtArgs>
    treasure_game?: boolean | treasure_gameDefaultArgs<ExtArgs>
  }
  export type AfterQuestionInformationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | puzzle_gameDefaultArgs<ExtArgs>
    quiz_game?: boolean | quiz_gameDefaultArgs<ExtArgs>
    treasure_game?: boolean | treasure_gameDefaultArgs<ExtArgs>
  }
  export type AfterQuestionInformationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | puzzle_gameDefaultArgs<ExtArgs>
    quiz_game?: boolean | quiz_gameDefaultArgs<ExtArgs>
    treasure_game?: boolean | treasure_gameDefaultArgs<ExtArgs>
  }

  export type $AfterQuestionInformationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AfterQuestionInformation"
    objects: {
      puzzle_game: Prisma.$puzzle_gamePayload<ExtArgs>
      quiz_game: Prisma.$quiz_gamePayload<ExtArgs>
      treasure_game: Prisma.$treasure_gamePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      gameId: number
      questionNumber: number
      images: Prisma.JsonValue
      texts: Prisma.JsonValue
    }, ExtArgs["result"]["afterQuestionInformation"]>
    composites: {}
  }

  type AfterQuestionInformationGetPayload<S extends boolean | null | undefined | AfterQuestionInformationDefaultArgs> = $Result.GetResult<Prisma.$AfterQuestionInformationPayload, S>

  type AfterQuestionInformationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AfterQuestionInformationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AfterQuestionInformationCountAggregateInputType | true
    }

  export interface AfterQuestionInformationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AfterQuestionInformation'], meta: { name: 'AfterQuestionInformation' } }
    /**
     * Find zero or one AfterQuestionInformation that matches the filter.
     * @param {AfterQuestionInformationFindUniqueArgs} args - Arguments to find a AfterQuestionInformation
     * @example
     * // Get one AfterQuestionInformation
     * const afterQuestionInformation = await prisma.afterQuestionInformation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AfterQuestionInformationFindUniqueArgs>(args: SelectSubset<T, AfterQuestionInformationFindUniqueArgs<ExtArgs>>): Prisma__AfterQuestionInformationClient<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AfterQuestionInformation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AfterQuestionInformationFindUniqueOrThrowArgs} args - Arguments to find a AfterQuestionInformation
     * @example
     * // Get one AfterQuestionInformation
     * const afterQuestionInformation = await prisma.afterQuestionInformation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AfterQuestionInformationFindUniqueOrThrowArgs>(args: SelectSubset<T, AfterQuestionInformationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AfterQuestionInformationClient<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AfterQuestionInformation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfterQuestionInformationFindFirstArgs} args - Arguments to find a AfterQuestionInformation
     * @example
     * // Get one AfterQuestionInformation
     * const afterQuestionInformation = await prisma.afterQuestionInformation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AfterQuestionInformationFindFirstArgs>(args?: SelectSubset<T, AfterQuestionInformationFindFirstArgs<ExtArgs>>): Prisma__AfterQuestionInformationClient<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AfterQuestionInformation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfterQuestionInformationFindFirstOrThrowArgs} args - Arguments to find a AfterQuestionInformation
     * @example
     * // Get one AfterQuestionInformation
     * const afterQuestionInformation = await prisma.afterQuestionInformation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AfterQuestionInformationFindFirstOrThrowArgs>(args?: SelectSubset<T, AfterQuestionInformationFindFirstOrThrowArgs<ExtArgs>>): Prisma__AfterQuestionInformationClient<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AfterQuestionInformations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfterQuestionInformationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AfterQuestionInformations
     * const afterQuestionInformations = await prisma.afterQuestionInformation.findMany()
     * 
     * // Get first 10 AfterQuestionInformations
     * const afterQuestionInformations = await prisma.afterQuestionInformation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const afterQuestionInformationWithIdOnly = await prisma.afterQuestionInformation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AfterQuestionInformationFindManyArgs>(args?: SelectSubset<T, AfterQuestionInformationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AfterQuestionInformation.
     * @param {AfterQuestionInformationCreateArgs} args - Arguments to create a AfterQuestionInformation.
     * @example
     * // Create one AfterQuestionInformation
     * const AfterQuestionInformation = await prisma.afterQuestionInformation.create({
     *   data: {
     *     // ... data to create a AfterQuestionInformation
     *   }
     * })
     * 
     */
    create<T extends AfterQuestionInformationCreateArgs>(args: SelectSubset<T, AfterQuestionInformationCreateArgs<ExtArgs>>): Prisma__AfterQuestionInformationClient<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AfterQuestionInformations.
     * @param {AfterQuestionInformationCreateManyArgs} args - Arguments to create many AfterQuestionInformations.
     * @example
     * // Create many AfterQuestionInformations
     * const afterQuestionInformation = await prisma.afterQuestionInformation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AfterQuestionInformationCreateManyArgs>(args?: SelectSubset<T, AfterQuestionInformationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AfterQuestionInformations and returns the data saved in the database.
     * @param {AfterQuestionInformationCreateManyAndReturnArgs} args - Arguments to create many AfterQuestionInformations.
     * @example
     * // Create many AfterQuestionInformations
     * const afterQuestionInformation = await prisma.afterQuestionInformation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AfterQuestionInformations and only return the `id`
     * const afterQuestionInformationWithIdOnly = await prisma.afterQuestionInformation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AfterQuestionInformationCreateManyAndReturnArgs>(args?: SelectSubset<T, AfterQuestionInformationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AfterQuestionInformation.
     * @param {AfterQuestionInformationDeleteArgs} args - Arguments to delete one AfterQuestionInformation.
     * @example
     * // Delete one AfterQuestionInformation
     * const AfterQuestionInformation = await prisma.afterQuestionInformation.delete({
     *   where: {
     *     // ... filter to delete one AfterQuestionInformation
     *   }
     * })
     * 
     */
    delete<T extends AfterQuestionInformationDeleteArgs>(args: SelectSubset<T, AfterQuestionInformationDeleteArgs<ExtArgs>>): Prisma__AfterQuestionInformationClient<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AfterQuestionInformation.
     * @param {AfterQuestionInformationUpdateArgs} args - Arguments to update one AfterQuestionInformation.
     * @example
     * // Update one AfterQuestionInformation
     * const afterQuestionInformation = await prisma.afterQuestionInformation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AfterQuestionInformationUpdateArgs>(args: SelectSubset<T, AfterQuestionInformationUpdateArgs<ExtArgs>>): Prisma__AfterQuestionInformationClient<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AfterQuestionInformations.
     * @param {AfterQuestionInformationDeleteManyArgs} args - Arguments to filter AfterQuestionInformations to delete.
     * @example
     * // Delete a few AfterQuestionInformations
     * const { count } = await prisma.afterQuestionInformation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AfterQuestionInformationDeleteManyArgs>(args?: SelectSubset<T, AfterQuestionInformationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AfterQuestionInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfterQuestionInformationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AfterQuestionInformations
     * const afterQuestionInformation = await prisma.afterQuestionInformation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AfterQuestionInformationUpdateManyArgs>(args: SelectSubset<T, AfterQuestionInformationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AfterQuestionInformations and returns the data updated in the database.
     * @param {AfterQuestionInformationUpdateManyAndReturnArgs} args - Arguments to update many AfterQuestionInformations.
     * @example
     * // Update many AfterQuestionInformations
     * const afterQuestionInformation = await prisma.afterQuestionInformation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AfterQuestionInformations and only return the `id`
     * const afterQuestionInformationWithIdOnly = await prisma.afterQuestionInformation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AfterQuestionInformationUpdateManyAndReturnArgs>(args: SelectSubset<T, AfterQuestionInformationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AfterQuestionInformation.
     * @param {AfterQuestionInformationUpsertArgs} args - Arguments to update or create a AfterQuestionInformation.
     * @example
     * // Update or create a AfterQuestionInformation
     * const afterQuestionInformation = await prisma.afterQuestionInformation.upsert({
     *   create: {
     *     // ... data to create a AfterQuestionInformation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AfterQuestionInformation we want to update
     *   }
     * })
     */
    upsert<T extends AfterQuestionInformationUpsertArgs>(args: SelectSubset<T, AfterQuestionInformationUpsertArgs<ExtArgs>>): Prisma__AfterQuestionInformationClient<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AfterQuestionInformations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfterQuestionInformationCountArgs} args - Arguments to filter AfterQuestionInformations to count.
     * @example
     * // Count the number of AfterQuestionInformations
     * const count = await prisma.afterQuestionInformation.count({
     *   where: {
     *     // ... the filter for the AfterQuestionInformations we want to count
     *   }
     * })
    **/
    count<T extends AfterQuestionInformationCountArgs>(
      args?: Subset<T, AfterQuestionInformationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AfterQuestionInformationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AfterQuestionInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfterQuestionInformationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AfterQuestionInformationAggregateArgs>(args: Subset<T, AfterQuestionInformationAggregateArgs>): Prisma.PrismaPromise<GetAfterQuestionInformationAggregateType<T>>

    /**
     * Group by AfterQuestionInformation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AfterQuestionInformationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AfterQuestionInformationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AfterQuestionInformationGroupByArgs['orderBy'] }
        : { orderBy?: AfterQuestionInformationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AfterQuestionInformationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAfterQuestionInformationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AfterQuestionInformation model
   */
  readonly fields: AfterQuestionInformationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AfterQuestionInformation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AfterQuestionInformationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    puzzle_game<T extends puzzle_gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, puzzle_gameDefaultArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    quiz_game<T extends quiz_gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, quiz_gameDefaultArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    treasure_game<T extends treasure_gameDefaultArgs<ExtArgs> = {}>(args?: Subset<T, treasure_gameDefaultArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AfterQuestionInformation model
   */
  interface AfterQuestionInformationFieldRefs {
    readonly id: FieldRef<"AfterQuestionInformation", 'Int'>
    readonly gameId: FieldRef<"AfterQuestionInformation", 'Int'>
    readonly questionNumber: FieldRef<"AfterQuestionInformation", 'Int'>
    readonly images: FieldRef<"AfterQuestionInformation", 'Json'>
    readonly texts: FieldRef<"AfterQuestionInformation", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * AfterQuestionInformation findUnique
   */
  export type AfterQuestionInformationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    /**
     * Filter, which AfterQuestionInformation to fetch.
     */
    where: AfterQuestionInformationWhereUniqueInput
  }

  /**
   * AfterQuestionInformation findUniqueOrThrow
   */
  export type AfterQuestionInformationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    /**
     * Filter, which AfterQuestionInformation to fetch.
     */
    where: AfterQuestionInformationWhereUniqueInput
  }

  /**
   * AfterQuestionInformation findFirst
   */
  export type AfterQuestionInformationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    /**
     * Filter, which AfterQuestionInformation to fetch.
     */
    where?: AfterQuestionInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AfterQuestionInformations to fetch.
     */
    orderBy?: AfterQuestionInformationOrderByWithRelationInput | AfterQuestionInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AfterQuestionInformations.
     */
    cursor?: AfterQuestionInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AfterQuestionInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AfterQuestionInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AfterQuestionInformations.
     */
    distinct?: AfterQuestionInformationScalarFieldEnum | AfterQuestionInformationScalarFieldEnum[]
  }

  /**
   * AfterQuestionInformation findFirstOrThrow
   */
  export type AfterQuestionInformationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    /**
     * Filter, which AfterQuestionInformation to fetch.
     */
    where?: AfterQuestionInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AfterQuestionInformations to fetch.
     */
    orderBy?: AfterQuestionInformationOrderByWithRelationInput | AfterQuestionInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AfterQuestionInformations.
     */
    cursor?: AfterQuestionInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AfterQuestionInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AfterQuestionInformations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AfterQuestionInformations.
     */
    distinct?: AfterQuestionInformationScalarFieldEnum | AfterQuestionInformationScalarFieldEnum[]
  }

  /**
   * AfterQuestionInformation findMany
   */
  export type AfterQuestionInformationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    /**
     * Filter, which AfterQuestionInformations to fetch.
     */
    where?: AfterQuestionInformationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AfterQuestionInformations to fetch.
     */
    orderBy?: AfterQuestionInformationOrderByWithRelationInput | AfterQuestionInformationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AfterQuestionInformations.
     */
    cursor?: AfterQuestionInformationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AfterQuestionInformations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AfterQuestionInformations.
     */
    skip?: number
    distinct?: AfterQuestionInformationScalarFieldEnum | AfterQuestionInformationScalarFieldEnum[]
  }

  /**
   * AfterQuestionInformation create
   */
  export type AfterQuestionInformationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    /**
     * The data needed to create a AfterQuestionInformation.
     */
    data: XOR<AfterQuestionInformationCreateInput, AfterQuestionInformationUncheckedCreateInput>
  }

  /**
   * AfterQuestionInformation createMany
   */
  export type AfterQuestionInformationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AfterQuestionInformations.
     */
    data: AfterQuestionInformationCreateManyInput | AfterQuestionInformationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AfterQuestionInformation createManyAndReturn
   */
  export type AfterQuestionInformationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * The data used to create many AfterQuestionInformations.
     */
    data: AfterQuestionInformationCreateManyInput | AfterQuestionInformationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AfterQuestionInformation update
   */
  export type AfterQuestionInformationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    /**
     * The data needed to update a AfterQuestionInformation.
     */
    data: XOR<AfterQuestionInformationUpdateInput, AfterQuestionInformationUncheckedUpdateInput>
    /**
     * Choose, which AfterQuestionInformation to update.
     */
    where: AfterQuestionInformationWhereUniqueInput
  }

  /**
   * AfterQuestionInformation updateMany
   */
  export type AfterQuestionInformationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AfterQuestionInformations.
     */
    data: XOR<AfterQuestionInformationUpdateManyMutationInput, AfterQuestionInformationUncheckedUpdateManyInput>
    /**
     * Filter which AfterQuestionInformations to update
     */
    where?: AfterQuestionInformationWhereInput
    /**
     * Limit how many AfterQuestionInformations to update.
     */
    limit?: number
  }

  /**
   * AfterQuestionInformation updateManyAndReturn
   */
  export type AfterQuestionInformationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * The data used to update AfterQuestionInformations.
     */
    data: XOR<AfterQuestionInformationUpdateManyMutationInput, AfterQuestionInformationUncheckedUpdateManyInput>
    /**
     * Filter which AfterQuestionInformations to update
     */
    where?: AfterQuestionInformationWhereInput
    /**
     * Limit how many AfterQuestionInformations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AfterQuestionInformation upsert
   */
  export type AfterQuestionInformationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    /**
     * The filter to search for the AfterQuestionInformation to update in case it exists.
     */
    where: AfterQuestionInformationWhereUniqueInput
    /**
     * In case the AfterQuestionInformation found by the `where` argument doesn't exist, create a new AfterQuestionInformation with this data.
     */
    create: XOR<AfterQuestionInformationCreateInput, AfterQuestionInformationUncheckedCreateInput>
    /**
     * In case the AfterQuestionInformation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AfterQuestionInformationUpdateInput, AfterQuestionInformationUncheckedUpdateInput>
  }

  /**
   * AfterQuestionInformation delete
   */
  export type AfterQuestionInformationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    /**
     * Filter which AfterQuestionInformation to delete.
     */
    where: AfterQuestionInformationWhereUniqueInput
  }

  /**
   * AfterQuestionInformation deleteMany
   */
  export type AfterQuestionInformationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AfterQuestionInformations to delete
     */
    where?: AfterQuestionInformationWhereInput
    /**
     * Limit how many AfterQuestionInformations to delete.
     */
    limit?: number
  }

  /**
   * AfterQuestionInformation without action
   */
  export type AfterQuestionInformationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    likes: number | null
    dislikes: number | null
    parentId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    likes: number | null
    dislikes: number | null
    parentId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    content: string | null
    likes: number | null
    dislikes: number | null
    parentId: number | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    content: string | null
    likes: number | null
    dislikes: number | null
    parentId: number | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    content: number
    likes: number
    dislikes: number
    parentId: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    likes?: true
    dislikes?: true
    parentId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    likes?: true
    dislikes?: true
    parentId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    likes?: true
    dislikes?: true
    parentId?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    likes?: true
    dislikes?: true
    parentId?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    content?: true
    likes?: true
    dislikes?: true
    parentId?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    postId: number
    userId: number
    content: string
    likes: number
    dislikes: number
    parentId: number | null
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    likes?: boolean
    dislikes?: boolean
    parentId?: boolean
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
    other_Comment?: boolean | Comment$other_CommentArgs<ExtArgs>
    Post?: boolean | PostDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    comment_reaction?: boolean | Comment$comment_reactionArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    likes?: boolean
    dislikes?: boolean
    parentId?: boolean
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
    Post?: boolean | PostDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    likes?: boolean
    dislikes?: boolean
    parentId?: boolean
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
    Post?: boolean | PostDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    content?: boolean
    likes?: boolean
    dislikes?: boolean
    parentId?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "content" | "likes" | "dislikes" | "parentId", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
    other_Comment?: boolean | Comment$other_CommentArgs<ExtArgs>
    Post?: boolean | PostDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    comment_reaction?: boolean | Comment$comment_reactionArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
    Post?: boolean | PostDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | Comment$CommentArgs<ExtArgs>
    Post?: boolean | PostDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      Comment: Prisma.$CommentPayload<ExtArgs> | null
      other_Comment: Prisma.$CommentPayload<ExtArgs>[]
      Post: Prisma.$PostPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
      comment_reaction: Prisma.$comment_reactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: number
      content: string
      likes: number
      dislikes: number
      parentId: number | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Comment<T extends Comment$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$CommentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_Comment<T extends Comment$other_CommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$other_CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    comment_reaction<T extends Comment$comment_reactionArgs<ExtArgs> = {}>(args?: Subset<T, Comment$comment_reactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly postId: FieldRef<"Comment", 'Int'>
    readonly userId: FieldRef<"Comment", 'Int'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly likes: FieldRef<"Comment", 'Int'>
    readonly dislikes: FieldRef<"Comment", 'Int'>
    readonly parentId: FieldRef<"Comment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.Comment
   */
  export type Comment$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.other_Comment
   */
  export type Comment$other_CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.comment_reaction
   */
  export type Comment$comment_reactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    where?: comment_reactionWhereInput
    orderBy?: comment_reactionOrderByWithRelationInput | comment_reactionOrderByWithRelationInput[]
    cursor?: comment_reactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Comment_reactionScalarFieldEnum | Comment_reactionScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model EmailVerification
   */

  export type AggregateEmailVerification = {
    _count: EmailVerificationCountAggregateOutputType | null
    _avg: EmailVerificationAvgAggregateOutputType | null
    _sum: EmailVerificationSumAggregateOutputType | null
    _min: EmailVerificationMinAggregateOutputType | null
    _max: EmailVerificationMaxAggregateOutputType | null
  }

  export type EmailVerificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EmailVerificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type EmailVerificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    otp: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type EmailVerificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    otp: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type EmailVerificationCountAggregateOutputType = {
    id: number
    userId: number
    otp: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type EmailVerificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EmailVerificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type EmailVerificationMinAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    createdAt?: true
    expiresAt?: true
  }

  export type EmailVerificationMaxAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    createdAt?: true
    expiresAt?: true
  }

  export type EmailVerificationCountAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type EmailVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerification to aggregate.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailVerifications
    **/
    _count?: true | EmailVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailVerificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailVerificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailVerificationMaxAggregateInputType
  }

  export type GetEmailVerificationAggregateType<T extends EmailVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailVerification[P]>
      : GetScalarType<T[P], AggregateEmailVerification[P]>
  }




  export type EmailVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailVerificationWhereInput
    orderBy?: EmailVerificationOrderByWithAggregationInput | EmailVerificationOrderByWithAggregationInput[]
    by: EmailVerificationScalarFieldEnum[] | EmailVerificationScalarFieldEnum
    having?: EmailVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailVerificationCountAggregateInputType | true
    _avg?: EmailVerificationAvgAggregateInputType
    _sum?: EmailVerificationSumAggregateInputType
    _min?: EmailVerificationMinAggregateInputType
    _max?: EmailVerificationMaxAggregateInputType
  }

  export type EmailVerificationGroupByOutputType = {
    id: number
    userId: number
    otp: string
    createdAt: Date
    expiresAt: Date
    _count: EmailVerificationCountAggregateOutputType | null
    _avg: EmailVerificationAvgAggregateOutputType | null
    _sum: EmailVerificationSumAggregateOutputType | null
    _min: EmailVerificationMinAggregateOutputType | null
    _max: EmailVerificationMaxAggregateOutputType | null
  }

  type GetEmailVerificationGroupByPayload<T extends EmailVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailVerificationGroupByOutputType[P]>
        }
      >
    >


  export type EmailVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerification"]>

  export type EmailVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerification"]>

  export type EmailVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailVerification"]>

  export type EmailVerificationSelectScalar = {
    id?: boolean
    userId?: boolean
    otp?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type EmailVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "otp" | "createdAt" | "expiresAt", ExtArgs["result"]["emailVerification"]>
  export type EmailVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailVerification"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      otp: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["emailVerification"]>
    composites: {}
  }

  type EmailVerificationGetPayload<S extends boolean | null | undefined | EmailVerificationDefaultArgs> = $Result.GetResult<Prisma.$EmailVerificationPayload, S>

  type EmailVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailVerificationCountAggregateInputType | true
    }

  export interface EmailVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailVerification'], meta: { name: 'EmailVerification' } }
    /**
     * Find zero or one EmailVerification that matches the filter.
     * @param {EmailVerificationFindUniqueArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailVerificationFindUniqueArgs>(args: SelectSubset<T, EmailVerificationFindUniqueArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailVerificationFindUniqueOrThrowArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationFindFirstArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailVerificationFindFirstArgs>(args?: SelectSubset<T, EmailVerificationFindFirstArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationFindFirstOrThrowArgs} args - Arguments to find a EmailVerification
     * @example
     * // Get one EmailVerification
     * const emailVerification = await prisma.emailVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailVerifications
     * const emailVerifications = await prisma.emailVerification.findMany()
     * 
     * // Get first 10 EmailVerifications
     * const emailVerifications = await prisma.emailVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailVerificationWithIdOnly = await prisma.emailVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailVerificationFindManyArgs>(args?: SelectSubset<T, EmailVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailVerification.
     * @param {EmailVerificationCreateArgs} args - Arguments to create a EmailVerification.
     * @example
     * // Create one EmailVerification
     * const EmailVerification = await prisma.emailVerification.create({
     *   data: {
     *     // ... data to create a EmailVerification
     *   }
     * })
     * 
     */
    create<T extends EmailVerificationCreateArgs>(args: SelectSubset<T, EmailVerificationCreateArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailVerifications.
     * @param {EmailVerificationCreateManyArgs} args - Arguments to create many EmailVerifications.
     * @example
     * // Create many EmailVerifications
     * const emailVerification = await prisma.emailVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailVerificationCreateManyArgs>(args?: SelectSubset<T, EmailVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailVerifications and returns the data saved in the database.
     * @param {EmailVerificationCreateManyAndReturnArgs} args - Arguments to create many EmailVerifications.
     * @example
     * // Create many EmailVerifications
     * const emailVerification = await prisma.emailVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailVerifications and only return the `id`
     * const emailVerificationWithIdOnly = await prisma.emailVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailVerification.
     * @param {EmailVerificationDeleteArgs} args - Arguments to delete one EmailVerification.
     * @example
     * // Delete one EmailVerification
     * const EmailVerification = await prisma.emailVerification.delete({
     *   where: {
     *     // ... filter to delete one EmailVerification
     *   }
     * })
     * 
     */
    delete<T extends EmailVerificationDeleteArgs>(args: SelectSubset<T, EmailVerificationDeleteArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailVerification.
     * @param {EmailVerificationUpdateArgs} args - Arguments to update one EmailVerification.
     * @example
     * // Update one EmailVerification
     * const emailVerification = await prisma.emailVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailVerificationUpdateArgs>(args: SelectSubset<T, EmailVerificationUpdateArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailVerifications.
     * @param {EmailVerificationDeleteManyArgs} args - Arguments to filter EmailVerifications to delete.
     * @example
     * // Delete a few EmailVerifications
     * const { count } = await prisma.emailVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailVerificationDeleteManyArgs>(args?: SelectSubset<T, EmailVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailVerifications
     * const emailVerification = await prisma.emailVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailVerificationUpdateManyArgs>(args: SelectSubset<T, EmailVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailVerifications and returns the data updated in the database.
     * @param {EmailVerificationUpdateManyAndReturnArgs} args - Arguments to update many EmailVerifications.
     * @example
     * // Update many EmailVerifications
     * const emailVerification = await prisma.emailVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailVerifications and only return the `id`
     * const emailVerificationWithIdOnly = await prisma.emailVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailVerification.
     * @param {EmailVerificationUpsertArgs} args - Arguments to update or create a EmailVerification.
     * @example
     * // Update or create a EmailVerification
     * const emailVerification = await prisma.emailVerification.upsert({
     *   create: {
     *     // ... data to create a EmailVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailVerification we want to update
     *   }
     * })
     */
    upsert<T extends EmailVerificationUpsertArgs>(args: SelectSubset<T, EmailVerificationUpsertArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationCountArgs} args - Arguments to filter EmailVerifications to count.
     * @example
     * // Count the number of EmailVerifications
     * const count = await prisma.emailVerification.count({
     *   where: {
     *     // ... the filter for the EmailVerifications we want to count
     *   }
     * })
    **/
    count<T extends EmailVerificationCountArgs>(
      args?: Subset<T, EmailVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailVerificationAggregateArgs>(args: Subset<T, EmailVerificationAggregateArgs>): Prisma.PrismaPromise<GetEmailVerificationAggregateType<T>>

    /**
     * Group by EmailVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailVerificationGroupByArgs['orderBy'] }
        : { orderBy?: EmailVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailVerification model
   */
  readonly fields: EmailVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailVerification model
   */
  interface EmailVerificationFieldRefs {
    readonly id: FieldRef<"EmailVerification", 'Int'>
    readonly userId: FieldRef<"EmailVerification", 'Int'>
    readonly otp: FieldRef<"EmailVerification", 'String'>
    readonly createdAt: FieldRef<"EmailVerification", 'DateTime'>
    readonly expiresAt: FieldRef<"EmailVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailVerification findUnique
   */
  export type EmailVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification findUniqueOrThrow
   */
  export type EmailVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification findFirst
   */
  export type EmailVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerifications.
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerifications.
     */
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * EmailVerification findFirstOrThrow
   */
  export type EmailVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerification to fetch.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailVerifications.
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailVerifications.
     */
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * EmailVerification findMany
   */
  export type EmailVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailVerifications to fetch.
     */
    where?: EmailVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailVerifications to fetch.
     */
    orderBy?: EmailVerificationOrderByWithRelationInput | EmailVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailVerifications.
     */
    cursor?: EmailVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailVerifications.
     */
    skip?: number
    distinct?: EmailVerificationScalarFieldEnum | EmailVerificationScalarFieldEnum[]
  }

  /**
   * EmailVerification create
   */
  export type EmailVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailVerification.
     */
    data: XOR<EmailVerificationCreateInput, EmailVerificationUncheckedCreateInput>
  }

  /**
   * EmailVerification createMany
   */
  export type EmailVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailVerifications.
     */
    data: EmailVerificationCreateManyInput | EmailVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailVerification createManyAndReturn
   */
  export type EmailVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many EmailVerifications.
     */
    data: EmailVerificationCreateManyInput | EmailVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerification update
   */
  export type EmailVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailVerification.
     */
    data: XOR<EmailVerificationUpdateInput, EmailVerificationUncheckedUpdateInput>
    /**
     * Choose, which EmailVerification to update.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification updateMany
   */
  export type EmailVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailVerifications.
     */
    data: XOR<EmailVerificationUpdateManyMutationInput, EmailVerificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerifications to update
     */
    where?: EmailVerificationWhereInput
    /**
     * Limit how many EmailVerifications to update.
     */
    limit?: number
  }

  /**
   * EmailVerification updateManyAndReturn
   */
  export type EmailVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * The data used to update EmailVerifications.
     */
    data: XOR<EmailVerificationUpdateManyMutationInput, EmailVerificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailVerifications to update
     */
    where?: EmailVerificationWhereInput
    /**
     * Limit how many EmailVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailVerification upsert
   */
  export type EmailVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailVerification to update in case it exists.
     */
    where: EmailVerificationWhereUniqueInput
    /**
     * In case the EmailVerification found by the `where` argument doesn't exist, create a new EmailVerification with this data.
     */
    create: XOR<EmailVerificationCreateInput, EmailVerificationUncheckedCreateInput>
    /**
     * In case the EmailVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailVerificationUpdateInput, EmailVerificationUncheckedUpdateInput>
  }

  /**
   * EmailVerification delete
   */
  export type EmailVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    /**
     * Filter which EmailVerification to delete.
     */
    where: EmailVerificationWhereUniqueInput
  }

  /**
   * EmailVerification deleteMany
   */
  export type EmailVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailVerifications to delete
     */
    where?: EmailVerificationWhereInput
    /**
     * Limit how many EmailVerifications to delete.
     */
    limit?: number
  }

  /**
   * EmailVerification without action
   */
  export type EmailVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type PostMinAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    question: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    title: string | null
    question: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    question: number
    media: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    question?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    question?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    question?: true
    media?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: number
    userId: number
    title: string
    question: string
    media: JsonValue
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    question?: boolean
    media?: boolean
    Comment?: boolean | Post$CommentArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Tags?: boolean | Post$TagsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    question?: boolean
    media?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    question?: boolean
    media?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    question?: boolean
    media?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "title" | "question" | "media", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | Post$CommentArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    Tags?: boolean | Post$TagsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      User: Prisma.$UserPayload<ExtArgs>
      Tags: Prisma.$TagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      title: string
      question: string
      media: Prisma.JsonValue
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Comment<T extends Post$CommentArgs<ExtArgs> = {}>(args?: Subset<T, Post$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tags<T extends Post$TagsArgs<ExtArgs> = {}>(args?: Subset<T, Post$TagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'Int'>
    readonly userId: FieldRef<"Post", 'Int'>
    readonly title: FieldRef<"Post", 'String'>
    readonly question: FieldRef<"Post", 'String'>
    readonly media: FieldRef<"Post", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.Comment
   */
  export type Post$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.Tags
   */
  export type Post$TagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    cursor?: TagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenAvgAggregateOutputType = {
    userId: number | null
  }

  export type RefreshTokenSumAggregateOutputType = {
    userId: number | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    hashedToken: string | null
    userId: number | null
    revoked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    expireAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    hashedToken: string | null
    userId: number | null
    revoked: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    expireAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    hashedToken: number
    userId: number
    revoked: number
    createdAt: number
    updatedAt: number
    expireAt: number
    _all: number
  }


  export type RefreshTokenAvgAggregateInputType = {
    userId?: true
  }

  export type RefreshTokenSumAggregateInputType = {
    userId?: true
  }

  export type RefreshTokenMinAggregateInputType = {
    id?: true
    hashedToken?: true
    userId?: true
    revoked?: true
    createdAt?: true
    updatedAt?: true
    expireAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    hashedToken?: true
    userId?: true
    revoked?: true
    createdAt?: true
    updatedAt?: true
    expireAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    hashedToken?: true
    userId?: true
    revoked?: true
    createdAt?: true
    updatedAt?: true
    expireAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RefreshTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RefreshTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _avg?: RefreshTokenAvgAggregateInputType
    _sum?: RefreshTokenSumAggregateInputType
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    hashedToken: string
    userId: number
    revoked: boolean
    createdAt: Date
    updatedAt: Date
    expireAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _avg: RefreshTokenAvgAggregateOutputType | null
    _sum: RefreshTokenSumAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hashedToken?: boolean
    userId?: boolean
    revoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expireAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hashedToken?: boolean
    userId?: boolean
    revoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expireAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    hashedToken?: boolean
    userId?: boolean
    revoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expireAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    hashedToken?: boolean
    userId?: boolean
    revoked?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    expireAt?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "hashedToken" | "userId" | "revoked" | "createdAt" | "updatedAt" | "expireAt", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      hashedToken: string
      userId: number
      revoked: boolean
      createdAt: Date
      updatedAt: Date
      expireAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly hashedToken: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'Int'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly expireAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Region
   */

  export type AggregateRegion = {
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  export type RegionAvgAggregateOutputType = {
    id: number | null
  }

  export type RegionSumAggregateOutputType = {
    id: number | null
  }

  export type RegionMinAggregateOutputType = {
    id: number | null
    regionName: string | null
    regionCode: string | null
    mediaUrl: string | null
    description: string | null
  }

  export type RegionMaxAggregateOutputType = {
    id: number | null
    regionName: string | null
    regionCode: string | null
    mediaUrl: string | null
    description: string | null
  }

  export type RegionCountAggregateOutputType = {
    id: number
    regionName: number
    regionCode: number
    mediaUrl: number
    description: number
    _all: number
  }


  export type RegionAvgAggregateInputType = {
    id?: true
  }

  export type RegionSumAggregateInputType = {
    id?: true
  }

  export type RegionMinAggregateInputType = {
    id?: true
    regionName?: true
    regionCode?: true
    mediaUrl?: true
    description?: true
  }

  export type RegionMaxAggregateInputType = {
    id?: true
    regionName?: true
    regionCode?: true
    mediaUrl?: true
    description?: true
  }

  export type RegionCountAggregateInputType = {
    id?: true
    regionName?: true
    regionCode?: true
    mediaUrl?: true
    description?: true
    _all?: true
  }

  export type RegionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Region to aggregate.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionMaxAggregateInputType
  }

  export type GetRegionAggregateType<T extends RegionAggregateArgs> = {
        [P in keyof T & keyof AggregateRegion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegion[P]>
      : GetScalarType<T[P], AggregateRegion[P]>
  }




  export type RegionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionWhereInput
    orderBy?: RegionOrderByWithAggregationInput | RegionOrderByWithAggregationInput[]
    by: RegionScalarFieldEnum[] | RegionScalarFieldEnum
    having?: RegionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionCountAggregateInputType | true
    _avg?: RegionAvgAggregateInputType
    _sum?: RegionSumAggregateInputType
    _min?: RegionMinAggregateInputType
    _max?: RegionMaxAggregateInputType
  }

  export type RegionGroupByOutputType = {
    id: number
    regionName: string
    regionCode: string
    mediaUrl: string | null
    description: string | null
    _count: RegionCountAggregateOutputType | null
    _avg: RegionAvgAggregateOutputType | null
    _sum: RegionSumAggregateOutputType | null
    _min: RegionMinAggregateOutputType | null
    _max: RegionMaxAggregateOutputType | null
  }

  type GetRegionGroupByPayload<T extends RegionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionGroupByOutputType[P]>
            : GetScalarType<T[P], RegionGroupByOutputType[P]>
        }
      >
    >


  export type RegionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionName?: boolean
    regionCode?: boolean
    mediaUrl?: boolean
    description?: boolean
    puzzle_game?: boolean | Region$puzzle_gameArgs<ExtArgs>
    quiz_game?: boolean | Region$quiz_gameArgs<ExtArgs>
    treasure_game?: boolean | Region$treasure_gameArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["region"]>

  export type RegionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionName?: boolean
    regionCode?: boolean
    mediaUrl?: boolean
    description?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionName?: boolean
    regionCode?: boolean
    mediaUrl?: boolean
    description?: boolean
  }, ExtArgs["result"]["region"]>

  export type RegionSelectScalar = {
    id?: boolean
    regionName?: boolean
    regionCode?: boolean
    mediaUrl?: boolean
    description?: boolean
  }

  export type RegionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionName" | "regionCode" | "mediaUrl" | "description", ExtArgs["result"]["region"]>
  export type RegionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | Region$puzzle_gameArgs<ExtArgs>
    quiz_game?: boolean | Region$quiz_gameArgs<ExtArgs>
    treasure_game?: boolean | Region$treasure_gameArgs<ExtArgs>
    _count?: boolean | RegionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RegionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RegionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RegionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Region"
    objects: {
      puzzle_game: Prisma.$puzzle_gamePayload<ExtArgs>[]
      quiz_game: Prisma.$quiz_gamePayload<ExtArgs>[]
      treasure_game: Prisma.$treasure_gamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionName: string
      regionCode: string
      mediaUrl: string | null
      description: string | null
    }, ExtArgs["result"]["region"]>
    composites: {}
  }

  type RegionGetPayload<S extends boolean | null | undefined | RegionDefaultArgs> = $Result.GetResult<Prisma.$RegionPayload, S>

  type RegionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RegionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegionCountAggregateInputType | true
    }

  export interface RegionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Region'], meta: { name: 'Region' } }
    /**
     * Find zero or one Region that matches the filter.
     * @param {RegionFindUniqueArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionFindUniqueArgs>(args: SelectSubset<T, RegionFindUniqueArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Region that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RegionFindUniqueOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionFindFirstArgs>(args?: SelectSubset<T, RegionFindFirstArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Region that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindFirstOrThrowArgs} args - Arguments to find a Region
     * @example
     * // Get one Region
     * const region = await prisma.region.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.region.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.region.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionWithIdOnly = await prisma.region.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionFindManyArgs>(args?: SelectSubset<T, RegionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Region.
     * @param {RegionCreateArgs} args - Arguments to create a Region.
     * @example
     * // Create one Region
     * const Region = await prisma.region.create({
     *   data: {
     *     // ... data to create a Region
     *   }
     * })
     * 
     */
    create<T extends RegionCreateArgs>(args: SelectSubset<T, RegionCreateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regions.
     * @param {RegionCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionCreateManyArgs>(args?: SelectSubset<T, RegionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regions and returns the data saved in the database.
     * @param {RegionCreateManyAndReturnArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const region = await prisma.region.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegionCreateManyAndReturnArgs>(args?: SelectSubset<T, RegionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Region.
     * @param {RegionDeleteArgs} args - Arguments to delete one Region.
     * @example
     * // Delete one Region
     * const Region = await prisma.region.delete({
     *   where: {
     *     // ... filter to delete one Region
     *   }
     * })
     * 
     */
    delete<T extends RegionDeleteArgs>(args: SelectSubset<T, RegionDeleteArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Region.
     * @param {RegionUpdateArgs} args - Arguments to update one Region.
     * @example
     * // Update one Region
     * const region = await prisma.region.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionUpdateArgs>(args: SelectSubset<T, RegionUpdateArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regions.
     * @param {RegionDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.region.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionDeleteManyArgs>(args?: SelectSubset<T, RegionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionUpdateManyArgs>(args: SelectSubset<T, RegionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions and returns the data updated in the database.
     * @param {RegionUpdateManyAndReturnArgs} args - Arguments to update many Regions.
     * @example
     * // Update many Regions
     * const region = await prisma.region.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Regions and only return the `id`
     * const regionWithIdOnly = await prisma.region.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RegionUpdateManyAndReturnArgs>(args: SelectSubset<T, RegionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Region.
     * @param {RegionUpsertArgs} args - Arguments to update or create a Region.
     * @example
     * // Update or create a Region
     * const region = await prisma.region.upsert({
     *   create: {
     *     // ... data to create a Region
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Region we want to update
     *   }
     * })
     */
    upsert<T extends RegionUpsertArgs>(args: SelectSubset<T, RegionUpsertArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.region.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionCountArgs>(
      args?: Subset<T, RegionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionAggregateArgs>(args: Subset<T, RegionAggregateArgs>): Prisma.PrismaPromise<GetRegionAggregateType<T>>

    /**
     * Group by Region.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionGroupByArgs['orderBy'] }
        : { orderBy?: RegionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Region model
   */
  readonly fields: RegionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Region.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    puzzle_game<T extends Region$puzzle_gameArgs<ExtArgs> = {}>(args?: Subset<T, Region$puzzle_gameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quiz_game<T extends Region$quiz_gameArgs<ExtArgs> = {}>(args?: Subset<T, Region$quiz_gameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    treasure_game<T extends Region$treasure_gameArgs<ExtArgs> = {}>(args?: Subset<T, Region$treasure_gameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Region model
   */
  interface RegionFieldRefs {
    readonly id: FieldRef<"Region", 'Int'>
    readonly regionName: FieldRef<"Region", 'String'>
    readonly regionCode: FieldRef<"Region", 'String'>
    readonly mediaUrl: FieldRef<"Region", 'String'>
    readonly description: FieldRef<"Region", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Region findUnique
   */
  export type RegionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findUniqueOrThrow
   */
  export type RegionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region findFirst
   */
  export type RegionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findFirstOrThrow
   */
  export type RegionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Region to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region findMany
   */
  export type RegionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionOrderByWithRelationInput | RegionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionScalarFieldEnum | RegionScalarFieldEnum[]
  }

  /**
   * Region create
   */
  export type RegionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to create a Region.
     */
    data: XOR<RegionCreateInput, RegionUncheckedCreateInput>
  }

  /**
   * Region createMany
   */
  export type RegionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region createManyAndReturn
   */
  export type RegionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to create many Regions.
     */
    data: RegionCreateManyInput | RegionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Region update
   */
  export type RegionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The data needed to update a Region.
     */
    data: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
    /**
     * Choose, which Region to update.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region updateMany
   */
  export type RegionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region updateManyAndReturn
   */
  export type RegionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionUpdateManyMutationInput, RegionUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to update.
     */
    limit?: number
  }

  /**
   * Region upsert
   */
  export type RegionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * The filter to search for the Region to update in case it exists.
     */
    where: RegionWhereUniqueInput
    /**
     * In case the Region found by the `where` argument doesn't exist, create a new Region with this data.
     */
    create: XOR<RegionCreateInput, RegionUncheckedCreateInput>
    /**
     * In case the Region was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionUpdateInput, RegionUncheckedUpdateInput>
  }

  /**
   * Region delete
   */
  export type RegionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    /**
     * Filter which Region to delete.
     */
    where: RegionWhereUniqueInput
  }

  /**
   * Region deleteMany
   */
  export type RegionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionWhereInput
    /**
     * Limit how many Regions to delete.
     */
    limit?: number
  }

  /**
   * Region.puzzle_game
   */
  export type Region$puzzle_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    where?: puzzle_gameWhereInput
    orderBy?: puzzle_gameOrderByWithRelationInput | puzzle_gameOrderByWithRelationInput[]
    cursor?: puzzle_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Puzzle_gameScalarFieldEnum | Puzzle_gameScalarFieldEnum[]
  }

  /**
   * Region.quiz_game
   */
  export type Region$quiz_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    where?: quiz_gameWhereInput
    orderBy?: quiz_gameOrderByWithRelationInput | quiz_gameOrderByWithRelationInput[]
    cursor?: quiz_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quiz_gameScalarFieldEnum | Quiz_gameScalarFieldEnum[]
  }

  /**
   * Region.treasure_game
   */
  export type Region$treasure_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    where?: treasure_gameWhereInput
    orderBy?: treasure_gameOrderByWithRelationInput | treasure_gameOrderByWithRelationInput[]
    cursor?: treasure_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Treasure_gameScalarFieldEnum | Treasure_gameScalarFieldEnum[]
  }

  /**
   * Region without action
   */
  export type RegionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
  }


  /**
   * Model Tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsAvgAggregateOutputType = {
    id: number | null
  }

  export type TagsSumAggregateOutputType = {
    id: number | null
  }

  export type TagsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TagsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TagsAvgAggregateInputType = {
    id?: true
  }

  export type TagsSumAggregateInputType = {
    id?: true
  }

  export type TagsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to aggregate.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type TagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagsWhereInput
    orderBy?: TagsOrderByWithAggregationInput | TagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: TagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _avg?: TagsAvgAggregateInputType
    _sum?: TagsSumAggregateInputType
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: number
    name: string
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends TagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type TagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    Post?: boolean | Tags$PostArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type TagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tags"]>

  export type TagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tags"]>

  export type TagsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["tags"]>
  export type TagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Post?: boolean | Tags$PostArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tags"
    objects: {
      Post: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type TagsGetPayload<S extends boolean | null | undefined | TagsDefaultArgs> = $Result.GetResult<Prisma.$TagsPayload, S>

  type TagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface TagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tags'], meta: { name: 'Tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {TagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagsFindUniqueArgs>(args: SelectSubset<T, TagsFindUniqueArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagsFindUniqueOrThrowArgs>(args: SelectSubset<T, TagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagsFindFirstArgs>(args?: SelectSubset<T, TagsFindFirstArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagsFindFirstOrThrowArgs>(args?: SelectSubset<T, TagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagsFindManyArgs>(args?: SelectSubset<T, TagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {TagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends TagsCreateArgs>(args: SelectSubset<T, TagsCreateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagsCreateManyArgs>(args?: SelectSubset<T, TagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagsCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagsCreateManyAndReturnArgs>(args?: SelectSubset<T, TagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tags.
     * @param {TagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends TagsDeleteArgs>(args: SelectSubset<T, TagsDeleteArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {TagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagsUpdateArgs>(args: SelectSubset<T, TagsUpdateArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagsDeleteManyArgs>(args?: SelectSubset<T, TagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagsUpdateManyArgs>(args: SelectSubset<T, TagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagsUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagsUpdateManyAndReturnArgs>(args: SelectSubset<T, TagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tags.
     * @param {TagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends TagsUpsertArgs>(args: SelectSubset<T, TagsUpsertArgs<ExtArgs>>): Prisma__TagsClient<$Result.GetResult<Prisma.$TagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagsCountArgs>(
      args?: Subset<T, TagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagsGroupByArgs['orderBy'] }
        : { orderBy?: TagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tags model
   */
  readonly fields: TagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Post<T extends Tags$PostArgs<ExtArgs> = {}>(args?: Subset<T, Tags$PostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tags model
   */
  interface TagsFieldRefs {
    readonly id: FieldRef<"Tags", 'Int'>
    readonly name: FieldRef<"Tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Tags findUnique
   */
  export type TagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findUniqueOrThrow
   */
  export type TagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags findFirst
   */
  export type TagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findFirstOrThrow
   */
  export type TagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags findMany
   */
  export type TagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagsOrderByWithRelationInput | TagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * Tags create
   */
  export type TagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to create a Tags.
     */
    data: XOR<TagsCreateInput, TagsUncheckedCreateInput>
  }

  /**
   * Tags createMany
   */
  export type TagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tags createManyAndReturn
   */
  export type TagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagsCreateManyInput | TagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tags update
   */
  export type TagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The data needed to update a Tags.
     */
    data: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
    /**
     * Choose, which Tags to update.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags updateMany
   */
  export type TagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tags updateManyAndReturn
   */
  export type TagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tags upsert
   */
  export type TagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * The filter to search for the Tags to update in case it exists.
     */
    where: TagsWhereUniqueInput
    /**
     * In case the Tags found by the `where` argument doesn't exist, create a new Tags with this data.
     */
    create: XOR<TagsCreateInput, TagsUncheckedCreateInput>
    /**
     * In case the Tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagsUpdateInput, TagsUncheckedUpdateInput>
  }

  /**
   * Tags delete
   */
  export type TagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
    /**
     * Filter which Tags to delete.
     */
    where: TagsWhereUniqueInput
  }

  /**
   * Tags deleteMany
   */
  export type TagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagsWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tags.Post
   */
  export type Tags$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Tags without action
   */
  export type TagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tags
     */
    select?: TagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tags
     */
    omit?: TagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagsInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    full_name: string | null
    username: string | null
    email: string | null
    password: string | null
    avatarUrl: string | null
    dateOfBirth: Date | null
    location: string | null
    gender: string | null
    isVerified: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    full_name: string | null
    username: string | null
    email: string | null
    password: string | null
    avatarUrl: string | null
    dateOfBirth: Date | null
    location: string | null
    gender: string | null
    isVerified: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    full_name: number
    username: number
    email: number
    password: number
    avatarUrl: number
    dateOfBirth: number
    location: number
    gender: number
    isVerified: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    full_name?: true
    username?: true
    email?: true
    password?: true
    avatarUrl?: true
    dateOfBirth?: true
    location?: true
    gender?: true
    isVerified?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    full_name?: true
    username?: true
    email?: true
    password?: true
    avatarUrl?: true
    dateOfBirth?: true
    location?: true
    gender?: true
    isVerified?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    full_name?: true
    username?: true
    email?: true
    password?: true
    avatarUrl?: true
    dateOfBirth?: true
    location?: true
    gender?: true
    isVerified?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    full_name: string
    username: string | null
    email: string
    password: string
    avatarUrl: string | null
    dateOfBirth: Date | null
    location: string | null
    gender: string | null
    isVerified: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    location?: boolean
    gender?: boolean
    isVerified?: boolean
    Achievement?: boolean | User$AchievementArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    EmailVerification?: boolean | User$EmailVerificationArgs<ExtArgs>
    Post?: boolean | User$PostArgs<ExtArgs>
    RefreshToken?: boolean | User$RefreshTokenArgs<ExtArgs>
    comment_reaction?: boolean | User$comment_reactionArgs<ExtArgs>
    password_resets?: boolean | User$password_resetsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    location?: boolean
    gender?: boolean
    isVerified?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    location?: boolean
    gender?: boolean
    isVerified?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    full_name?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    location?: boolean
    gender?: boolean
    isVerified?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "username" | "email" | "password" | "avatarUrl" | "dateOfBirth" | "location" | "gender" | "isVerified", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Achievement?: boolean | User$AchievementArgs<ExtArgs>
    Comment?: boolean | User$CommentArgs<ExtArgs>
    EmailVerification?: boolean | User$EmailVerificationArgs<ExtArgs>
    Post?: boolean | User$PostArgs<ExtArgs>
    RefreshToken?: boolean | User$RefreshTokenArgs<ExtArgs>
    comment_reaction?: boolean | User$comment_reactionArgs<ExtArgs>
    password_resets?: boolean | User$password_resetsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Achievement: Prisma.$AchievementPayload<ExtArgs>[]
      Comment: Prisma.$CommentPayload<ExtArgs>[]
      EmailVerification: Prisma.$EmailVerificationPayload<ExtArgs> | null
      Post: Prisma.$PostPayload<ExtArgs>[]
      RefreshToken: Prisma.$RefreshTokenPayload<ExtArgs>[]
      comment_reaction: Prisma.$comment_reactionPayload<ExtArgs>[]
      password_resets: Prisma.$password_resetsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      full_name: string
      username: string | null
      email: string
      password: string
      avatarUrl: string | null
      dateOfBirth: Date | null
      location: string | null
      gender: string | null
      isVerified: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Achievement<T extends User$AchievementArgs<ExtArgs> = {}>(args?: Subset<T, User$AchievementArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AchievementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Comment<T extends User$CommentArgs<ExtArgs> = {}>(args?: Subset<T, User$CommentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    EmailVerification<T extends User$EmailVerificationArgs<ExtArgs> = {}>(args?: Subset<T, User$EmailVerificationArgs<ExtArgs>>): Prisma__EmailVerificationClient<$Result.GetResult<Prisma.$EmailVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Post<T extends User$PostArgs<ExtArgs> = {}>(args?: Subset<T, User$PostArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    RefreshToken<T extends User$RefreshTokenArgs<ExtArgs> = {}>(args?: Subset<T, User$RefreshTokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comment_reaction<T extends User$comment_reactionArgs<ExtArgs> = {}>(args?: Subset<T, User$comment_reactionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    password_resets<T extends User$password_resetsArgs<ExtArgs> = {}>(args?: Subset<T, User$password_resetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly location: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.Achievement
   */
  export type User$AchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Achievement
     */
    select?: AchievementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Achievement
     */
    omit?: AchievementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AchievementInclude<ExtArgs> | null
    where?: AchievementWhereInput
    orderBy?: AchievementOrderByWithRelationInput | AchievementOrderByWithRelationInput[]
    cursor?: AchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AchievementScalarFieldEnum | AchievementScalarFieldEnum[]
  }

  /**
   * User.Comment
   */
  export type User$CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.EmailVerification
   */
  export type User$EmailVerificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailVerification
     */
    select?: EmailVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailVerification
     */
    omit?: EmailVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailVerificationInclude<ExtArgs> | null
    where?: EmailVerificationWhereInput
  }

  /**
   * User.Post
   */
  export type User$PostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * User.RefreshToken
   */
  export type User$RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.comment_reaction
   */
  export type User$comment_reactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    where?: comment_reactionWhereInput
    orderBy?: comment_reactionOrderByWithRelationInput | comment_reactionOrderByWithRelationInput[]
    cursor?: comment_reactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Comment_reactionScalarFieldEnum | Comment_reactionScalarFieldEnum[]
  }

  /**
   * User.password_resets
   */
  export type User$password_resetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    where?: password_resetsWhereInput
    orderBy?: password_resetsOrderByWithRelationInput | password_resetsOrderByWithRelationInput[]
    cursor?: password_resetsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Password_resetsScalarFieldEnum | Password_resetsScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model comment_reaction
   */

  export type AggregateComment_reaction = {
    _count: Comment_reactionCountAggregateOutputType | null
    _avg: Comment_reactionAvgAggregateOutputType | null
    _sum: Comment_reactionSumAggregateOutputType | null
    _min: Comment_reactionMinAggregateOutputType | null
    _max: Comment_reactionMaxAggregateOutputType | null
  }

  export type Comment_reactionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    comment_id: number | null
  }

  export type Comment_reactionSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    comment_id: number | null
  }

  export type Comment_reactionMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    comment_id: number | null
    reaction_type: $Enums.reaction_type_enum | null
    created_at: Date | null
  }

  export type Comment_reactionMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    comment_id: number | null
    reaction_type: $Enums.reaction_type_enum | null
    created_at: Date | null
  }

  export type Comment_reactionCountAggregateOutputType = {
    id: number
    user_id: number
    comment_id: number
    reaction_type: number
    created_at: number
    _all: number
  }


  export type Comment_reactionAvgAggregateInputType = {
    id?: true
    user_id?: true
    comment_id?: true
  }

  export type Comment_reactionSumAggregateInputType = {
    id?: true
    user_id?: true
    comment_id?: true
  }

  export type Comment_reactionMinAggregateInputType = {
    id?: true
    user_id?: true
    comment_id?: true
    reaction_type?: true
    created_at?: true
  }

  export type Comment_reactionMaxAggregateInputType = {
    id?: true
    user_id?: true
    comment_id?: true
    reaction_type?: true
    created_at?: true
  }

  export type Comment_reactionCountAggregateInputType = {
    id?: true
    user_id?: true
    comment_id?: true
    reaction_type?: true
    created_at?: true
    _all?: true
  }

  export type Comment_reactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comment_reaction to aggregate.
     */
    where?: comment_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comment_reactions to fetch.
     */
    orderBy?: comment_reactionOrderByWithRelationInput | comment_reactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comment_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comment_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comment_reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comment_reactions
    **/
    _count?: true | Comment_reactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Comment_reactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Comment_reactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Comment_reactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Comment_reactionMaxAggregateInputType
  }

  export type GetComment_reactionAggregateType<T extends Comment_reactionAggregateArgs> = {
        [P in keyof T & keyof AggregateComment_reaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment_reaction[P]>
      : GetScalarType<T[P], AggregateComment_reaction[P]>
  }




  export type comment_reactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comment_reactionWhereInput
    orderBy?: comment_reactionOrderByWithAggregationInput | comment_reactionOrderByWithAggregationInput[]
    by: Comment_reactionScalarFieldEnum[] | Comment_reactionScalarFieldEnum
    having?: comment_reactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Comment_reactionCountAggregateInputType | true
    _avg?: Comment_reactionAvgAggregateInputType
    _sum?: Comment_reactionSumAggregateInputType
    _min?: Comment_reactionMinAggregateInputType
    _max?: Comment_reactionMaxAggregateInputType
  }

  export type Comment_reactionGroupByOutputType = {
    id: number
    user_id: number
    comment_id: number
    reaction_type: $Enums.reaction_type_enum
    created_at: Date | null
    _count: Comment_reactionCountAggregateOutputType | null
    _avg: Comment_reactionAvgAggregateOutputType | null
    _sum: Comment_reactionSumAggregateOutputType | null
    _min: Comment_reactionMinAggregateOutputType | null
    _max: Comment_reactionMaxAggregateOutputType | null
  }

  type GetComment_reactionGroupByPayload<T extends comment_reactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Comment_reactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Comment_reactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Comment_reactionGroupByOutputType[P]>
            : GetScalarType<T[P], Comment_reactionGroupByOutputType[P]>
        }
      >
    >


  export type comment_reactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    comment_id?: boolean
    reaction_type?: boolean
    created_at?: boolean
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment_reaction"]>

  export type comment_reactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    comment_id?: boolean
    reaction_type?: boolean
    created_at?: boolean
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment_reaction"]>

  export type comment_reactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    comment_id?: boolean
    reaction_type?: boolean
    created_at?: boolean
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment_reaction"]>

  export type comment_reactionSelectScalar = {
    id?: boolean
    user_id?: boolean
    comment_id?: boolean
    reaction_type?: boolean
    created_at?: boolean
  }

  export type comment_reactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "comment_id" | "reaction_type" | "created_at", ExtArgs["result"]["comment_reaction"]>
  export type comment_reactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type comment_reactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type comment_reactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Comment?: boolean | CommentDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $comment_reactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comment_reaction"
    objects: {
      Comment: Prisma.$CommentPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: number
      comment_id: number
      reaction_type: $Enums.reaction_type_enum
      created_at: Date | null
    }, ExtArgs["result"]["comment_reaction"]>
    composites: {}
  }

  type comment_reactionGetPayload<S extends boolean | null | undefined | comment_reactionDefaultArgs> = $Result.GetResult<Prisma.$comment_reactionPayload, S>

  type comment_reactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<comment_reactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Comment_reactionCountAggregateInputType | true
    }

  export interface comment_reactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comment_reaction'], meta: { name: 'comment_reaction' } }
    /**
     * Find zero or one Comment_reaction that matches the filter.
     * @param {comment_reactionFindUniqueArgs} args - Arguments to find a Comment_reaction
     * @example
     * // Get one Comment_reaction
     * const comment_reaction = await prisma.comment_reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comment_reactionFindUniqueArgs>(args: SelectSubset<T, comment_reactionFindUniqueArgs<ExtArgs>>): Prisma__comment_reactionClient<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment_reaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {comment_reactionFindUniqueOrThrowArgs} args - Arguments to find a Comment_reaction
     * @example
     * // Get one Comment_reaction
     * const comment_reaction = await prisma.comment_reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comment_reactionFindUniqueOrThrowArgs>(args: SelectSubset<T, comment_reactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comment_reactionClient<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment_reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comment_reactionFindFirstArgs} args - Arguments to find a Comment_reaction
     * @example
     * // Get one Comment_reaction
     * const comment_reaction = await prisma.comment_reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comment_reactionFindFirstArgs>(args?: SelectSubset<T, comment_reactionFindFirstArgs<ExtArgs>>): Prisma__comment_reactionClient<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment_reaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comment_reactionFindFirstOrThrowArgs} args - Arguments to find a Comment_reaction
     * @example
     * // Get one Comment_reaction
     * const comment_reaction = await prisma.comment_reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comment_reactionFindFirstOrThrowArgs>(args?: SelectSubset<T, comment_reactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__comment_reactionClient<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comment_reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comment_reactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comment_reactions
     * const comment_reactions = await prisma.comment_reaction.findMany()
     * 
     * // Get first 10 Comment_reactions
     * const comment_reactions = await prisma.comment_reaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comment_reactionWithIdOnly = await prisma.comment_reaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends comment_reactionFindManyArgs>(args?: SelectSubset<T, comment_reactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment_reaction.
     * @param {comment_reactionCreateArgs} args - Arguments to create a Comment_reaction.
     * @example
     * // Create one Comment_reaction
     * const Comment_reaction = await prisma.comment_reaction.create({
     *   data: {
     *     // ... data to create a Comment_reaction
     *   }
     * })
     * 
     */
    create<T extends comment_reactionCreateArgs>(args: SelectSubset<T, comment_reactionCreateArgs<ExtArgs>>): Prisma__comment_reactionClient<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comment_reactions.
     * @param {comment_reactionCreateManyArgs} args - Arguments to create many Comment_reactions.
     * @example
     * // Create many Comment_reactions
     * const comment_reaction = await prisma.comment_reaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comment_reactionCreateManyArgs>(args?: SelectSubset<T, comment_reactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comment_reactions and returns the data saved in the database.
     * @param {comment_reactionCreateManyAndReturnArgs} args - Arguments to create many Comment_reactions.
     * @example
     * // Create many Comment_reactions
     * const comment_reaction = await prisma.comment_reaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comment_reactions and only return the `id`
     * const comment_reactionWithIdOnly = await prisma.comment_reaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends comment_reactionCreateManyAndReturnArgs>(args?: SelectSubset<T, comment_reactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment_reaction.
     * @param {comment_reactionDeleteArgs} args - Arguments to delete one Comment_reaction.
     * @example
     * // Delete one Comment_reaction
     * const Comment_reaction = await prisma.comment_reaction.delete({
     *   where: {
     *     // ... filter to delete one Comment_reaction
     *   }
     * })
     * 
     */
    delete<T extends comment_reactionDeleteArgs>(args: SelectSubset<T, comment_reactionDeleteArgs<ExtArgs>>): Prisma__comment_reactionClient<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment_reaction.
     * @param {comment_reactionUpdateArgs} args - Arguments to update one Comment_reaction.
     * @example
     * // Update one Comment_reaction
     * const comment_reaction = await prisma.comment_reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comment_reactionUpdateArgs>(args: SelectSubset<T, comment_reactionUpdateArgs<ExtArgs>>): Prisma__comment_reactionClient<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comment_reactions.
     * @param {comment_reactionDeleteManyArgs} args - Arguments to filter Comment_reactions to delete.
     * @example
     * // Delete a few Comment_reactions
     * const { count } = await prisma.comment_reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comment_reactionDeleteManyArgs>(args?: SelectSubset<T, comment_reactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comment_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comment_reactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comment_reactions
     * const comment_reaction = await prisma.comment_reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comment_reactionUpdateManyArgs>(args: SelectSubset<T, comment_reactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comment_reactions and returns the data updated in the database.
     * @param {comment_reactionUpdateManyAndReturnArgs} args - Arguments to update many Comment_reactions.
     * @example
     * // Update many Comment_reactions
     * const comment_reaction = await prisma.comment_reaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comment_reactions and only return the `id`
     * const comment_reactionWithIdOnly = await prisma.comment_reaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends comment_reactionUpdateManyAndReturnArgs>(args: SelectSubset<T, comment_reactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment_reaction.
     * @param {comment_reactionUpsertArgs} args - Arguments to update or create a Comment_reaction.
     * @example
     * // Update or create a Comment_reaction
     * const comment_reaction = await prisma.comment_reaction.upsert({
     *   create: {
     *     // ... data to create a Comment_reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment_reaction we want to update
     *   }
     * })
     */
    upsert<T extends comment_reactionUpsertArgs>(args: SelectSubset<T, comment_reactionUpsertArgs<ExtArgs>>): Prisma__comment_reactionClient<$Result.GetResult<Prisma.$comment_reactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comment_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comment_reactionCountArgs} args - Arguments to filter Comment_reactions to count.
     * @example
     * // Count the number of Comment_reactions
     * const count = await prisma.comment_reaction.count({
     *   where: {
     *     // ... the filter for the Comment_reactions we want to count
     *   }
     * })
    **/
    count<T extends comment_reactionCountArgs>(
      args?: Subset<T, comment_reactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Comment_reactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment_reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Comment_reactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Comment_reactionAggregateArgs>(args: Subset<T, Comment_reactionAggregateArgs>): Prisma.PrismaPromise<GetComment_reactionAggregateType<T>>

    /**
     * Group by Comment_reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comment_reactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comment_reactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comment_reactionGroupByArgs['orderBy'] }
        : { orderBy?: comment_reactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comment_reactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComment_reactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comment_reaction model
   */
  readonly fields: comment_reactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comment_reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comment_reactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comment_reaction model
   */
  interface comment_reactionFieldRefs {
    readonly id: FieldRef<"comment_reaction", 'Int'>
    readonly user_id: FieldRef<"comment_reaction", 'Int'>
    readonly comment_id: FieldRef<"comment_reaction", 'Int'>
    readonly reaction_type: FieldRef<"comment_reaction", 'reaction_type_enum'>
    readonly created_at: FieldRef<"comment_reaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * comment_reaction findUnique
   */
  export type comment_reactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    /**
     * Filter, which comment_reaction to fetch.
     */
    where: comment_reactionWhereUniqueInput
  }

  /**
   * comment_reaction findUniqueOrThrow
   */
  export type comment_reactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    /**
     * Filter, which comment_reaction to fetch.
     */
    where: comment_reactionWhereUniqueInput
  }

  /**
   * comment_reaction findFirst
   */
  export type comment_reactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    /**
     * Filter, which comment_reaction to fetch.
     */
    where?: comment_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comment_reactions to fetch.
     */
    orderBy?: comment_reactionOrderByWithRelationInput | comment_reactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comment_reactions.
     */
    cursor?: comment_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comment_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comment_reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comment_reactions.
     */
    distinct?: Comment_reactionScalarFieldEnum | Comment_reactionScalarFieldEnum[]
  }

  /**
   * comment_reaction findFirstOrThrow
   */
  export type comment_reactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    /**
     * Filter, which comment_reaction to fetch.
     */
    where?: comment_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comment_reactions to fetch.
     */
    orderBy?: comment_reactionOrderByWithRelationInput | comment_reactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comment_reactions.
     */
    cursor?: comment_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comment_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comment_reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comment_reactions.
     */
    distinct?: Comment_reactionScalarFieldEnum | Comment_reactionScalarFieldEnum[]
  }

  /**
   * comment_reaction findMany
   */
  export type comment_reactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    /**
     * Filter, which comment_reactions to fetch.
     */
    where?: comment_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comment_reactions to fetch.
     */
    orderBy?: comment_reactionOrderByWithRelationInput | comment_reactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comment_reactions.
     */
    cursor?: comment_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comment_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comment_reactions.
     */
    skip?: number
    distinct?: Comment_reactionScalarFieldEnum | Comment_reactionScalarFieldEnum[]
  }

  /**
   * comment_reaction create
   */
  export type comment_reactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    /**
     * The data needed to create a comment_reaction.
     */
    data: XOR<comment_reactionCreateInput, comment_reactionUncheckedCreateInput>
  }

  /**
   * comment_reaction createMany
   */
  export type comment_reactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comment_reactions.
     */
    data: comment_reactionCreateManyInput | comment_reactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comment_reaction createManyAndReturn
   */
  export type comment_reactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * The data used to create many comment_reactions.
     */
    data: comment_reactionCreateManyInput | comment_reactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comment_reaction update
   */
  export type comment_reactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    /**
     * The data needed to update a comment_reaction.
     */
    data: XOR<comment_reactionUpdateInput, comment_reactionUncheckedUpdateInput>
    /**
     * Choose, which comment_reaction to update.
     */
    where: comment_reactionWhereUniqueInput
  }

  /**
   * comment_reaction updateMany
   */
  export type comment_reactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comment_reactions.
     */
    data: XOR<comment_reactionUpdateManyMutationInput, comment_reactionUncheckedUpdateManyInput>
    /**
     * Filter which comment_reactions to update
     */
    where?: comment_reactionWhereInput
    /**
     * Limit how many comment_reactions to update.
     */
    limit?: number
  }

  /**
   * comment_reaction updateManyAndReturn
   */
  export type comment_reactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * The data used to update comment_reactions.
     */
    data: XOR<comment_reactionUpdateManyMutationInput, comment_reactionUncheckedUpdateManyInput>
    /**
     * Filter which comment_reactions to update
     */
    where?: comment_reactionWhereInput
    /**
     * Limit how many comment_reactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * comment_reaction upsert
   */
  export type comment_reactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    /**
     * The filter to search for the comment_reaction to update in case it exists.
     */
    where: comment_reactionWhereUniqueInput
    /**
     * In case the comment_reaction found by the `where` argument doesn't exist, create a new comment_reaction with this data.
     */
    create: XOR<comment_reactionCreateInput, comment_reactionUncheckedCreateInput>
    /**
     * In case the comment_reaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comment_reactionUpdateInput, comment_reactionUncheckedUpdateInput>
  }

  /**
   * comment_reaction delete
   */
  export type comment_reactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
    /**
     * Filter which comment_reaction to delete.
     */
    where: comment_reactionWhereUniqueInput
  }

  /**
   * comment_reaction deleteMany
   */
  export type comment_reactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comment_reactions to delete
     */
    where?: comment_reactionWhereInput
    /**
     * Limit how many comment_reactions to delete.
     */
    limit?: number
  }

  /**
   * comment_reaction without action
   */
  export type comment_reactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment_reaction
     */
    select?: comment_reactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment_reaction
     */
    omit?: comment_reactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comment_reactionInclude<ExtArgs> | null
  }


  /**
   * Model game_type
   */

  export type AggregateGame_type = {
    _count: Game_typeCountAggregateOutputType | null
    _avg: Game_typeAvgAggregateOutputType | null
    _sum: Game_typeSumAggregateOutputType | null
    _min: Game_typeMinAggregateOutputType | null
    _max: Game_typeMaxAggregateOutputType | null
  }

  export type Game_typeAvgAggregateOutputType = {
    id: number | null
  }

  export type Game_typeSumAggregateOutputType = {
    id: number | null
  }

  export type Game_typeMinAggregateOutputType = {
    id: number | null
    code: $Enums.game_code_enum | null
    name: string | null
  }

  export type Game_typeMaxAggregateOutputType = {
    id: number | null
    code: $Enums.game_code_enum | null
    name: string | null
  }

  export type Game_typeCountAggregateOutputType = {
    id: number
    code: number
    name: number
    _all: number
  }


  export type Game_typeAvgAggregateInputType = {
    id?: true
  }

  export type Game_typeSumAggregateInputType = {
    id?: true
  }

  export type Game_typeMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type Game_typeMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
  }

  export type Game_typeCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    _all?: true
  }

  export type Game_typeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_type to aggregate.
     */
    where?: game_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_types to fetch.
     */
    orderBy?: game_typeOrderByWithRelationInput | game_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: game_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned game_types
    **/
    _count?: true | Game_typeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Game_typeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Game_typeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Game_typeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Game_typeMaxAggregateInputType
  }

  export type GetGame_typeAggregateType<T extends Game_typeAggregateArgs> = {
        [P in keyof T & keyof AggregateGame_type]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGame_type[P]>
      : GetScalarType<T[P], AggregateGame_type[P]>
  }




  export type game_typeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: game_typeWhereInput
    orderBy?: game_typeOrderByWithAggregationInput | game_typeOrderByWithAggregationInput[]
    by: Game_typeScalarFieldEnum[] | Game_typeScalarFieldEnum
    having?: game_typeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Game_typeCountAggregateInputType | true
    _avg?: Game_typeAvgAggregateInputType
    _sum?: Game_typeSumAggregateInputType
    _min?: Game_typeMinAggregateInputType
    _max?: Game_typeMaxAggregateInputType
  }

  export type Game_typeGroupByOutputType = {
    id: number
    code: $Enums.game_code_enum
    name: string
    _count: Game_typeCountAggregateOutputType | null
    _avg: Game_typeAvgAggregateOutputType | null
    _sum: Game_typeSumAggregateOutputType | null
    _min: Game_typeMinAggregateOutputType | null
    _max: Game_typeMaxAggregateOutputType | null
  }

  type GetGame_typeGroupByPayload<T extends game_typeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Game_typeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Game_typeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Game_typeGroupByOutputType[P]>
            : GetScalarType<T[P], Game_typeGroupByOutputType[P]>
        }
      >
    >


  export type game_typeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    puzzle_game?: boolean | game_type$puzzle_gameArgs<ExtArgs>
    quiz_game?: boolean | game_type$quiz_gameArgs<ExtArgs>
    treasure_game?: boolean | game_type$treasure_gameArgs<ExtArgs>
    _count?: boolean | Game_typeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["game_type"]>

  export type game_typeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["game_type"]>

  export type game_typeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
  }, ExtArgs["result"]["game_type"]>

  export type game_typeSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
  }

  export type game_typeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name", ExtArgs["result"]["game_type"]>
  export type game_typeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | game_type$puzzle_gameArgs<ExtArgs>
    quiz_game?: boolean | game_type$quiz_gameArgs<ExtArgs>
    treasure_game?: boolean | game_type$treasure_gameArgs<ExtArgs>
    _count?: boolean | Game_typeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type game_typeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type game_typeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $game_typePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "game_type"
    objects: {
      puzzle_game: Prisma.$puzzle_gamePayload<ExtArgs>[]
      quiz_game: Prisma.$quiz_gamePayload<ExtArgs>[]
      treasure_game: Prisma.$treasure_gamePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: $Enums.game_code_enum
      name: string
    }, ExtArgs["result"]["game_type"]>
    composites: {}
  }

  type game_typeGetPayload<S extends boolean | null | undefined | game_typeDefaultArgs> = $Result.GetResult<Prisma.$game_typePayload, S>

  type game_typeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<game_typeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Game_typeCountAggregateInputType | true
    }

  export interface game_typeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['game_type'], meta: { name: 'game_type' } }
    /**
     * Find zero or one Game_type that matches the filter.
     * @param {game_typeFindUniqueArgs} args - Arguments to find a Game_type
     * @example
     * // Get one Game_type
     * const game_type = await prisma.game_type.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends game_typeFindUniqueArgs>(args: SelectSubset<T, game_typeFindUniqueArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Game_type that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {game_typeFindUniqueOrThrowArgs} args - Arguments to find a Game_type
     * @example
     * // Get one Game_type
     * const game_type = await prisma.game_type.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends game_typeFindUniqueOrThrowArgs>(args: SelectSubset<T, game_typeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game_type that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_typeFindFirstArgs} args - Arguments to find a Game_type
     * @example
     * // Get one Game_type
     * const game_type = await prisma.game_type.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends game_typeFindFirstArgs>(args?: SelectSubset<T, game_typeFindFirstArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Game_type that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_typeFindFirstOrThrowArgs} args - Arguments to find a Game_type
     * @example
     * // Get one Game_type
     * const game_type = await prisma.game_type.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends game_typeFindFirstOrThrowArgs>(args?: SelectSubset<T, game_typeFindFirstOrThrowArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Game_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_typeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Game_types
     * const game_types = await prisma.game_type.findMany()
     * 
     * // Get first 10 Game_types
     * const game_types = await prisma.game_type.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const game_typeWithIdOnly = await prisma.game_type.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends game_typeFindManyArgs>(args?: SelectSubset<T, game_typeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Game_type.
     * @param {game_typeCreateArgs} args - Arguments to create a Game_type.
     * @example
     * // Create one Game_type
     * const Game_type = await prisma.game_type.create({
     *   data: {
     *     // ... data to create a Game_type
     *   }
     * })
     * 
     */
    create<T extends game_typeCreateArgs>(args: SelectSubset<T, game_typeCreateArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Game_types.
     * @param {game_typeCreateManyArgs} args - Arguments to create many Game_types.
     * @example
     * // Create many Game_types
     * const game_type = await prisma.game_type.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends game_typeCreateManyArgs>(args?: SelectSubset<T, game_typeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Game_types and returns the data saved in the database.
     * @param {game_typeCreateManyAndReturnArgs} args - Arguments to create many Game_types.
     * @example
     * // Create many Game_types
     * const game_type = await prisma.game_type.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Game_types and only return the `id`
     * const game_typeWithIdOnly = await prisma.game_type.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends game_typeCreateManyAndReturnArgs>(args?: SelectSubset<T, game_typeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Game_type.
     * @param {game_typeDeleteArgs} args - Arguments to delete one Game_type.
     * @example
     * // Delete one Game_type
     * const Game_type = await prisma.game_type.delete({
     *   where: {
     *     // ... filter to delete one Game_type
     *   }
     * })
     * 
     */
    delete<T extends game_typeDeleteArgs>(args: SelectSubset<T, game_typeDeleteArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Game_type.
     * @param {game_typeUpdateArgs} args - Arguments to update one Game_type.
     * @example
     * // Update one Game_type
     * const game_type = await prisma.game_type.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends game_typeUpdateArgs>(args: SelectSubset<T, game_typeUpdateArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Game_types.
     * @param {game_typeDeleteManyArgs} args - Arguments to filter Game_types to delete.
     * @example
     * // Delete a few Game_types
     * const { count } = await prisma.game_type.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends game_typeDeleteManyArgs>(args?: SelectSubset<T, game_typeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_typeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Game_types
     * const game_type = await prisma.game_type.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends game_typeUpdateManyArgs>(args: SelectSubset<T, game_typeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Game_types and returns the data updated in the database.
     * @param {game_typeUpdateManyAndReturnArgs} args - Arguments to update many Game_types.
     * @example
     * // Update many Game_types
     * const game_type = await prisma.game_type.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Game_types and only return the `id`
     * const game_typeWithIdOnly = await prisma.game_type.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends game_typeUpdateManyAndReturnArgs>(args: SelectSubset<T, game_typeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Game_type.
     * @param {game_typeUpsertArgs} args - Arguments to update or create a Game_type.
     * @example
     * // Update or create a Game_type
     * const game_type = await prisma.game_type.upsert({
     *   create: {
     *     // ... data to create a Game_type
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Game_type we want to update
     *   }
     * })
     */
    upsert<T extends game_typeUpsertArgs>(args: SelectSubset<T, game_typeUpsertArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Game_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_typeCountArgs} args - Arguments to filter Game_types to count.
     * @example
     * // Count the number of Game_types
     * const count = await prisma.game_type.count({
     *   where: {
     *     // ... the filter for the Game_types we want to count
     *   }
     * })
    **/
    count<T extends game_typeCountArgs>(
      args?: Subset<T, game_typeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Game_typeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Game_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Game_typeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Game_typeAggregateArgs>(args: Subset<T, Game_typeAggregateArgs>): Prisma.PrismaPromise<GetGame_typeAggregateType<T>>

    /**
     * Group by Game_type.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {game_typeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends game_typeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: game_typeGroupByArgs['orderBy'] }
        : { orderBy?: game_typeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, game_typeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGame_typeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the game_type model
   */
  readonly fields: game_typeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for game_type.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__game_typeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    puzzle_game<T extends game_type$puzzle_gameArgs<ExtArgs> = {}>(args?: Subset<T, game_type$puzzle_gameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quiz_game<T extends game_type$quiz_gameArgs<ExtArgs> = {}>(args?: Subset<T, game_type$quiz_gameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    treasure_game<T extends game_type$treasure_gameArgs<ExtArgs> = {}>(args?: Subset<T, game_type$treasure_gameArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the game_type model
   */
  interface game_typeFieldRefs {
    readonly id: FieldRef<"game_type", 'Int'>
    readonly code: FieldRef<"game_type", 'game_code_enum'>
    readonly name: FieldRef<"game_type", 'String'>
  }
    

  // Custom InputTypes
  /**
   * game_type findUnique
   */
  export type game_typeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    /**
     * Filter, which game_type to fetch.
     */
    where: game_typeWhereUniqueInput
  }

  /**
   * game_type findUniqueOrThrow
   */
  export type game_typeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    /**
     * Filter, which game_type to fetch.
     */
    where: game_typeWhereUniqueInput
  }

  /**
   * game_type findFirst
   */
  export type game_typeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    /**
     * Filter, which game_type to fetch.
     */
    where?: game_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_types to fetch.
     */
    orderBy?: game_typeOrderByWithRelationInput | game_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_types.
     */
    cursor?: game_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_types.
     */
    distinct?: Game_typeScalarFieldEnum | Game_typeScalarFieldEnum[]
  }

  /**
   * game_type findFirstOrThrow
   */
  export type game_typeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    /**
     * Filter, which game_type to fetch.
     */
    where?: game_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_types to fetch.
     */
    orderBy?: game_typeOrderByWithRelationInput | game_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for game_types.
     */
    cursor?: game_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of game_types.
     */
    distinct?: Game_typeScalarFieldEnum | Game_typeScalarFieldEnum[]
  }

  /**
   * game_type findMany
   */
  export type game_typeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    /**
     * Filter, which game_types to fetch.
     */
    where?: game_typeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of game_types to fetch.
     */
    orderBy?: game_typeOrderByWithRelationInput | game_typeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing game_types.
     */
    cursor?: game_typeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` game_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` game_types.
     */
    skip?: number
    distinct?: Game_typeScalarFieldEnum | Game_typeScalarFieldEnum[]
  }

  /**
   * game_type create
   */
  export type game_typeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    /**
     * The data needed to create a game_type.
     */
    data: XOR<game_typeCreateInput, game_typeUncheckedCreateInput>
  }

  /**
   * game_type createMany
   */
  export type game_typeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many game_types.
     */
    data: game_typeCreateManyInput | game_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game_type createManyAndReturn
   */
  export type game_typeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * The data used to create many game_types.
     */
    data: game_typeCreateManyInput | game_typeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * game_type update
   */
  export type game_typeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    /**
     * The data needed to update a game_type.
     */
    data: XOR<game_typeUpdateInput, game_typeUncheckedUpdateInput>
    /**
     * Choose, which game_type to update.
     */
    where: game_typeWhereUniqueInput
  }

  /**
   * game_type updateMany
   */
  export type game_typeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update game_types.
     */
    data: XOR<game_typeUpdateManyMutationInput, game_typeUncheckedUpdateManyInput>
    /**
     * Filter which game_types to update
     */
    where?: game_typeWhereInput
    /**
     * Limit how many game_types to update.
     */
    limit?: number
  }

  /**
   * game_type updateManyAndReturn
   */
  export type game_typeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * The data used to update game_types.
     */
    data: XOR<game_typeUpdateManyMutationInput, game_typeUncheckedUpdateManyInput>
    /**
     * Filter which game_types to update
     */
    where?: game_typeWhereInput
    /**
     * Limit how many game_types to update.
     */
    limit?: number
  }

  /**
   * game_type upsert
   */
  export type game_typeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    /**
     * The filter to search for the game_type to update in case it exists.
     */
    where: game_typeWhereUniqueInput
    /**
     * In case the game_type found by the `where` argument doesn't exist, create a new game_type with this data.
     */
    create: XOR<game_typeCreateInput, game_typeUncheckedCreateInput>
    /**
     * In case the game_type was found with the provided `where` argument, update it with this data.
     */
    update: XOR<game_typeUpdateInput, game_typeUncheckedUpdateInput>
  }

  /**
   * game_type delete
   */
  export type game_typeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    /**
     * Filter which game_type to delete.
     */
    where: game_typeWhereUniqueInput
  }

  /**
   * game_type deleteMany
   */
  export type game_typeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which game_types to delete
     */
    where?: game_typeWhereInput
    /**
     * Limit how many game_types to delete.
     */
    limit?: number
  }

  /**
   * game_type.puzzle_game
   */
  export type game_type$puzzle_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    where?: puzzle_gameWhereInput
    orderBy?: puzzle_gameOrderByWithRelationInput | puzzle_gameOrderByWithRelationInput[]
    cursor?: puzzle_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Puzzle_gameScalarFieldEnum | Puzzle_gameScalarFieldEnum[]
  }

  /**
   * game_type.quiz_game
   */
  export type game_type$quiz_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    where?: quiz_gameWhereInput
    orderBy?: quiz_gameOrderByWithRelationInput | quiz_gameOrderByWithRelationInput[]
    cursor?: quiz_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quiz_gameScalarFieldEnum | Quiz_gameScalarFieldEnum[]
  }

  /**
   * game_type.treasure_game
   */
  export type game_type$treasure_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    where?: treasure_gameWhereInput
    orderBy?: treasure_gameOrderByWithRelationInput | treasure_gameOrderByWithRelationInput[]
    cursor?: treasure_gameWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Treasure_gameScalarFieldEnum | Treasure_gameScalarFieldEnum[]
  }

  /**
   * game_type without action
   */
  export type game_typeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
  }


  /**
   * Model password_resets
   */

  export type AggregatePassword_resets = {
    _count: Password_resetsCountAggregateOutputType | null
    _avg: Password_resetsAvgAggregateOutputType | null
    _sum: Password_resetsSumAggregateOutputType | null
    _min: Password_resetsMinAggregateOutputType | null
    _max: Password_resetsMaxAggregateOutputType | null
  }

  export type Password_resetsAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Password_resetsSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type Password_resetsMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
  }

  export type Password_resetsMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    expiresAt: Date | null
  }

  export type Password_resetsCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    _all: number
  }


  export type Password_resetsAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Password_resetsSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type Password_resetsMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type Password_resetsMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
  }

  export type Password_resetsCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    _all?: true
  }

  export type Password_resetsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_resets to aggregate.
     */
    where?: password_resetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_resets to fetch.
     */
    orderBy?: password_resetsOrderByWithRelationInput | password_resetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: password_resetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_resets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_resets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned password_resets
    **/
    _count?: true | Password_resetsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Password_resetsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Password_resetsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_resetsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_resetsMaxAggregateInputType
  }

  export type GetPassword_resetsAggregateType<T extends Password_resetsAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_resets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_resets[P]>
      : GetScalarType<T[P], AggregatePassword_resets[P]>
  }




  export type password_resetsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_resetsWhereInput
    orderBy?: password_resetsOrderByWithAggregationInput | password_resetsOrderByWithAggregationInput[]
    by: Password_resetsScalarFieldEnum[] | Password_resetsScalarFieldEnum
    having?: password_resetsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_resetsCountAggregateInputType | true
    _avg?: Password_resetsAvgAggregateInputType
    _sum?: Password_resetsSumAggregateInputType
    _min?: Password_resetsMinAggregateInputType
    _max?: Password_resetsMaxAggregateInputType
  }

  export type Password_resetsGroupByOutputType = {
    id: number
    userId: number
    token: string
    expiresAt: Date
    _count: Password_resetsCountAggregateOutputType | null
    _avg: Password_resetsAvgAggregateOutputType | null
    _sum: Password_resetsSumAggregateOutputType | null
    _min: Password_resetsMinAggregateOutputType | null
    _max: Password_resetsMaxAggregateOutputType | null
  }

  type GetPassword_resetsGroupByPayload<T extends password_resetsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Password_resetsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Password_resetsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Password_resetsGroupByOutputType[P]>
            : GetScalarType<T[P], Password_resetsGroupByOutputType[P]>
        }
      >
    >


  export type password_resetsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_resets"]>

  export type password_resetsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_resets"]>

  export type password_resetsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["password_resets"]>

  export type password_resetsSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
  }

  export type password_resetsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expiresAt", ExtArgs["result"]["password_resets"]>
  export type password_resetsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type password_resetsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type password_resetsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $password_resetsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "password_resets"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      token: string
      expiresAt: Date
    }, ExtArgs["result"]["password_resets"]>
    composites: {}
  }

  type password_resetsGetPayload<S extends boolean | null | undefined | password_resetsDefaultArgs> = $Result.GetResult<Prisma.$password_resetsPayload, S>

  type password_resetsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<password_resetsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Password_resetsCountAggregateInputType | true
    }

  export interface password_resetsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['password_resets'], meta: { name: 'password_resets' } }
    /**
     * Find zero or one Password_resets that matches the filter.
     * @param {password_resetsFindUniqueArgs} args - Arguments to find a Password_resets
     * @example
     * // Get one Password_resets
     * const password_resets = await prisma.password_resets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends password_resetsFindUniqueArgs>(args: SelectSubset<T, password_resetsFindUniqueArgs<ExtArgs>>): Prisma__password_resetsClient<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password_resets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {password_resetsFindUniqueOrThrowArgs} args - Arguments to find a Password_resets
     * @example
     * // Get one Password_resets
     * const password_resets = await prisma.password_resets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends password_resetsFindUniqueOrThrowArgs>(args: SelectSubset<T, password_resetsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__password_resetsClient<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_resets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_resetsFindFirstArgs} args - Arguments to find a Password_resets
     * @example
     * // Get one Password_resets
     * const password_resets = await prisma.password_resets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends password_resetsFindFirstArgs>(args?: SelectSubset<T, password_resetsFindFirstArgs<ExtArgs>>): Prisma__password_resetsClient<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_resets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_resetsFindFirstOrThrowArgs} args - Arguments to find a Password_resets
     * @example
     * // Get one Password_resets
     * const password_resets = await prisma.password_resets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends password_resetsFindFirstOrThrowArgs>(args?: SelectSubset<T, password_resetsFindFirstOrThrowArgs<ExtArgs>>): Prisma__password_resetsClient<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Password_resets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_resetsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_resets
     * const password_resets = await prisma.password_resets.findMany()
     * 
     * // Get first 10 Password_resets
     * const password_resets = await prisma.password_resets.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const password_resetsWithIdOnly = await prisma.password_resets.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends password_resetsFindManyArgs>(args?: SelectSubset<T, password_resetsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password_resets.
     * @param {password_resetsCreateArgs} args - Arguments to create a Password_resets.
     * @example
     * // Create one Password_resets
     * const Password_resets = await prisma.password_resets.create({
     *   data: {
     *     // ... data to create a Password_resets
     *   }
     * })
     * 
     */
    create<T extends password_resetsCreateArgs>(args: SelectSubset<T, password_resetsCreateArgs<ExtArgs>>): Prisma__password_resetsClient<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Password_resets.
     * @param {password_resetsCreateManyArgs} args - Arguments to create many Password_resets.
     * @example
     * // Create many Password_resets
     * const password_resets = await prisma.password_resets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends password_resetsCreateManyArgs>(args?: SelectSubset<T, password_resetsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Password_resets and returns the data saved in the database.
     * @param {password_resetsCreateManyAndReturnArgs} args - Arguments to create many Password_resets.
     * @example
     * // Create many Password_resets
     * const password_resets = await prisma.password_resets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Password_resets and only return the `id`
     * const password_resetsWithIdOnly = await prisma.password_resets.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends password_resetsCreateManyAndReturnArgs>(args?: SelectSubset<T, password_resetsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Password_resets.
     * @param {password_resetsDeleteArgs} args - Arguments to delete one Password_resets.
     * @example
     * // Delete one Password_resets
     * const Password_resets = await prisma.password_resets.delete({
     *   where: {
     *     // ... filter to delete one Password_resets
     *   }
     * })
     * 
     */
    delete<T extends password_resetsDeleteArgs>(args: SelectSubset<T, password_resetsDeleteArgs<ExtArgs>>): Prisma__password_resetsClient<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password_resets.
     * @param {password_resetsUpdateArgs} args - Arguments to update one Password_resets.
     * @example
     * // Update one Password_resets
     * const password_resets = await prisma.password_resets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends password_resetsUpdateArgs>(args: SelectSubset<T, password_resetsUpdateArgs<ExtArgs>>): Prisma__password_resetsClient<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Password_resets.
     * @param {password_resetsDeleteManyArgs} args - Arguments to filter Password_resets to delete.
     * @example
     * // Delete a few Password_resets
     * const { count } = await prisma.password_resets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends password_resetsDeleteManyArgs>(args?: SelectSubset<T, password_resetsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_resets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_resetsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_resets
     * const password_resets = await prisma.password_resets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends password_resetsUpdateManyArgs>(args: SelectSubset<T, password_resetsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_resets and returns the data updated in the database.
     * @param {password_resetsUpdateManyAndReturnArgs} args - Arguments to update many Password_resets.
     * @example
     * // Update many Password_resets
     * const password_resets = await prisma.password_resets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Password_resets and only return the `id`
     * const password_resetsWithIdOnly = await prisma.password_resets.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends password_resetsUpdateManyAndReturnArgs>(args: SelectSubset<T, password_resetsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Password_resets.
     * @param {password_resetsUpsertArgs} args - Arguments to update or create a Password_resets.
     * @example
     * // Update or create a Password_resets
     * const password_resets = await prisma.password_resets.upsert({
     *   create: {
     *     // ... data to create a Password_resets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_resets we want to update
     *   }
     * })
     */
    upsert<T extends password_resetsUpsertArgs>(args: SelectSubset<T, password_resetsUpsertArgs<ExtArgs>>): Prisma__password_resetsClient<$Result.GetResult<Prisma.$password_resetsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Password_resets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_resetsCountArgs} args - Arguments to filter Password_resets to count.
     * @example
     * // Count the number of Password_resets
     * const count = await prisma.password_resets.count({
     *   where: {
     *     // ... the filter for the Password_resets we want to count
     *   }
     * })
    **/
    count<T extends password_resetsCountArgs>(
      args?: Subset<T, password_resetsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_resetsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_resets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_resetsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_resetsAggregateArgs>(args: Subset<T, Password_resetsAggregateArgs>): Prisma.PrismaPromise<GetPassword_resetsAggregateType<T>>

    /**
     * Group by Password_resets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_resetsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends password_resetsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: password_resetsGroupByArgs['orderBy'] }
        : { orderBy?: password_resetsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, password_resetsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_resetsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the password_resets model
   */
  readonly fields: password_resetsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for password_resets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__password_resetsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the password_resets model
   */
  interface password_resetsFieldRefs {
    readonly id: FieldRef<"password_resets", 'Int'>
    readonly userId: FieldRef<"password_resets", 'Int'>
    readonly token: FieldRef<"password_resets", 'String'>
    readonly expiresAt: FieldRef<"password_resets", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * password_resets findUnique
   */
  export type password_resetsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    /**
     * Filter, which password_resets to fetch.
     */
    where: password_resetsWhereUniqueInput
  }

  /**
   * password_resets findUniqueOrThrow
   */
  export type password_resetsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    /**
     * Filter, which password_resets to fetch.
     */
    where: password_resetsWhereUniqueInput
  }

  /**
   * password_resets findFirst
   */
  export type password_resetsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    /**
     * Filter, which password_resets to fetch.
     */
    where?: password_resetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_resets to fetch.
     */
    orderBy?: password_resetsOrderByWithRelationInput | password_resetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_resets.
     */
    cursor?: password_resetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_resets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_resets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_resets.
     */
    distinct?: Password_resetsScalarFieldEnum | Password_resetsScalarFieldEnum[]
  }

  /**
   * password_resets findFirstOrThrow
   */
  export type password_resetsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    /**
     * Filter, which password_resets to fetch.
     */
    where?: password_resetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_resets to fetch.
     */
    orderBy?: password_resetsOrderByWithRelationInput | password_resetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_resets.
     */
    cursor?: password_resetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_resets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_resets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_resets.
     */
    distinct?: Password_resetsScalarFieldEnum | Password_resetsScalarFieldEnum[]
  }

  /**
   * password_resets findMany
   */
  export type password_resetsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    /**
     * Filter, which password_resets to fetch.
     */
    where?: password_resetsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_resets to fetch.
     */
    orderBy?: password_resetsOrderByWithRelationInput | password_resetsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing password_resets.
     */
    cursor?: password_resetsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_resets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_resets.
     */
    skip?: number
    distinct?: Password_resetsScalarFieldEnum | Password_resetsScalarFieldEnum[]
  }

  /**
   * password_resets create
   */
  export type password_resetsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    /**
     * The data needed to create a password_resets.
     */
    data: XOR<password_resetsCreateInput, password_resetsUncheckedCreateInput>
  }

  /**
   * password_resets createMany
   */
  export type password_resetsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many password_resets.
     */
    data: password_resetsCreateManyInput | password_resetsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * password_resets createManyAndReturn
   */
  export type password_resetsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * The data used to create many password_resets.
     */
    data: password_resetsCreateManyInput | password_resetsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * password_resets update
   */
  export type password_resetsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    /**
     * The data needed to update a password_resets.
     */
    data: XOR<password_resetsUpdateInput, password_resetsUncheckedUpdateInput>
    /**
     * Choose, which password_resets to update.
     */
    where: password_resetsWhereUniqueInput
  }

  /**
   * password_resets updateMany
   */
  export type password_resetsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update password_resets.
     */
    data: XOR<password_resetsUpdateManyMutationInput, password_resetsUncheckedUpdateManyInput>
    /**
     * Filter which password_resets to update
     */
    where?: password_resetsWhereInput
    /**
     * Limit how many password_resets to update.
     */
    limit?: number
  }

  /**
   * password_resets updateManyAndReturn
   */
  export type password_resetsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * The data used to update password_resets.
     */
    data: XOR<password_resetsUpdateManyMutationInput, password_resetsUncheckedUpdateManyInput>
    /**
     * Filter which password_resets to update
     */
    where?: password_resetsWhereInput
    /**
     * Limit how many password_resets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * password_resets upsert
   */
  export type password_resetsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    /**
     * The filter to search for the password_resets to update in case it exists.
     */
    where: password_resetsWhereUniqueInput
    /**
     * In case the password_resets found by the `where` argument doesn't exist, create a new password_resets with this data.
     */
    create: XOR<password_resetsCreateInput, password_resetsUncheckedCreateInput>
    /**
     * In case the password_resets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<password_resetsUpdateInput, password_resetsUncheckedUpdateInput>
  }

  /**
   * password_resets delete
   */
  export type password_resetsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
    /**
     * Filter which password_resets to delete.
     */
    where: password_resetsWhereUniqueInput
  }

  /**
   * password_resets deleteMany
   */
  export type password_resetsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_resets to delete
     */
    where?: password_resetsWhereInput
    /**
     * Limit how many password_resets to delete.
     */
    limit?: number
  }

  /**
   * password_resets without action
   */
  export type password_resetsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_resets
     */
    select?: password_resetsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_resets
     */
    omit?: password_resetsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: password_resetsInclude<ExtArgs> | null
  }


  /**
   * Model puzzle_game
   */

  export type AggregatePuzzle_game = {
    _count: Puzzle_gameCountAggregateOutputType | null
    _avg: Puzzle_gameAvgAggregateOutputType | null
    _sum: Puzzle_gameSumAggregateOutputType | null
    _min: Puzzle_gameMinAggregateOutputType | null
    _max: Puzzle_gameMaxAggregateOutputType | null
  }

  export type Puzzle_gameAvgAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
  }

  export type Puzzle_gameSumAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
  }

  export type Puzzle_gameMinAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
    imageurl: string | null
  }

  export type Puzzle_gameMaxAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
    imageurl: string | null
  }

  export type Puzzle_gameCountAggregateOutputType = {
    id: number
    regionid: number
    gametype: number
    imageurl: number
    _all: number
  }


  export type Puzzle_gameAvgAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
  }

  export type Puzzle_gameSumAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
  }

  export type Puzzle_gameMinAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
    imageurl?: true
  }

  export type Puzzle_gameMaxAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
    imageurl?: true
  }

  export type Puzzle_gameCountAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
    imageurl?: true
    _all?: true
  }

  export type Puzzle_gameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which puzzle_game to aggregate.
     */
    where?: puzzle_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of puzzle_games to fetch.
     */
    orderBy?: puzzle_gameOrderByWithRelationInput | puzzle_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: puzzle_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` puzzle_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` puzzle_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned puzzle_games
    **/
    _count?: true | Puzzle_gameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Puzzle_gameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Puzzle_gameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Puzzle_gameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Puzzle_gameMaxAggregateInputType
  }

  export type GetPuzzle_gameAggregateType<T extends Puzzle_gameAggregateArgs> = {
        [P in keyof T & keyof AggregatePuzzle_game]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePuzzle_game[P]>
      : GetScalarType<T[P], AggregatePuzzle_game[P]>
  }




  export type puzzle_gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: puzzle_gameWhereInput
    orderBy?: puzzle_gameOrderByWithAggregationInput | puzzle_gameOrderByWithAggregationInput[]
    by: Puzzle_gameScalarFieldEnum[] | Puzzle_gameScalarFieldEnum
    having?: puzzle_gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Puzzle_gameCountAggregateInputType | true
    _avg?: Puzzle_gameAvgAggregateInputType
    _sum?: Puzzle_gameSumAggregateInputType
    _min?: Puzzle_gameMinAggregateInputType
    _max?: Puzzle_gameMaxAggregateInputType
  }

  export type Puzzle_gameGroupByOutputType = {
    id: number
    regionid: number | null
    gametype: number | null
    imageurl: string | null
    _count: Puzzle_gameCountAggregateOutputType | null
    _avg: Puzzle_gameAvgAggregateOutputType | null
    _sum: Puzzle_gameSumAggregateOutputType | null
    _min: Puzzle_gameMinAggregateOutputType | null
    _max: Puzzle_gameMaxAggregateOutputType | null
  }

  type GetPuzzle_gameGroupByPayload<T extends puzzle_gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Puzzle_gameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Puzzle_gameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Puzzle_gameGroupByOutputType[P]>
            : GetScalarType<T[P], Puzzle_gameGroupByOutputType[P]>
        }
      >
    >


  export type puzzle_gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    imageurl?: boolean
    AfterQuestionInformation?: boolean | puzzle_game$AfterQuestionInformationArgs<ExtArgs>
    Region?: boolean | puzzle_game$RegionArgs<ExtArgs>
    game_type?: boolean | puzzle_game$game_typeArgs<ExtArgs>
    puzzle_pieces?: boolean | puzzle_game$puzzle_piecesArgs<ExtArgs>
    _count?: boolean | Puzzle_gameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["puzzle_game"]>

  export type puzzle_gameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    imageurl?: boolean
    Region?: boolean | puzzle_game$RegionArgs<ExtArgs>
    game_type?: boolean | puzzle_game$game_typeArgs<ExtArgs>
  }, ExtArgs["result"]["puzzle_game"]>

  export type puzzle_gameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    imageurl?: boolean
    Region?: boolean | puzzle_game$RegionArgs<ExtArgs>
    game_type?: boolean | puzzle_game$game_typeArgs<ExtArgs>
  }, ExtArgs["result"]["puzzle_game"]>

  export type puzzle_gameSelectScalar = {
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    imageurl?: boolean
  }

  export type puzzle_gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionid" | "gametype" | "imageurl", ExtArgs["result"]["puzzle_game"]>
  export type puzzle_gameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AfterQuestionInformation?: boolean | puzzle_game$AfterQuestionInformationArgs<ExtArgs>
    Region?: boolean | puzzle_game$RegionArgs<ExtArgs>
    game_type?: boolean | puzzle_game$game_typeArgs<ExtArgs>
    puzzle_pieces?: boolean | puzzle_game$puzzle_piecesArgs<ExtArgs>
    _count?: boolean | Puzzle_gameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type puzzle_gameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Region?: boolean | puzzle_game$RegionArgs<ExtArgs>
    game_type?: boolean | puzzle_game$game_typeArgs<ExtArgs>
  }
  export type puzzle_gameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Region?: boolean | puzzle_game$RegionArgs<ExtArgs>
    game_type?: boolean | puzzle_game$game_typeArgs<ExtArgs>
  }

  export type $puzzle_gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "puzzle_game"
    objects: {
      AfterQuestionInformation: Prisma.$AfterQuestionInformationPayload<ExtArgs>[]
      Region: Prisma.$RegionPayload<ExtArgs> | null
      game_type: Prisma.$game_typePayload<ExtArgs> | null
      puzzle_pieces: Prisma.$puzzle_piecesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionid: number | null
      gametype: number | null
      imageurl: string | null
    }, ExtArgs["result"]["puzzle_game"]>
    composites: {}
  }

  type puzzle_gameGetPayload<S extends boolean | null | undefined | puzzle_gameDefaultArgs> = $Result.GetResult<Prisma.$puzzle_gamePayload, S>

  type puzzle_gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<puzzle_gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Puzzle_gameCountAggregateInputType | true
    }

  export interface puzzle_gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['puzzle_game'], meta: { name: 'puzzle_game' } }
    /**
     * Find zero or one Puzzle_game that matches the filter.
     * @param {puzzle_gameFindUniqueArgs} args - Arguments to find a Puzzle_game
     * @example
     * // Get one Puzzle_game
     * const puzzle_game = await prisma.puzzle_game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends puzzle_gameFindUniqueArgs>(args: SelectSubset<T, puzzle_gameFindUniqueArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Puzzle_game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {puzzle_gameFindUniqueOrThrowArgs} args - Arguments to find a Puzzle_game
     * @example
     * // Get one Puzzle_game
     * const puzzle_game = await prisma.puzzle_game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends puzzle_gameFindUniqueOrThrowArgs>(args: SelectSubset<T, puzzle_gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Puzzle_game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_gameFindFirstArgs} args - Arguments to find a Puzzle_game
     * @example
     * // Get one Puzzle_game
     * const puzzle_game = await prisma.puzzle_game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends puzzle_gameFindFirstArgs>(args?: SelectSubset<T, puzzle_gameFindFirstArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Puzzle_game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_gameFindFirstOrThrowArgs} args - Arguments to find a Puzzle_game
     * @example
     * // Get one Puzzle_game
     * const puzzle_game = await prisma.puzzle_game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends puzzle_gameFindFirstOrThrowArgs>(args?: SelectSubset<T, puzzle_gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Puzzle_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Puzzle_games
     * const puzzle_games = await prisma.puzzle_game.findMany()
     * 
     * // Get first 10 Puzzle_games
     * const puzzle_games = await prisma.puzzle_game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const puzzle_gameWithIdOnly = await prisma.puzzle_game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends puzzle_gameFindManyArgs>(args?: SelectSubset<T, puzzle_gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Puzzle_game.
     * @param {puzzle_gameCreateArgs} args - Arguments to create a Puzzle_game.
     * @example
     * // Create one Puzzle_game
     * const Puzzle_game = await prisma.puzzle_game.create({
     *   data: {
     *     // ... data to create a Puzzle_game
     *   }
     * })
     * 
     */
    create<T extends puzzle_gameCreateArgs>(args: SelectSubset<T, puzzle_gameCreateArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Puzzle_games.
     * @param {puzzle_gameCreateManyArgs} args - Arguments to create many Puzzle_games.
     * @example
     * // Create many Puzzle_games
     * const puzzle_game = await prisma.puzzle_game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends puzzle_gameCreateManyArgs>(args?: SelectSubset<T, puzzle_gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Puzzle_games and returns the data saved in the database.
     * @param {puzzle_gameCreateManyAndReturnArgs} args - Arguments to create many Puzzle_games.
     * @example
     * // Create many Puzzle_games
     * const puzzle_game = await prisma.puzzle_game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Puzzle_games and only return the `id`
     * const puzzle_gameWithIdOnly = await prisma.puzzle_game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends puzzle_gameCreateManyAndReturnArgs>(args?: SelectSubset<T, puzzle_gameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Puzzle_game.
     * @param {puzzle_gameDeleteArgs} args - Arguments to delete one Puzzle_game.
     * @example
     * // Delete one Puzzle_game
     * const Puzzle_game = await prisma.puzzle_game.delete({
     *   where: {
     *     // ... filter to delete one Puzzle_game
     *   }
     * })
     * 
     */
    delete<T extends puzzle_gameDeleteArgs>(args: SelectSubset<T, puzzle_gameDeleteArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Puzzle_game.
     * @param {puzzle_gameUpdateArgs} args - Arguments to update one Puzzle_game.
     * @example
     * // Update one Puzzle_game
     * const puzzle_game = await prisma.puzzle_game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends puzzle_gameUpdateArgs>(args: SelectSubset<T, puzzle_gameUpdateArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Puzzle_games.
     * @param {puzzle_gameDeleteManyArgs} args - Arguments to filter Puzzle_games to delete.
     * @example
     * // Delete a few Puzzle_games
     * const { count } = await prisma.puzzle_game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends puzzle_gameDeleteManyArgs>(args?: SelectSubset<T, puzzle_gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Puzzle_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Puzzle_games
     * const puzzle_game = await prisma.puzzle_game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends puzzle_gameUpdateManyArgs>(args: SelectSubset<T, puzzle_gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Puzzle_games and returns the data updated in the database.
     * @param {puzzle_gameUpdateManyAndReturnArgs} args - Arguments to update many Puzzle_games.
     * @example
     * // Update many Puzzle_games
     * const puzzle_game = await prisma.puzzle_game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Puzzle_games and only return the `id`
     * const puzzle_gameWithIdOnly = await prisma.puzzle_game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends puzzle_gameUpdateManyAndReturnArgs>(args: SelectSubset<T, puzzle_gameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Puzzle_game.
     * @param {puzzle_gameUpsertArgs} args - Arguments to update or create a Puzzle_game.
     * @example
     * // Update or create a Puzzle_game
     * const puzzle_game = await prisma.puzzle_game.upsert({
     *   create: {
     *     // ... data to create a Puzzle_game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Puzzle_game we want to update
     *   }
     * })
     */
    upsert<T extends puzzle_gameUpsertArgs>(args: SelectSubset<T, puzzle_gameUpsertArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Puzzle_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_gameCountArgs} args - Arguments to filter Puzzle_games to count.
     * @example
     * // Count the number of Puzzle_games
     * const count = await prisma.puzzle_game.count({
     *   where: {
     *     // ... the filter for the Puzzle_games we want to count
     *   }
     * })
    **/
    count<T extends puzzle_gameCountArgs>(
      args?: Subset<T, puzzle_gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Puzzle_gameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Puzzle_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Puzzle_gameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Puzzle_gameAggregateArgs>(args: Subset<T, Puzzle_gameAggregateArgs>): Prisma.PrismaPromise<GetPuzzle_gameAggregateType<T>>

    /**
     * Group by Puzzle_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends puzzle_gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: puzzle_gameGroupByArgs['orderBy'] }
        : { orderBy?: puzzle_gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, puzzle_gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPuzzle_gameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the puzzle_game model
   */
  readonly fields: puzzle_gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for puzzle_game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__puzzle_gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AfterQuestionInformation<T extends puzzle_game$AfterQuestionInformationArgs<ExtArgs> = {}>(args?: Subset<T, puzzle_game$AfterQuestionInformationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Region<T extends puzzle_game$RegionArgs<ExtArgs> = {}>(args?: Subset<T, puzzle_game$RegionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    game_type<T extends puzzle_game$game_typeArgs<ExtArgs> = {}>(args?: Subset<T, puzzle_game$game_typeArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    puzzle_pieces<T extends puzzle_game$puzzle_piecesArgs<ExtArgs> = {}>(args?: Subset<T, puzzle_game$puzzle_piecesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the puzzle_game model
   */
  interface puzzle_gameFieldRefs {
    readonly id: FieldRef<"puzzle_game", 'Int'>
    readonly regionid: FieldRef<"puzzle_game", 'Int'>
    readonly gametype: FieldRef<"puzzle_game", 'Int'>
    readonly imageurl: FieldRef<"puzzle_game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * puzzle_game findUnique
   */
  export type puzzle_gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_game to fetch.
     */
    where: puzzle_gameWhereUniqueInput
  }

  /**
   * puzzle_game findUniqueOrThrow
   */
  export type puzzle_gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_game to fetch.
     */
    where: puzzle_gameWhereUniqueInput
  }

  /**
   * puzzle_game findFirst
   */
  export type puzzle_gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_game to fetch.
     */
    where?: puzzle_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of puzzle_games to fetch.
     */
    orderBy?: puzzle_gameOrderByWithRelationInput | puzzle_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for puzzle_games.
     */
    cursor?: puzzle_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` puzzle_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` puzzle_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of puzzle_games.
     */
    distinct?: Puzzle_gameScalarFieldEnum | Puzzle_gameScalarFieldEnum[]
  }

  /**
   * puzzle_game findFirstOrThrow
   */
  export type puzzle_gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_game to fetch.
     */
    where?: puzzle_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of puzzle_games to fetch.
     */
    orderBy?: puzzle_gameOrderByWithRelationInput | puzzle_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for puzzle_games.
     */
    cursor?: puzzle_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` puzzle_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` puzzle_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of puzzle_games.
     */
    distinct?: Puzzle_gameScalarFieldEnum | Puzzle_gameScalarFieldEnum[]
  }

  /**
   * puzzle_game findMany
   */
  export type puzzle_gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_games to fetch.
     */
    where?: puzzle_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of puzzle_games to fetch.
     */
    orderBy?: puzzle_gameOrderByWithRelationInput | puzzle_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing puzzle_games.
     */
    cursor?: puzzle_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` puzzle_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` puzzle_games.
     */
    skip?: number
    distinct?: Puzzle_gameScalarFieldEnum | Puzzle_gameScalarFieldEnum[]
  }

  /**
   * puzzle_game create
   */
  export type puzzle_gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    /**
     * The data needed to create a puzzle_game.
     */
    data?: XOR<puzzle_gameCreateInput, puzzle_gameUncheckedCreateInput>
  }

  /**
   * puzzle_game createMany
   */
  export type puzzle_gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many puzzle_games.
     */
    data: puzzle_gameCreateManyInput | puzzle_gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * puzzle_game createManyAndReturn
   */
  export type puzzle_gameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * The data used to create many puzzle_games.
     */
    data: puzzle_gameCreateManyInput | puzzle_gameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * puzzle_game update
   */
  export type puzzle_gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    /**
     * The data needed to update a puzzle_game.
     */
    data: XOR<puzzle_gameUpdateInput, puzzle_gameUncheckedUpdateInput>
    /**
     * Choose, which puzzle_game to update.
     */
    where: puzzle_gameWhereUniqueInput
  }

  /**
   * puzzle_game updateMany
   */
  export type puzzle_gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update puzzle_games.
     */
    data: XOR<puzzle_gameUpdateManyMutationInput, puzzle_gameUncheckedUpdateManyInput>
    /**
     * Filter which puzzle_games to update
     */
    where?: puzzle_gameWhereInput
    /**
     * Limit how many puzzle_games to update.
     */
    limit?: number
  }

  /**
   * puzzle_game updateManyAndReturn
   */
  export type puzzle_gameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * The data used to update puzzle_games.
     */
    data: XOR<puzzle_gameUpdateManyMutationInput, puzzle_gameUncheckedUpdateManyInput>
    /**
     * Filter which puzzle_games to update
     */
    where?: puzzle_gameWhereInput
    /**
     * Limit how many puzzle_games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * puzzle_game upsert
   */
  export type puzzle_gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    /**
     * The filter to search for the puzzle_game to update in case it exists.
     */
    where: puzzle_gameWhereUniqueInput
    /**
     * In case the puzzle_game found by the `where` argument doesn't exist, create a new puzzle_game with this data.
     */
    create: XOR<puzzle_gameCreateInput, puzzle_gameUncheckedCreateInput>
    /**
     * In case the puzzle_game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<puzzle_gameUpdateInput, puzzle_gameUncheckedUpdateInput>
  }

  /**
   * puzzle_game delete
   */
  export type puzzle_gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    /**
     * Filter which puzzle_game to delete.
     */
    where: puzzle_gameWhereUniqueInput
  }

  /**
   * puzzle_game deleteMany
   */
  export type puzzle_gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which puzzle_games to delete
     */
    where?: puzzle_gameWhereInput
    /**
     * Limit how many puzzle_games to delete.
     */
    limit?: number
  }

  /**
   * puzzle_game.AfterQuestionInformation
   */
  export type puzzle_game$AfterQuestionInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    where?: AfterQuestionInformationWhereInput
    orderBy?: AfterQuestionInformationOrderByWithRelationInput | AfterQuestionInformationOrderByWithRelationInput[]
    cursor?: AfterQuestionInformationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AfterQuestionInformationScalarFieldEnum | AfterQuestionInformationScalarFieldEnum[]
  }

  /**
   * puzzle_game.Region
   */
  export type puzzle_game$RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * puzzle_game.game_type
   */
  export type puzzle_game$game_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    where?: game_typeWhereInput
  }

  /**
   * puzzle_game.puzzle_pieces
   */
  export type puzzle_game$puzzle_piecesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    where?: puzzle_piecesWhereInput
    orderBy?: puzzle_piecesOrderByWithRelationInput | puzzle_piecesOrderByWithRelationInput[]
    cursor?: puzzle_piecesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Puzzle_piecesScalarFieldEnum | Puzzle_piecesScalarFieldEnum[]
  }

  /**
   * puzzle_game without action
   */
  export type puzzle_gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
  }


  /**
   * Model puzzle_pieces
   */

  export type AggregatePuzzle_pieces = {
    _count: Puzzle_piecesCountAggregateOutputType | null
    _avg: Puzzle_piecesAvgAggregateOutputType | null
    _sum: Puzzle_piecesSumAggregateOutputType | null
    _min: Puzzle_piecesMinAggregateOutputType | null
    _max: Puzzle_piecesMaxAggregateOutputType | null
  }

  export type Puzzle_piecesAvgAggregateOutputType = {
    id: number | null
    puzzleid: number | null
    piece_index: number | null
    x_position: number | null
    y_position: number | null
    correct_x: number | null
    correct_y: number | null
  }

  export type Puzzle_piecesSumAggregateOutputType = {
    id: number | null
    puzzleid: number | null
    piece_index: number | null
    x_position: number | null
    y_position: number | null
    correct_x: number | null
    correct_y: number | null
  }

  export type Puzzle_piecesMinAggregateOutputType = {
    id: number | null
    puzzleid: number | null
    piece_index: number | null
    x_position: number | null
    y_position: number | null
    correct_x: number | null
    correct_y: number | null
    image_piece_url: string | null
  }

  export type Puzzle_piecesMaxAggregateOutputType = {
    id: number | null
    puzzleid: number | null
    piece_index: number | null
    x_position: number | null
    y_position: number | null
    correct_x: number | null
    correct_y: number | null
    image_piece_url: string | null
  }

  export type Puzzle_piecesCountAggregateOutputType = {
    id: number
    puzzleid: number
    piece_index: number
    x_position: number
    y_position: number
    correct_x: number
    correct_y: number
    image_piece_url: number
    _all: number
  }


  export type Puzzle_piecesAvgAggregateInputType = {
    id?: true
    puzzleid?: true
    piece_index?: true
    x_position?: true
    y_position?: true
    correct_x?: true
    correct_y?: true
  }

  export type Puzzle_piecesSumAggregateInputType = {
    id?: true
    puzzleid?: true
    piece_index?: true
    x_position?: true
    y_position?: true
    correct_x?: true
    correct_y?: true
  }

  export type Puzzle_piecesMinAggregateInputType = {
    id?: true
    puzzleid?: true
    piece_index?: true
    x_position?: true
    y_position?: true
    correct_x?: true
    correct_y?: true
    image_piece_url?: true
  }

  export type Puzzle_piecesMaxAggregateInputType = {
    id?: true
    puzzleid?: true
    piece_index?: true
    x_position?: true
    y_position?: true
    correct_x?: true
    correct_y?: true
    image_piece_url?: true
  }

  export type Puzzle_piecesCountAggregateInputType = {
    id?: true
    puzzleid?: true
    piece_index?: true
    x_position?: true
    y_position?: true
    correct_x?: true
    correct_y?: true
    image_piece_url?: true
    _all?: true
  }

  export type Puzzle_piecesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which puzzle_pieces to aggregate.
     */
    where?: puzzle_piecesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of puzzle_pieces to fetch.
     */
    orderBy?: puzzle_piecesOrderByWithRelationInput | puzzle_piecesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: puzzle_piecesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` puzzle_pieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` puzzle_pieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned puzzle_pieces
    **/
    _count?: true | Puzzle_piecesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Puzzle_piecesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Puzzle_piecesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Puzzle_piecesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Puzzle_piecesMaxAggregateInputType
  }

  export type GetPuzzle_piecesAggregateType<T extends Puzzle_piecesAggregateArgs> = {
        [P in keyof T & keyof AggregatePuzzle_pieces]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePuzzle_pieces[P]>
      : GetScalarType<T[P], AggregatePuzzle_pieces[P]>
  }




  export type puzzle_piecesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: puzzle_piecesWhereInput
    orderBy?: puzzle_piecesOrderByWithAggregationInput | puzzle_piecesOrderByWithAggregationInput[]
    by: Puzzle_piecesScalarFieldEnum[] | Puzzle_piecesScalarFieldEnum
    having?: puzzle_piecesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Puzzle_piecesCountAggregateInputType | true
    _avg?: Puzzle_piecesAvgAggregateInputType
    _sum?: Puzzle_piecesSumAggregateInputType
    _min?: Puzzle_piecesMinAggregateInputType
    _max?: Puzzle_piecesMaxAggregateInputType
  }

  export type Puzzle_piecesGroupByOutputType = {
    id: number
    puzzleid: number | null
    piece_index: number
    x_position: number | null
    y_position: number | null
    correct_x: number
    correct_y: number
    image_piece_url: string | null
    _count: Puzzle_piecesCountAggregateOutputType | null
    _avg: Puzzle_piecesAvgAggregateOutputType | null
    _sum: Puzzle_piecesSumAggregateOutputType | null
    _min: Puzzle_piecesMinAggregateOutputType | null
    _max: Puzzle_piecesMaxAggregateOutputType | null
  }

  type GetPuzzle_piecesGroupByPayload<T extends puzzle_piecesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Puzzle_piecesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Puzzle_piecesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Puzzle_piecesGroupByOutputType[P]>
            : GetScalarType<T[P], Puzzle_piecesGroupByOutputType[P]>
        }
      >
    >


  export type puzzle_piecesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    puzzleid?: boolean
    piece_index?: boolean
    x_position?: boolean
    y_position?: boolean
    correct_x?: boolean
    correct_y?: boolean
    image_piece_url?: boolean
    puzzle_game?: boolean | puzzle_pieces$puzzle_gameArgs<ExtArgs>
  }, ExtArgs["result"]["puzzle_pieces"]>

  export type puzzle_piecesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    puzzleid?: boolean
    piece_index?: boolean
    x_position?: boolean
    y_position?: boolean
    correct_x?: boolean
    correct_y?: boolean
    image_piece_url?: boolean
    puzzle_game?: boolean | puzzle_pieces$puzzle_gameArgs<ExtArgs>
  }, ExtArgs["result"]["puzzle_pieces"]>

  export type puzzle_piecesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    puzzleid?: boolean
    piece_index?: boolean
    x_position?: boolean
    y_position?: boolean
    correct_x?: boolean
    correct_y?: boolean
    image_piece_url?: boolean
    puzzle_game?: boolean | puzzle_pieces$puzzle_gameArgs<ExtArgs>
  }, ExtArgs["result"]["puzzle_pieces"]>

  export type puzzle_piecesSelectScalar = {
    id?: boolean
    puzzleid?: boolean
    piece_index?: boolean
    x_position?: boolean
    y_position?: boolean
    correct_x?: boolean
    correct_y?: boolean
    image_piece_url?: boolean
  }

  export type puzzle_piecesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "puzzleid" | "piece_index" | "x_position" | "y_position" | "correct_x" | "correct_y" | "image_piece_url", ExtArgs["result"]["puzzle_pieces"]>
  export type puzzle_piecesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | puzzle_pieces$puzzle_gameArgs<ExtArgs>
  }
  export type puzzle_piecesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | puzzle_pieces$puzzle_gameArgs<ExtArgs>
  }
  export type puzzle_piecesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    puzzle_game?: boolean | puzzle_pieces$puzzle_gameArgs<ExtArgs>
  }

  export type $puzzle_piecesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "puzzle_pieces"
    objects: {
      puzzle_game: Prisma.$puzzle_gamePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      puzzleid: number | null
      piece_index: number
      x_position: number | null
      y_position: number | null
      correct_x: number
      correct_y: number
      image_piece_url: string | null
    }, ExtArgs["result"]["puzzle_pieces"]>
    composites: {}
  }

  type puzzle_piecesGetPayload<S extends boolean | null | undefined | puzzle_piecesDefaultArgs> = $Result.GetResult<Prisma.$puzzle_piecesPayload, S>

  type puzzle_piecesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<puzzle_piecesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Puzzle_piecesCountAggregateInputType | true
    }

  export interface puzzle_piecesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['puzzle_pieces'], meta: { name: 'puzzle_pieces' } }
    /**
     * Find zero or one Puzzle_pieces that matches the filter.
     * @param {puzzle_piecesFindUniqueArgs} args - Arguments to find a Puzzle_pieces
     * @example
     * // Get one Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends puzzle_piecesFindUniqueArgs>(args: SelectSubset<T, puzzle_piecesFindUniqueArgs<ExtArgs>>): Prisma__puzzle_piecesClient<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Puzzle_pieces that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {puzzle_piecesFindUniqueOrThrowArgs} args - Arguments to find a Puzzle_pieces
     * @example
     * // Get one Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends puzzle_piecesFindUniqueOrThrowArgs>(args: SelectSubset<T, puzzle_piecesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__puzzle_piecesClient<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Puzzle_pieces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_piecesFindFirstArgs} args - Arguments to find a Puzzle_pieces
     * @example
     * // Get one Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends puzzle_piecesFindFirstArgs>(args?: SelectSubset<T, puzzle_piecesFindFirstArgs<ExtArgs>>): Prisma__puzzle_piecesClient<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Puzzle_pieces that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_piecesFindFirstOrThrowArgs} args - Arguments to find a Puzzle_pieces
     * @example
     * // Get one Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends puzzle_piecesFindFirstOrThrowArgs>(args?: SelectSubset<T, puzzle_piecesFindFirstOrThrowArgs<ExtArgs>>): Prisma__puzzle_piecesClient<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Puzzle_pieces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_piecesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.findMany()
     * 
     * // Get first 10 Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const puzzle_piecesWithIdOnly = await prisma.puzzle_pieces.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends puzzle_piecesFindManyArgs>(args?: SelectSubset<T, puzzle_piecesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Puzzle_pieces.
     * @param {puzzle_piecesCreateArgs} args - Arguments to create a Puzzle_pieces.
     * @example
     * // Create one Puzzle_pieces
     * const Puzzle_pieces = await prisma.puzzle_pieces.create({
     *   data: {
     *     // ... data to create a Puzzle_pieces
     *   }
     * })
     * 
     */
    create<T extends puzzle_piecesCreateArgs>(args: SelectSubset<T, puzzle_piecesCreateArgs<ExtArgs>>): Prisma__puzzle_piecesClient<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Puzzle_pieces.
     * @param {puzzle_piecesCreateManyArgs} args - Arguments to create many Puzzle_pieces.
     * @example
     * // Create many Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends puzzle_piecesCreateManyArgs>(args?: SelectSubset<T, puzzle_piecesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Puzzle_pieces and returns the data saved in the database.
     * @param {puzzle_piecesCreateManyAndReturnArgs} args - Arguments to create many Puzzle_pieces.
     * @example
     * // Create many Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Puzzle_pieces and only return the `id`
     * const puzzle_piecesWithIdOnly = await prisma.puzzle_pieces.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends puzzle_piecesCreateManyAndReturnArgs>(args?: SelectSubset<T, puzzle_piecesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Puzzle_pieces.
     * @param {puzzle_piecesDeleteArgs} args - Arguments to delete one Puzzle_pieces.
     * @example
     * // Delete one Puzzle_pieces
     * const Puzzle_pieces = await prisma.puzzle_pieces.delete({
     *   where: {
     *     // ... filter to delete one Puzzle_pieces
     *   }
     * })
     * 
     */
    delete<T extends puzzle_piecesDeleteArgs>(args: SelectSubset<T, puzzle_piecesDeleteArgs<ExtArgs>>): Prisma__puzzle_piecesClient<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Puzzle_pieces.
     * @param {puzzle_piecesUpdateArgs} args - Arguments to update one Puzzle_pieces.
     * @example
     * // Update one Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends puzzle_piecesUpdateArgs>(args: SelectSubset<T, puzzle_piecesUpdateArgs<ExtArgs>>): Prisma__puzzle_piecesClient<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Puzzle_pieces.
     * @param {puzzle_piecesDeleteManyArgs} args - Arguments to filter Puzzle_pieces to delete.
     * @example
     * // Delete a few Puzzle_pieces
     * const { count } = await prisma.puzzle_pieces.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends puzzle_piecesDeleteManyArgs>(args?: SelectSubset<T, puzzle_piecesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Puzzle_pieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_piecesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends puzzle_piecesUpdateManyArgs>(args: SelectSubset<T, puzzle_piecesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Puzzle_pieces and returns the data updated in the database.
     * @param {puzzle_piecesUpdateManyAndReturnArgs} args - Arguments to update many Puzzle_pieces.
     * @example
     * // Update many Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Puzzle_pieces and only return the `id`
     * const puzzle_piecesWithIdOnly = await prisma.puzzle_pieces.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends puzzle_piecesUpdateManyAndReturnArgs>(args: SelectSubset<T, puzzle_piecesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Puzzle_pieces.
     * @param {puzzle_piecesUpsertArgs} args - Arguments to update or create a Puzzle_pieces.
     * @example
     * // Update or create a Puzzle_pieces
     * const puzzle_pieces = await prisma.puzzle_pieces.upsert({
     *   create: {
     *     // ... data to create a Puzzle_pieces
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Puzzle_pieces we want to update
     *   }
     * })
     */
    upsert<T extends puzzle_piecesUpsertArgs>(args: SelectSubset<T, puzzle_piecesUpsertArgs<ExtArgs>>): Prisma__puzzle_piecesClient<$Result.GetResult<Prisma.$puzzle_piecesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Puzzle_pieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_piecesCountArgs} args - Arguments to filter Puzzle_pieces to count.
     * @example
     * // Count the number of Puzzle_pieces
     * const count = await prisma.puzzle_pieces.count({
     *   where: {
     *     // ... the filter for the Puzzle_pieces we want to count
     *   }
     * })
    **/
    count<T extends puzzle_piecesCountArgs>(
      args?: Subset<T, puzzle_piecesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Puzzle_piecesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Puzzle_pieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Puzzle_piecesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Puzzle_piecesAggregateArgs>(args: Subset<T, Puzzle_piecesAggregateArgs>): Prisma.PrismaPromise<GetPuzzle_piecesAggregateType<T>>

    /**
     * Group by Puzzle_pieces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {puzzle_piecesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends puzzle_piecesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: puzzle_piecesGroupByArgs['orderBy'] }
        : { orderBy?: puzzle_piecesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, puzzle_piecesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPuzzle_piecesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the puzzle_pieces model
   */
  readonly fields: puzzle_piecesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for puzzle_pieces.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__puzzle_piecesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    puzzle_game<T extends puzzle_pieces$puzzle_gameArgs<ExtArgs> = {}>(args?: Subset<T, puzzle_pieces$puzzle_gameArgs<ExtArgs>>): Prisma__puzzle_gameClient<$Result.GetResult<Prisma.$puzzle_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the puzzle_pieces model
   */
  interface puzzle_piecesFieldRefs {
    readonly id: FieldRef<"puzzle_pieces", 'Int'>
    readonly puzzleid: FieldRef<"puzzle_pieces", 'Int'>
    readonly piece_index: FieldRef<"puzzle_pieces", 'Int'>
    readonly x_position: FieldRef<"puzzle_pieces", 'Int'>
    readonly y_position: FieldRef<"puzzle_pieces", 'Int'>
    readonly correct_x: FieldRef<"puzzle_pieces", 'Int'>
    readonly correct_y: FieldRef<"puzzle_pieces", 'Int'>
    readonly image_piece_url: FieldRef<"puzzle_pieces", 'String'>
  }
    

  // Custom InputTypes
  /**
   * puzzle_pieces findUnique
   */
  export type puzzle_piecesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_pieces to fetch.
     */
    where: puzzle_piecesWhereUniqueInput
  }

  /**
   * puzzle_pieces findUniqueOrThrow
   */
  export type puzzle_piecesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_pieces to fetch.
     */
    where: puzzle_piecesWhereUniqueInput
  }

  /**
   * puzzle_pieces findFirst
   */
  export type puzzle_piecesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_pieces to fetch.
     */
    where?: puzzle_piecesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of puzzle_pieces to fetch.
     */
    orderBy?: puzzle_piecesOrderByWithRelationInput | puzzle_piecesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for puzzle_pieces.
     */
    cursor?: puzzle_piecesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` puzzle_pieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` puzzle_pieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of puzzle_pieces.
     */
    distinct?: Puzzle_piecesScalarFieldEnum | Puzzle_piecesScalarFieldEnum[]
  }

  /**
   * puzzle_pieces findFirstOrThrow
   */
  export type puzzle_piecesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_pieces to fetch.
     */
    where?: puzzle_piecesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of puzzle_pieces to fetch.
     */
    orderBy?: puzzle_piecesOrderByWithRelationInput | puzzle_piecesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for puzzle_pieces.
     */
    cursor?: puzzle_piecesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` puzzle_pieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` puzzle_pieces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of puzzle_pieces.
     */
    distinct?: Puzzle_piecesScalarFieldEnum | Puzzle_piecesScalarFieldEnum[]
  }

  /**
   * puzzle_pieces findMany
   */
  export type puzzle_piecesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    /**
     * Filter, which puzzle_pieces to fetch.
     */
    where?: puzzle_piecesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of puzzle_pieces to fetch.
     */
    orderBy?: puzzle_piecesOrderByWithRelationInput | puzzle_piecesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing puzzle_pieces.
     */
    cursor?: puzzle_piecesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` puzzle_pieces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` puzzle_pieces.
     */
    skip?: number
    distinct?: Puzzle_piecesScalarFieldEnum | Puzzle_piecesScalarFieldEnum[]
  }

  /**
   * puzzle_pieces create
   */
  export type puzzle_piecesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    /**
     * The data needed to create a puzzle_pieces.
     */
    data: XOR<puzzle_piecesCreateInput, puzzle_piecesUncheckedCreateInput>
  }

  /**
   * puzzle_pieces createMany
   */
  export type puzzle_piecesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many puzzle_pieces.
     */
    data: puzzle_piecesCreateManyInput | puzzle_piecesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * puzzle_pieces createManyAndReturn
   */
  export type puzzle_piecesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * The data used to create many puzzle_pieces.
     */
    data: puzzle_piecesCreateManyInput | puzzle_piecesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * puzzle_pieces update
   */
  export type puzzle_piecesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    /**
     * The data needed to update a puzzle_pieces.
     */
    data: XOR<puzzle_piecesUpdateInput, puzzle_piecesUncheckedUpdateInput>
    /**
     * Choose, which puzzle_pieces to update.
     */
    where: puzzle_piecesWhereUniqueInput
  }

  /**
   * puzzle_pieces updateMany
   */
  export type puzzle_piecesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update puzzle_pieces.
     */
    data: XOR<puzzle_piecesUpdateManyMutationInput, puzzle_piecesUncheckedUpdateManyInput>
    /**
     * Filter which puzzle_pieces to update
     */
    where?: puzzle_piecesWhereInput
    /**
     * Limit how many puzzle_pieces to update.
     */
    limit?: number
  }

  /**
   * puzzle_pieces updateManyAndReturn
   */
  export type puzzle_piecesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * The data used to update puzzle_pieces.
     */
    data: XOR<puzzle_piecesUpdateManyMutationInput, puzzle_piecesUncheckedUpdateManyInput>
    /**
     * Filter which puzzle_pieces to update
     */
    where?: puzzle_piecesWhereInput
    /**
     * Limit how many puzzle_pieces to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * puzzle_pieces upsert
   */
  export type puzzle_piecesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    /**
     * The filter to search for the puzzle_pieces to update in case it exists.
     */
    where: puzzle_piecesWhereUniqueInput
    /**
     * In case the puzzle_pieces found by the `where` argument doesn't exist, create a new puzzle_pieces with this data.
     */
    create: XOR<puzzle_piecesCreateInput, puzzle_piecesUncheckedCreateInput>
    /**
     * In case the puzzle_pieces was found with the provided `where` argument, update it with this data.
     */
    update: XOR<puzzle_piecesUpdateInput, puzzle_piecesUncheckedUpdateInput>
  }

  /**
   * puzzle_pieces delete
   */
  export type puzzle_piecesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
    /**
     * Filter which puzzle_pieces to delete.
     */
    where: puzzle_piecesWhereUniqueInput
  }

  /**
   * puzzle_pieces deleteMany
   */
  export type puzzle_piecesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which puzzle_pieces to delete
     */
    where?: puzzle_piecesWhereInput
    /**
     * Limit how many puzzle_pieces to delete.
     */
    limit?: number
  }

  /**
   * puzzle_pieces.puzzle_game
   */
  export type puzzle_pieces$puzzle_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_game
     */
    select?: puzzle_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_game
     */
    omit?: puzzle_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_gameInclude<ExtArgs> | null
    where?: puzzle_gameWhereInput
  }

  /**
   * puzzle_pieces without action
   */
  export type puzzle_piecesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the puzzle_pieces
     */
    select?: puzzle_piecesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the puzzle_pieces
     */
    omit?: puzzle_piecesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: puzzle_piecesInclude<ExtArgs> | null
  }


  /**
   * Model quiz_game
   */

  export type AggregateQuiz_game = {
    _count: Quiz_gameCountAggregateOutputType | null
    _avg: Quiz_gameAvgAggregateOutputType | null
    _sum: Quiz_gameSumAggregateOutputType | null
    _min: Quiz_gameMinAggregateOutputType | null
    _max: Quiz_gameMaxAggregateOutputType | null
  }

  export type Quiz_gameAvgAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
  }

  export type Quiz_gameSumAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
  }

  export type Quiz_gameMinAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
    title: string | null
    description: string | null
  }

  export type Quiz_gameMaxAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
    title: string | null
    description: string | null
  }

  export type Quiz_gameCountAggregateOutputType = {
    id: number
    regionid: number
    gametype: number
    title: number
    description: number
    _all: number
  }


  export type Quiz_gameAvgAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
  }

  export type Quiz_gameSumAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
  }

  export type Quiz_gameMinAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
    title?: true
    description?: true
  }

  export type Quiz_gameMaxAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
    title?: true
    description?: true
  }

  export type Quiz_gameCountAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
    title?: true
    description?: true
    _all?: true
  }

  export type Quiz_gameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quiz_game to aggregate.
     */
    where?: quiz_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_games to fetch.
     */
    orderBy?: quiz_gameOrderByWithRelationInput | quiz_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quiz_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quiz_games
    **/
    _count?: true | Quiz_gameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Quiz_gameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Quiz_gameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quiz_gameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quiz_gameMaxAggregateInputType
  }

  export type GetQuiz_gameAggregateType<T extends Quiz_gameAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz_game]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz_game[P]>
      : GetScalarType<T[P], AggregateQuiz_game[P]>
  }




  export type quiz_gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quiz_gameWhereInput
    orderBy?: quiz_gameOrderByWithAggregationInput | quiz_gameOrderByWithAggregationInput[]
    by: Quiz_gameScalarFieldEnum[] | Quiz_gameScalarFieldEnum
    having?: quiz_gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quiz_gameCountAggregateInputType | true
    _avg?: Quiz_gameAvgAggregateInputType
    _sum?: Quiz_gameSumAggregateInputType
    _min?: Quiz_gameMinAggregateInputType
    _max?: Quiz_gameMaxAggregateInputType
  }

  export type Quiz_gameGroupByOutputType = {
    id: number
    regionid: number | null
    gametype: number | null
    title: string
    description: string | null
    _count: Quiz_gameCountAggregateOutputType | null
    _avg: Quiz_gameAvgAggregateOutputType | null
    _sum: Quiz_gameSumAggregateOutputType | null
    _min: Quiz_gameMinAggregateOutputType | null
    _max: Quiz_gameMaxAggregateOutputType | null
  }

  type GetQuiz_gameGroupByPayload<T extends quiz_gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Quiz_gameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quiz_gameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quiz_gameGroupByOutputType[P]>
            : GetScalarType<T[P], Quiz_gameGroupByOutputType[P]>
        }
      >
    >


  export type quiz_gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    title?: boolean
    description?: boolean
    AfterQuestionInformation?: boolean | quiz_game$AfterQuestionInformationArgs<ExtArgs>
    game_type?: boolean | quiz_game$game_typeArgs<ExtArgs>
    Region?: boolean | quiz_game$RegionArgs<ExtArgs>
    quiz_game_qa?: boolean | quiz_game$quiz_game_qaArgs<ExtArgs>
    _count?: boolean | Quiz_gameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz_game"]>

  export type quiz_gameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    title?: boolean
    description?: boolean
    game_type?: boolean | quiz_game$game_typeArgs<ExtArgs>
    Region?: boolean | quiz_game$RegionArgs<ExtArgs>
  }, ExtArgs["result"]["quiz_game"]>

  export type quiz_gameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    title?: boolean
    description?: boolean
    game_type?: boolean | quiz_game$game_typeArgs<ExtArgs>
    Region?: boolean | quiz_game$RegionArgs<ExtArgs>
  }, ExtArgs["result"]["quiz_game"]>

  export type quiz_gameSelectScalar = {
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    title?: boolean
    description?: boolean
  }

  export type quiz_gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionid" | "gametype" | "title" | "description", ExtArgs["result"]["quiz_game"]>
  export type quiz_gameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AfterQuestionInformation?: boolean | quiz_game$AfterQuestionInformationArgs<ExtArgs>
    game_type?: boolean | quiz_game$game_typeArgs<ExtArgs>
    Region?: boolean | quiz_game$RegionArgs<ExtArgs>
    quiz_game_qa?: boolean | quiz_game$quiz_game_qaArgs<ExtArgs>
    _count?: boolean | Quiz_gameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type quiz_gameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game_type?: boolean | quiz_game$game_typeArgs<ExtArgs>
    Region?: boolean | quiz_game$RegionArgs<ExtArgs>
  }
  export type quiz_gameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game_type?: boolean | quiz_game$game_typeArgs<ExtArgs>
    Region?: boolean | quiz_game$RegionArgs<ExtArgs>
  }

  export type $quiz_gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quiz_game"
    objects: {
      AfterQuestionInformation: Prisma.$AfterQuestionInformationPayload<ExtArgs>[]
      game_type: Prisma.$game_typePayload<ExtArgs> | null
      Region: Prisma.$RegionPayload<ExtArgs> | null
      quiz_game_qa: Prisma.$quiz_game_qaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionid: number | null
      gametype: number | null
      title: string
      description: string | null
    }, ExtArgs["result"]["quiz_game"]>
    composites: {}
  }

  type quiz_gameGetPayload<S extends boolean | null | undefined | quiz_gameDefaultArgs> = $Result.GetResult<Prisma.$quiz_gamePayload, S>

  type quiz_gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quiz_gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Quiz_gameCountAggregateInputType | true
    }

  export interface quiz_gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quiz_game'], meta: { name: 'quiz_game' } }
    /**
     * Find zero or one Quiz_game that matches the filter.
     * @param {quiz_gameFindUniqueArgs} args - Arguments to find a Quiz_game
     * @example
     * // Get one Quiz_game
     * const quiz_game = await prisma.quiz_game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quiz_gameFindUniqueArgs>(args: SelectSubset<T, quiz_gameFindUniqueArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz_game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quiz_gameFindUniqueOrThrowArgs} args - Arguments to find a Quiz_game
     * @example
     * // Get one Quiz_game
     * const quiz_game = await prisma.quiz_game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quiz_gameFindUniqueOrThrowArgs>(args: SelectSubset<T, quiz_gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz_game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_gameFindFirstArgs} args - Arguments to find a Quiz_game
     * @example
     * // Get one Quiz_game
     * const quiz_game = await prisma.quiz_game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quiz_gameFindFirstArgs>(args?: SelectSubset<T, quiz_gameFindFirstArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz_game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_gameFindFirstOrThrowArgs} args - Arguments to find a Quiz_game
     * @example
     * // Get one Quiz_game
     * const quiz_game = await prisma.quiz_game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quiz_gameFindFirstOrThrowArgs>(args?: SelectSubset<T, quiz_gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quiz_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quiz_games
     * const quiz_games = await prisma.quiz_game.findMany()
     * 
     * // Get first 10 Quiz_games
     * const quiz_games = await prisma.quiz_game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quiz_gameWithIdOnly = await prisma.quiz_game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quiz_gameFindManyArgs>(args?: SelectSubset<T, quiz_gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz_game.
     * @param {quiz_gameCreateArgs} args - Arguments to create a Quiz_game.
     * @example
     * // Create one Quiz_game
     * const Quiz_game = await prisma.quiz_game.create({
     *   data: {
     *     // ... data to create a Quiz_game
     *   }
     * })
     * 
     */
    create<T extends quiz_gameCreateArgs>(args: SelectSubset<T, quiz_gameCreateArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quiz_games.
     * @param {quiz_gameCreateManyArgs} args - Arguments to create many Quiz_games.
     * @example
     * // Create many Quiz_games
     * const quiz_game = await prisma.quiz_game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quiz_gameCreateManyArgs>(args?: SelectSubset<T, quiz_gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quiz_games and returns the data saved in the database.
     * @param {quiz_gameCreateManyAndReturnArgs} args - Arguments to create many Quiz_games.
     * @example
     * // Create many Quiz_games
     * const quiz_game = await prisma.quiz_game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quiz_games and only return the `id`
     * const quiz_gameWithIdOnly = await prisma.quiz_game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends quiz_gameCreateManyAndReturnArgs>(args?: SelectSubset<T, quiz_gameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz_game.
     * @param {quiz_gameDeleteArgs} args - Arguments to delete one Quiz_game.
     * @example
     * // Delete one Quiz_game
     * const Quiz_game = await prisma.quiz_game.delete({
     *   where: {
     *     // ... filter to delete one Quiz_game
     *   }
     * })
     * 
     */
    delete<T extends quiz_gameDeleteArgs>(args: SelectSubset<T, quiz_gameDeleteArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz_game.
     * @param {quiz_gameUpdateArgs} args - Arguments to update one Quiz_game.
     * @example
     * // Update one Quiz_game
     * const quiz_game = await prisma.quiz_game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quiz_gameUpdateArgs>(args: SelectSubset<T, quiz_gameUpdateArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quiz_games.
     * @param {quiz_gameDeleteManyArgs} args - Arguments to filter Quiz_games to delete.
     * @example
     * // Delete a few Quiz_games
     * const { count } = await prisma.quiz_game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quiz_gameDeleteManyArgs>(args?: SelectSubset<T, quiz_gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quiz_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quiz_games
     * const quiz_game = await prisma.quiz_game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quiz_gameUpdateManyArgs>(args: SelectSubset<T, quiz_gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quiz_games and returns the data updated in the database.
     * @param {quiz_gameUpdateManyAndReturnArgs} args - Arguments to update many Quiz_games.
     * @example
     * // Update many Quiz_games
     * const quiz_game = await prisma.quiz_game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quiz_games and only return the `id`
     * const quiz_gameWithIdOnly = await prisma.quiz_game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends quiz_gameUpdateManyAndReturnArgs>(args: SelectSubset<T, quiz_gameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz_game.
     * @param {quiz_gameUpsertArgs} args - Arguments to update or create a Quiz_game.
     * @example
     * // Update or create a Quiz_game
     * const quiz_game = await prisma.quiz_game.upsert({
     *   create: {
     *     // ... data to create a Quiz_game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz_game we want to update
     *   }
     * })
     */
    upsert<T extends quiz_gameUpsertArgs>(args: SelectSubset<T, quiz_gameUpsertArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quiz_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_gameCountArgs} args - Arguments to filter Quiz_games to count.
     * @example
     * // Count the number of Quiz_games
     * const count = await prisma.quiz_game.count({
     *   where: {
     *     // ... the filter for the Quiz_games we want to count
     *   }
     * })
    **/
    count<T extends quiz_gameCountArgs>(
      args?: Subset<T, quiz_gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quiz_gameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quiz_gameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quiz_gameAggregateArgs>(args: Subset<T, Quiz_gameAggregateArgs>): Prisma.PrismaPromise<GetQuiz_gameAggregateType<T>>

    /**
     * Group by Quiz_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quiz_gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quiz_gameGroupByArgs['orderBy'] }
        : { orderBy?: quiz_gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quiz_gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuiz_gameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quiz_game model
   */
  readonly fields: quiz_gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quiz_game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quiz_gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AfterQuestionInformation<T extends quiz_game$AfterQuestionInformationArgs<ExtArgs> = {}>(args?: Subset<T, quiz_game$AfterQuestionInformationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    game_type<T extends quiz_game$game_typeArgs<ExtArgs> = {}>(args?: Subset<T, quiz_game$game_typeArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Region<T extends quiz_game$RegionArgs<ExtArgs> = {}>(args?: Subset<T, quiz_game$RegionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    quiz_game_qa<T extends quiz_game$quiz_game_qaArgs<ExtArgs> = {}>(args?: Subset<T, quiz_game$quiz_game_qaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quiz_game model
   */
  interface quiz_gameFieldRefs {
    readonly id: FieldRef<"quiz_game", 'Int'>
    readonly regionid: FieldRef<"quiz_game", 'Int'>
    readonly gametype: FieldRef<"quiz_game", 'Int'>
    readonly title: FieldRef<"quiz_game", 'String'>
    readonly description: FieldRef<"quiz_game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * quiz_game findUnique
   */
  export type quiz_gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    /**
     * Filter, which quiz_game to fetch.
     */
    where: quiz_gameWhereUniqueInput
  }

  /**
   * quiz_game findUniqueOrThrow
   */
  export type quiz_gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    /**
     * Filter, which quiz_game to fetch.
     */
    where: quiz_gameWhereUniqueInput
  }

  /**
   * quiz_game findFirst
   */
  export type quiz_gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    /**
     * Filter, which quiz_game to fetch.
     */
    where?: quiz_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_games to fetch.
     */
    orderBy?: quiz_gameOrderByWithRelationInput | quiz_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quiz_games.
     */
    cursor?: quiz_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quiz_games.
     */
    distinct?: Quiz_gameScalarFieldEnum | Quiz_gameScalarFieldEnum[]
  }

  /**
   * quiz_game findFirstOrThrow
   */
  export type quiz_gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    /**
     * Filter, which quiz_game to fetch.
     */
    where?: quiz_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_games to fetch.
     */
    orderBy?: quiz_gameOrderByWithRelationInput | quiz_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quiz_games.
     */
    cursor?: quiz_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quiz_games.
     */
    distinct?: Quiz_gameScalarFieldEnum | Quiz_gameScalarFieldEnum[]
  }

  /**
   * quiz_game findMany
   */
  export type quiz_gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    /**
     * Filter, which quiz_games to fetch.
     */
    where?: quiz_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_games to fetch.
     */
    orderBy?: quiz_gameOrderByWithRelationInput | quiz_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quiz_games.
     */
    cursor?: quiz_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_games.
     */
    skip?: number
    distinct?: Quiz_gameScalarFieldEnum | Quiz_gameScalarFieldEnum[]
  }

  /**
   * quiz_game create
   */
  export type quiz_gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    /**
     * The data needed to create a quiz_game.
     */
    data: XOR<quiz_gameCreateInput, quiz_gameUncheckedCreateInput>
  }

  /**
   * quiz_game createMany
   */
  export type quiz_gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quiz_games.
     */
    data: quiz_gameCreateManyInput | quiz_gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quiz_game createManyAndReturn
   */
  export type quiz_gameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * The data used to create many quiz_games.
     */
    data: quiz_gameCreateManyInput | quiz_gameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * quiz_game update
   */
  export type quiz_gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    /**
     * The data needed to update a quiz_game.
     */
    data: XOR<quiz_gameUpdateInput, quiz_gameUncheckedUpdateInput>
    /**
     * Choose, which quiz_game to update.
     */
    where: quiz_gameWhereUniqueInput
  }

  /**
   * quiz_game updateMany
   */
  export type quiz_gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quiz_games.
     */
    data: XOR<quiz_gameUpdateManyMutationInput, quiz_gameUncheckedUpdateManyInput>
    /**
     * Filter which quiz_games to update
     */
    where?: quiz_gameWhereInput
    /**
     * Limit how many quiz_games to update.
     */
    limit?: number
  }

  /**
   * quiz_game updateManyAndReturn
   */
  export type quiz_gameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * The data used to update quiz_games.
     */
    data: XOR<quiz_gameUpdateManyMutationInput, quiz_gameUncheckedUpdateManyInput>
    /**
     * Filter which quiz_games to update
     */
    where?: quiz_gameWhereInput
    /**
     * Limit how many quiz_games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * quiz_game upsert
   */
  export type quiz_gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    /**
     * The filter to search for the quiz_game to update in case it exists.
     */
    where: quiz_gameWhereUniqueInput
    /**
     * In case the quiz_game found by the `where` argument doesn't exist, create a new quiz_game with this data.
     */
    create: XOR<quiz_gameCreateInput, quiz_gameUncheckedCreateInput>
    /**
     * In case the quiz_game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quiz_gameUpdateInput, quiz_gameUncheckedUpdateInput>
  }

  /**
   * quiz_game delete
   */
  export type quiz_gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    /**
     * Filter which quiz_game to delete.
     */
    where: quiz_gameWhereUniqueInput
  }

  /**
   * quiz_game deleteMany
   */
  export type quiz_gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quiz_games to delete
     */
    where?: quiz_gameWhereInput
    /**
     * Limit how many quiz_games to delete.
     */
    limit?: number
  }

  /**
   * quiz_game.AfterQuestionInformation
   */
  export type quiz_game$AfterQuestionInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    where?: AfterQuestionInformationWhereInput
    orderBy?: AfterQuestionInformationOrderByWithRelationInput | AfterQuestionInformationOrderByWithRelationInput[]
    cursor?: AfterQuestionInformationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AfterQuestionInformationScalarFieldEnum | AfterQuestionInformationScalarFieldEnum[]
  }

  /**
   * quiz_game.game_type
   */
  export type quiz_game$game_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    where?: game_typeWhereInput
  }

  /**
   * quiz_game.Region
   */
  export type quiz_game$RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * quiz_game.quiz_game_qa
   */
  export type quiz_game$quiz_game_qaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    where?: quiz_game_qaWhereInput
    orderBy?: quiz_game_qaOrderByWithRelationInput | quiz_game_qaOrderByWithRelationInput[]
    cursor?: quiz_game_qaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Quiz_game_qaScalarFieldEnum | Quiz_game_qaScalarFieldEnum[]
  }

  /**
   * quiz_game without action
   */
  export type quiz_gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
  }


  /**
   * Model quiz_game_qa
   */

  export type AggregateQuiz_game_qa = {
    _count: Quiz_game_qaCountAggregateOutputType | null
    _avg: Quiz_game_qaAvgAggregateOutputType | null
    _sum: Quiz_game_qaSumAggregateOutputType | null
    _min: Quiz_game_qaMinAggregateOutputType | null
    _max: Quiz_game_qaMaxAggregateOutputType | null
  }

  export type Quiz_game_qaAvgAggregateOutputType = {
    id: number | null
    quiz_game_id: number | null
  }

  export type Quiz_game_qaSumAggregateOutputType = {
    id: number | null
    quiz_game_id: number | null
  }

  export type Quiz_game_qaMinAggregateOutputType = {
    id: number | null
    quiz_game_id: number | null
    question: string | null
    correct_answer: string | null
  }

  export type Quiz_game_qaMaxAggregateOutputType = {
    id: number | null
    quiz_game_id: number | null
    question: string | null
    correct_answer: string | null
  }

  export type Quiz_game_qaCountAggregateOutputType = {
    id: number
    quiz_game_id: number
    question: number
    wrong_answers: number
    correct_answer: number
    _all: number
  }


  export type Quiz_game_qaAvgAggregateInputType = {
    id?: true
    quiz_game_id?: true
  }

  export type Quiz_game_qaSumAggregateInputType = {
    id?: true
    quiz_game_id?: true
  }

  export type Quiz_game_qaMinAggregateInputType = {
    id?: true
    quiz_game_id?: true
    question?: true
    correct_answer?: true
  }

  export type Quiz_game_qaMaxAggregateInputType = {
    id?: true
    quiz_game_id?: true
    question?: true
    correct_answer?: true
  }

  export type Quiz_game_qaCountAggregateInputType = {
    id?: true
    quiz_game_id?: true
    question?: true
    wrong_answers?: true
    correct_answer?: true
    _all?: true
  }

  export type Quiz_game_qaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quiz_game_qa to aggregate.
     */
    where?: quiz_game_qaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_game_qas to fetch.
     */
    orderBy?: quiz_game_qaOrderByWithRelationInput | quiz_game_qaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: quiz_game_qaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_game_qas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_game_qas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned quiz_game_qas
    **/
    _count?: true | Quiz_game_qaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Quiz_game_qaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Quiz_game_qaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Quiz_game_qaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Quiz_game_qaMaxAggregateInputType
  }

  export type GetQuiz_game_qaAggregateType<T extends Quiz_game_qaAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz_game_qa]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz_game_qa[P]>
      : GetScalarType<T[P], AggregateQuiz_game_qa[P]>
  }




  export type quiz_game_qaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: quiz_game_qaWhereInput
    orderBy?: quiz_game_qaOrderByWithAggregationInput | quiz_game_qaOrderByWithAggregationInput[]
    by: Quiz_game_qaScalarFieldEnum[] | Quiz_game_qaScalarFieldEnum
    having?: quiz_game_qaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Quiz_game_qaCountAggregateInputType | true
    _avg?: Quiz_game_qaAvgAggregateInputType
    _sum?: Quiz_game_qaSumAggregateInputType
    _min?: Quiz_game_qaMinAggregateInputType
    _max?: Quiz_game_qaMaxAggregateInputType
  }

  export type Quiz_game_qaGroupByOutputType = {
    id: number
    quiz_game_id: number | null
    question: string
    wrong_answers: JsonValue
    correct_answer: string
    _count: Quiz_game_qaCountAggregateOutputType | null
    _avg: Quiz_game_qaAvgAggregateOutputType | null
    _sum: Quiz_game_qaSumAggregateOutputType | null
    _min: Quiz_game_qaMinAggregateOutputType | null
    _max: Quiz_game_qaMaxAggregateOutputType | null
  }

  type GetQuiz_game_qaGroupByPayload<T extends quiz_game_qaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Quiz_game_qaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Quiz_game_qaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Quiz_game_qaGroupByOutputType[P]>
            : GetScalarType<T[P], Quiz_game_qaGroupByOutputType[P]>
        }
      >
    >


  export type quiz_game_qaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_game_id?: boolean
    question?: boolean
    wrong_answers?: boolean
    correct_answer?: boolean
    quiz_game?: boolean | quiz_game_qa$quiz_gameArgs<ExtArgs>
  }, ExtArgs["result"]["quiz_game_qa"]>

  export type quiz_game_qaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_game_id?: boolean
    question?: boolean
    wrong_answers?: boolean
    correct_answer?: boolean
    quiz_game?: boolean | quiz_game_qa$quiz_gameArgs<ExtArgs>
  }, ExtArgs["result"]["quiz_game_qa"]>

  export type quiz_game_qaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quiz_game_id?: boolean
    question?: boolean
    wrong_answers?: boolean
    correct_answer?: boolean
    quiz_game?: boolean | quiz_game_qa$quiz_gameArgs<ExtArgs>
  }, ExtArgs["result"]["quiz_game_qa"]>

  export type quiz_game_qaSelectScalar = {
    id?: boolean
    quiz_game_id?: boolean
    question?: boolean
    wrong_answers?: boolean
    correct_answer?: boolean
  }

  export type quiz_game_qaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quiz_game_id" | "question" | "wrong_answers" | "correct_answer", ExtArgs["result"]["quiz_game_qa"]>
  export type quiz_game_qaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz_game?: boolean | quiz_game_qa$quiz_gameArgs<ExtArgs>
  }
  export type quiz_game_qaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz_game?: boolean | quiz_game_qa$quiz_gameArgs<ExtArgs>
  }
  export type quiz_game_qaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz_game?: boolean | quiz_game_qa$quiz_gameArgs<ExtArgs>
  }

  export type $quiz_game_qaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "quiz_game_qa"
    objects: {
      quiz_game: Prisma.$quiz_gamePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quiz_game_id: number | null
      question: string
      wrong_answers: Prisma.JsonValue
      correct_answer: string
    }, ExtArgs["result"]["quiz_game_qa"]>
    composites: {}
  }

  type quiz_game_qaGetPayload<S extends boolean | null | undefined | quiz_game_qaDefaultArgs> = $Result.GetResult<Prisma.$quiz_game_qaPayload, S>

  type quiz_game_qaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<quiz_game_qaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Quiz_game_qaCountAggregateInputType | true
    }

  export interface quiz_game_qaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['quiz_game_qa'], meta: { name: 'quiz_game_qa' } }
    /**
     * Find zero or one Quiz_game_qa that matches the filter.
     * @param {quiz_game_qaFindUniqueArgs} args - Arguments to find a Quiz_game_qa
     * @example
     * // Get one Quiz_game_qa
     * const quiz_game_qa = await prisma.quiz_game_qa.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends quiz_game_qaFindUniqueArgs>(args: SelectSubset<T, quiz_game_qaFindUniqueArgs<ExtArgs>>): Prisma__quiz_game_qaClient<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz_game_qa that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {quiz_game_qaFindUniqueOrThrowArgs} args - Arguments to find a Quiz_game_qa
     * @example
     * // Get one Quiz_game_qa
     * const quiz_game_qa = await prisma.quiz_game_qa.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends quiz_game_qaFindUniqueOrThrowArgs>(args: SelectSubset<T, quiz_game_qaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__quiz_game_qaClient<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz_game_qa that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_game_qaFindFirstArgs} args - Arguments to find a Quiz_game_qa
     * @example
     * // Get one Quiz_game_qa
     * const quiz_game_qa = await prisma.quiz_game_qa.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends quiz_game_qaFindFirstArgs>(args?: SelectSubset<T, quiz_game_qaFindFirstArgs<ExtArgs>>): Prisma__quiz_game_qaClient<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz_game_qa that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_game_qaFindFirstOrThrowArgs} args - Arguments to find a Quiz_game_qa
     * @example
     * // Get one Quiz_game_qa
     * const quiz_game_qa = await prisma.quiz_game_qa.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends quiz_game_qaFindFirstOrThrowArgs>(args?: SelectSubset<T, quiz_game_qaFindFirstOrThrowArgs<ExtArgs>>): Prisma__quiz_game_qaClient<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quiz_game_qas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_game_qaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quiz_game_qas
     * const quiz_game_qas = await prisma.quiz_game_qa.findMany()
     * 
     * // Get first 10 Quiz_game_qas
     * const quiz_game_qas = await prisma.quiz_game_qa.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quiz_game_qaWithIdOnly = await prisma.quiz_game_qa.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends quiz_game_qaFindManyArgs>(args?: SelectSubset<T, quiz_game_qaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz_game_qa.
     * @param {quiz_game_qaCreateArgs} args - Arguments to create a Quiz_game_qa.
     * @example
     * // Create one Quiz_game_qa
     * const Quiz_game_qa = await prisma.quiz_game_qa.create({
     *   data: {
     *     // ... data to create a Quiz_game_qa
     *   }
     * })
     * 
     */
    create<T extends quiz_game_qaCreateArgs>(args: SelectSubset<T, quiz_game_qaCreateArgs<ExtArgs>>): Prisma__quiz_game_qaClient<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quiz_game_qas.
     * @param {quiz_game_qaCreateManyArgs} args - Arguments to create many Quiz_game_qas.
     * @example
     * // Create many Quiz_game_qas
     * const quiz_game_qa = await prisma.quiz_game_qa.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends quiz_game_qaCreateManyArgs>(args?: SelectSubset<T, quiz_game_qaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quiz_game_qas and returns the data saved in the database.
     * @param {quiz_game_qaCreateManyAndReturnArgs} args - Arguments to create many Quiz_game_qas.
     * @example
     * // Create many Quiz_game_qas
     * const quiz_game_qa = await prisma.quiz_game_qa.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quiz_game_qas and only return the `id`
     * const quiz_game_qaWithIdOnly = await prisma.quiz_game_qa.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends quiz_game_qaCreateManyAndReturnArgs>(args?: SelectSubset<T, quiz_game_qaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz_game_qa.
     * @param {quiz_game_qaDeleteArgs} args - Arguments to delete one Quiz_game_qa.
     * @example
     * // Delete one Quiz_game_qa
     * const Quiz_game_qa = await prisma.quiz_game_qa.delete({
     *   where: {
     *     // ... filter to delete one Quiz_game_qa
     *   }
     * })
     * 
     */
    delete<T extends quiz_game_qaDeleteArgs>(args: SelectSubset<T, quiz_game_qaDeleteArgs<ExtArgs>>): Prisma__quiz_game_qaClient<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz_game_qa.
     * @param {quiz_game_qaUpdateArgs} args - Arguments to update one Quiz_game_qa.
     * @example
     * // Update one Quiz_game_qa
     * const quiz_game_qa = await prisma.quiz_game_qa.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends quiz_game_qaUpdateArgs>(args: SelectSubset<T, quiz_game_qaUpdateArgs<ExtArgs>>): Prisma__quiz_game_qaClient<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quiz_game_qas.
     * @param {quiz_game_qaDeleteManyArgs} args - Arguments to filter Quiz_game_qas to delete.
     * @example
     * // Delete a few Quiz_game_qas
     * const { count } = await prisma.quiz_game_qa.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends quiz_game_qaDeleteManyArgs>(args?: SelectSubset<T, quiz_game_qaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quiz_game_qas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_game_qaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quiz_game_qas
     * const quiz_game_qa = await prisma.quiz_game_qa.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends quiz_game_qaUpdateManyArgs>(args: SelectSubset<T, quiz_game_qaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quiz_game_qas and returns the data updated in the database.
     * @param {quiz_game_qaUpdateManyAndReturnArgs} args - Arguments to update many Quiz_game_qas.
     * @example
     * // Update many Quiz_game_qas
     * const quiz_game_qa = await prisma.quiz_game_qa.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quiz_game_qas and only return the `id`
     * const quiz_game_qaWithIdOnly = await prisma.quiz_game_qa.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends quiz_game_qaUpdateManyAndReturnArgs>(args: SelectSubset<T, quiz_game_qaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz_game_qa.
     * @param {quiz_game_qaUpsertArgs} args - Arguments to update or create a Quiz_game_qa.
     * @example
     * // Update or create a Quiz_game_qa
     * const quiz_game_qa = await prisma.quiz_game_qa.upsert({
     *   create: {
     *     // ... data to create a Quiz_game_qa
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz_game_qa we want to update
     *   }
     * })
     */
    upsert<T extends quiz_game_qaUpsertArgs>(args: SelectSubset<T, quiz_game_qaUpsertArgs<ExtArgs>>): Prisma__quiz_game_qaClient<$Result.GetResult<Prisma.$quiz_game_qaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quiz_game_qas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_game_qaCountArgs} args - Arguments to filter Quiz_game_qas to count.
     * @example
     * // Count the number of Quiz_game_qas
     * const count = await prisma.quiz_game_qa.count({
     *   where: {
     *     // ... the filter for the Quiz_game_qas we want to count
     *   }
     * })
    **/
    count<T extends quiz_game_qaCountArgs>(
      args?: Subset<T, quiz_game_qaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Quiz_game_qaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz_game_qa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Quiz_game_qaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Quiz_game_qaAggregateArgs>(args: Subset<T, Quiz_game_qaAggregateArgs>): Prisma.PrismaPromise<GetQuiz_game_qaAggregateType<T>>

    /**
     * Group by Quiz_game_qa.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {quiz_game_qaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends quiz_game_qaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: quiz_game_qaGroupByArgs['orderBy'] }
        : { orderBy?: quiz_game_qaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, quiz_game_qaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuiz_game_qaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the quiz_game_qa model
   */
  readonly fields: quiz_game_qaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for quiz_game_qa.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__quiz_game_qaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz_game<T extends quiz_game_qa$quiz_gameArgs<ExtArgs> = {}>(args?: Subset<T, quiz_game_qa$quiz_gameArgs<ExtArgs>>): Prisma__quiz_gameClient<$Result.GetResult<Prisma.$quiz_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the quiz_game_qa model
   */
  interface quiz_game_qaFieldRefs {
    readonly id: FieldRef<"quiz_game_qa", 'Int'>
    readonly quiz_game_id: FieldRef<"quiz_game_qa", 'Int'>
    readonly question: FieldRef<"quiz_game_qa", 'String'>
    readonly wrong_answers: FieldRef<"quiz_game_qa", 'Json'>
    readonly correct_answer: FieldRef<"quiz_game_qa", 'String'>
  }
    

  // Custom InputTypes
  /**
   * quiz_game_qa findUnique
   */
  export type quiz_game_qaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    /**
     * Filter, which quiz_game_qa to fetch.
     */
    where: quiz_game_qaWhereUniqueInput
  }

  /**
   * quiz_game_qa findUniqueOrThrow
   */
  export type quiz_game_qaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    /**
     * Filter, which quiz_game_qa to fetch.
     */
    where: quiz_game_qaWhereUniqueInput
  }

  /**
   * quiz_game_qa findFirst
   */
  export type quiz_game_qaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    /**
     * Filter, which quiz_game_qa to fetch.
     */
    where?: quiz_game_qaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_game_qas to fetch.
     */
    orderBy?: quiz_game_qaOrderByWithRelationInput | quiz_game_qaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quiz_game_qas.
     */
    cursor?: quiz_game_qaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_game_qas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_game_qas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quiz_game_qas.
     */
    distinct?: Quiz_game_qaScalarFieldEnum | Quiz_game_qaScalarFieldEnum[]
  }

  /**
   * quiz_game_qa findFirstOrThrow
   */
  export type quiz_game_qaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    /**
     * Filter, which quiz_game_qa to fetch.
     */
    where?: quiz_game_qaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_game_qas to fetch.
     */
    orderBy?: quiz_game_qaOrderByWithRelationInput | quiz_game_qaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for quiz_game_qas.
     */
    cursor?: quiz_game_qaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_game_qas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_game_qas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of quiz_game_qas.
     */
    distinct?: Quiz_game_qaScalarFieldEnum | Quiz_game_qaScalarFieldEnum[]
  }

  /**
   * quiz_game_qa findMany
   */
  export type quiz_game_qaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    /**
     * Filter, which quiz_game_qas to fetch.
     */
    where?: quiz_game_qaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of quiz_game_qas to fetch.
     */
    orderBy?: quiz_game_qaOrderByWithRelationInput | quiz_game_qaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing quiz_game_qas.
     */
    cursor?: quiz_game_qaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` quiz_game_qas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` quiz_game_qas.
     */
    skip?: number
    distinct?: Quiz_game_qaScalarFieldEnum | Quiz_game_qaScalarFieldEnum[]
  }

  /**
   * quiz_game_qa create
   */
  export type quiz_game_qaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    /**
     * The data needed to create a quiz_game_qa.
     */
    data: XOR<quiz_game_qaCreateInput, quiz_game_qaUncheckedCreateInput>
  }

  /**
   * quiz_game_qa createMany
   */
  export type quiz_game_qaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many quiz_game_qas.
     */
    data: quiz_game_qaCreateManyInput | quiz_game_qaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * quiz_game_qa createManyAndReturn
   */
  export type quiz_game_qaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * The data used to create many quiz_game_qas.
     */
    data: quiz_game_qaCreateManyInput | quiz_game_qaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * quiz_game_qa update
   */
  export type quiz_game_qaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    /**
     * The data needed to update a quiz_game_qa.
     */
    data: XOR<quiz_game_qaUpdateInput, quiz_game_qaUncheckedUpdateInput>
    /**
     * Choose, which quiz_game_qa to update.
     */
    where: quiz_game_qaWhereUniqueInput
  }

  /**
   * quiz_game_qa updateMany
   */
  export type quiz_game_qaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update quiz_game_qas.
     */
    data: XOR<quiz_game_qaUpdateManyMutationInput, quiz_game_qaUncheckedUpdateManyInput>
    /**
     * Filter which quiz_game_qas to update
     */
    where?: quiz_game_qaWhereInput
    /**
     * Limit how many quiz_game_qas to update.
     */
    limit?: number
  }

  /**
   * quiz_game_qa updateManyAndReturn
   */
  export type quiz_game_qaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * The data used to update quiz_game_qas.
     */
    data: XOR<quiz_game_qaUpdateManyMutationInput, quiz_game_qaUncheckedUpdateManyInput>
    /**
     * Filter which quiz_game_qas to update
     */
    where?: quiz_game_qaWhereInput
    /**
     * Limit how many quiz_game_qas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * quiz_game_qa upsert
   */
  export type quiz_game_qaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    /**
     * The filter to search for the quiz_game_qa to update in case it exists.
     */
    where: quiz_game_qaWhereUniqueInput
    /**
     * In case the quiz_game_qa found by the `where` argument doesn't exist, create a new quiz_game_qa with this data.
     */
    create: XOR<quiz_game_qaCreateInput, quiz_game_qaUncheckedCreateInput>
    /**
     * In case the quiz_game_qa was found with the provided `where` argument, update it with this data.
     */
    update: XOR<quiz_game_qaUpdateInput, quiz_game_qaUncheckedUpdateInput>
  }

  /**
   * quiz_game_qa delete
   */
  export type quiz_game_qaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
    /**
     * Filter which quiz_game_qa to delete.
     */
    where: quiz_game_qaWhereUniqueInput
  }

  /**
   * quiz_game_qa deleteMany
   */
  export type quiz_game_qaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which quiz_game_qas to delete
     */
    where?: quiz_game_qaWhereInput
    /**
     * Limit how many quiz_game_qas to delete.
     */
    limit?: number
  }

  /**
   * quiz_game_qa.quiz_game
   */
  export type quiz_game_qa$quiz_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game
     */
    select?: quiz_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game
     */
    omit?: quiz_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_gameInclude<ExtArgs> | null
    where?: quiz_gameWhereInput
  }

  /**
   * quiz_game_qa without action
   */
  export type quiz_game_qaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the quiz_game_qa
     */
    select?: quiz_game_qaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the quiz_game_qa
     */
    omit?: quiz_game_qaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: quiz_game_qaInclude<ExtArgs> | null
  }


  /**
   * Model treasure_connection_cards
   */

  export type AggregateTreasure_connection_cards = {
    _count: Treasure_connection_cardsCountAggregateOutputType | null
    _avg: Treasure_connection_cardsAvgAggregateOutputType | null
    _sum: Treasure_connection_cardsSumAggregateOutputType | null
    _min: Treasure_connection_cardsMinAggregateOutputType | null
    _max: Treasure_connection_cardsMaxAggregateOutputType | null
  }

  export type Treasure_connection_cardsAvgAggregateOutputType = {
    id: number | null
    treasure_game_id: number | null
    pair_id: number | null
    position: number | null
  }

  export type Treasure_connection_cardsSumAggregateOutputType = {
    id: number | null
    treasure_game_id: number | null
    pair_id: number | null
    position: number | null
  }

  export type Treasure_connection_cardsMinAggregateOutputType = {
    id: number | null
    treasure_game_id: number | null
    card_type: $Enums.card_type_enum | null
    card_value: string | null
    image_url: string | null
    pair_id: number | null
    position: number | null
  }

  export type Treasure_connection_cardsMaxAggregateOutputType = {
    id: number | null
    treasure_game_id: number | null
    card_type: $Enums.card_type_enum | null
    card_value: string | null
    image_url: string | null
    pair_id: number | null
    position: number | null
  }

  export type Treasure_connection_cardsCountAggregateOutputType = {
    id: number
    treasure_game_id: number
    card_type: number
    card_value: number
    image_url: number
    pair_id: number
    position: number
    _all: number
  }


  export type Treasure_connection_cardsAvgAggregateInputType = {
    id?: true
    treasure_game_id?: true
    pair_id?: true
    position?: true
  }

  export type Treasure_connection_cardsSumAggregateInputType = {
    id?: true
    treasure_game_id?: true
    pair_id?: true
    position?: true
  }

  export type Treasure_connection_cardsMinAggregateInputType = {
    id?: true
    treasure_game_id?: true
    card_type?: true
    card_value?: true
    image_url?: true
    pair_id?: true
    position?: true
  }

  export type Treasure_connection_cardsMaxAggregateInputType = {
    id?: true
    treasure_game_id?: true
    card_type?: true
    card_value?: true
    image_url?: true
    pair_id?: true
    position?: true
  }

  export type Treasure_connection_cardsCountAggregateInputType = {
    id?: true
    treasure_game_id?: true
    card_type?: true
    card_value?: true
    image_url?: true
    pair_id?: true
    position?: true
    _all?: true
  }

  export type Treasure_connection_cardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which treasure_connection_cards to aggregate.
     */
    where?: treasure_connection_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasure_connection_cards to fetch.
     */
    orderBy?: treasure_connection_cardsOrderByWithRelationInput | treasure_connection_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: treasure_connection_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasure_connection_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasure_connection_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned treasure_connection_cards
    **/
    _count?: true | Treasure_connection_cardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Treasure_connection_cardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Treasure_connection_cardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Treasure_connection_cardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Treasure_connection_cardsMaxAggregateInputType
  }

  export type GetTreasure_connection_cardsAggregateType<T extends Treasure_connection_cardsAggregateArgs> = {
        [P in keyof T & keyof AggregateTreasure_connection_cards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreasure_connection_cards[P]>
      : GetScalarType<T[P], AggregateTreasure_connection_cards[P]>
  }




  export type treasure_connection_cardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: treasure_connection_cardsWhereInput
    orderBy?: treasure_connection_cardsOrderByWithAggregationInput | treasure_connection_cardsOrderByWithAggregationInput[]
    by: Treasure_connection_cardsScalarFieldEnum[] | Treasure_connection_cardsScalarFieldEnum
    having?: treasure_connection_cardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Treasure_connection_cardsCountAggregateInputType | true
    _avg?: Treasure_connection_cardsAvgAggregateInputType
    _sum?: Treasure_connection_cardsSumAggregateInputType
    _min?: Treasure_connection_cardsMinAggregateInputType
    _max?: Treasure_connection_cardsMaxAggregateInputType
  }

  export type Treasure_connection_cardsGroupByOutputType = {
    id: number
    treasure_game_id: number | null
    card_type: $Enums.card_type_enum
    card_value: string | null
    image_url: string | null
    pair_id: number
    position: number | null
    _count: Treasure_connection_cardsCountAggregateOutputType | null
    _avg: Treasure_connection_cardsAvgAggregateOutputType | null
    _sum: Treasure_connection_cardsSumAggregateOutputType | null
    _min: Treasure_connection_cardsMinAggregateOutputType | null
    _max: Treasure_connection_cardsMaxAggregateOutputType | null
  }

  type GetTreasure_connection_cardsGroupByPayload<T extends treasure_connection_cardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Treasure_connection_cardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Treasure_connection_cardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Treasure_connection_cardsGroupByOutputType[P]>
            : GetScalarType<T[P], Treasure_connection_cardsGroupByOutputType[P]>
        }
      >
    >


  export type treasure_connection_cardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    treasure_game_id?: boolean
    card_type?: boolean
    card_value?: boolean
    image_url?: boolean
    pair_id?: boolean
    position?: boolean
    treasure_game?: boolean | treasure_connection_cards$treasure_gameArgs<ExtArgs>
  }, ExtArgs["result"]["treasure_connection_cards"]>

  export type treasure_connection_cardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    treasure_game_id?: boolean
    card_type?: boolean
    card_value?: boolean
    image_url?: boolean
    pair_id?: boolean
    position?: boolean
    treasure_game?: boolean | treasure_connection_cards$treasure_gameArgs<ExtArgs>
  }, ExtArgs["result"]["treasure_connection_cards"]>

  export type treasure_connection_cardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    treasure_game_id?: boolean
    card_type?: boolean
    card_value?: boolean
    image_url?: boolean
    pair_id?: boolean
    position?: boolean
    treasure_game?: boolean | treasure_connection_cards$treasure_gameArgs<ExtArgs>
  }, ExtArgs["result"]["treasure_connection_cards"]>

  export type treasure_connection_cardsSelectScalar = {
    id?: boolean
    treasure_game_id?: boolean
    card_type?: boolean
    card_value?: boolean
    image_url?: boolean
    pair_id?: boolean
    position?: boolean
  }

  export type treasure_connection_cardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "treasure_game_id" | "card_type" | "card_value" | "image_url" | "pair_id" | "position", ExtArgs["result"]["treasure_connection_cards"]>
  export type treasure_connection_cardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    treasure_game?: boolean | treasure_connection_cards$treasure_gameArgs<ExtArgs>
  }
  export type treasure_connection_cardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    treasure_game?: boolean | treasure_connection_cards$treasure_gameArgs<ExtArgs>
  }
  export type treasure_connection_cardsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    treasure_game?: boolean | treasure_connection_cards$treasure_gameArgs<ExtArgs>
  }

  export type $treasure_connection_cardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "treasure_connection_cards"
    objects: {
      treasure_game: Prisma.$treasure_gamePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      treasure_game_id: number | null
      card_type: $Enums.card_type_enum
      card_value: string | null
      image_url: string | null
      pair_id: number
      position: number | null
    }, ExtArgs["result"]["treasure_connection_cards"]>
    composites: {}
  }

  type treasure_connection_cardsGetPayload<S extends boolean | null | undefined | treasure_connection_cardsDefaultArgs> = $Result.GetResult<Prisma.$treasure_connection_cardsPayload, S>

  type treasure_connection_cardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<treasure_connection_cardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Treasure_connection_cardsCountAggregateInputType | true
    }

  export interface treasure_connection_cardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['treasure_connection_cards'], meta: { name: 'treasure_connection_cards' } }
    /**
     * Find zero or one Treasure_connection_cards that matches the filter.
     * @param {treasure_connection_cardsFindUniqueArgs} args - Arguments to find a Treasure_connection_cards
     * @example
     * // Get one Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends treasure_connection_cardsFindUniqueArgs>(args: SelectSubset<T, treasure_connection_cardsFindUniqueArgs<ExtArgs>>): Prisma__treasure_connection_cardsClient<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Treasure_connection_cards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {treasure_connection_cardsFindUniqueOrThrowArgs} args - Arguments to find a Treasure_connection_cards
     * @example
     * // Get one Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends treasure_connection_cardsFindUniqueOrThrowArgs>(args: SelectSubset<T, treasure_connection_cardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__treasure_connection_cardsClient<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Treasure_connection_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_connection_cardsFindFirstArgs} args - Arguments to find a Treasure_connection_cards
     * @example
     * // Get one Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends treasure_connection_cardsFindFirstArgs>(args?: SelectSubset<T, treasure_connection_cardsFindFirstArgs<ExtArgs>>): Prisma__treasure_connection_cardsClient<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Treasure_connection_cards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_connection_cardsFindFirstOrThrowArgs} args - Arguments to find a Treasure_connection_cards
     * @example
     * // Get one Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends treasure_connection_cardsFindFirstOrThrowArgs>(args?: SelectSubset<T, treasure_connection_cardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__treasure_connection_cardsClient<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Treasure_connection_cards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_connection_cardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.findMany()
     * 
     * // Get first 10 Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treasure_connection_cardsWithIdOnly = await prisma.treasure_connection_cards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends treasure_connection_cardsFindManyArgs>(args?: SelectSubset<T, treasure_connection_cardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Treasure_connection_cards.
     * @param {treasure_connection_cardsCreateArgs} args - Arguments to create a Treasure_connection_cards.
     * @example
     * // Create one Treasure_connection_cards
     * const Treasure_connection_cards = await prisma.treasure_connection_cards.create({
     *   data: {
     *     // ... data to create a Treasure_connection_cards
     *   }
     * })
     * 
     */
    create<T extends treasure_connection_cardsCreateArgs>(args: SelectSubset<T, treasure_connection_cardsCreateArgs<ExtArgs>>): Prisma__treasure_connection_cardsClient<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Treasure_connection_cards.
     * @param {treasure_connection_cardsCreateManyArgs} args - Arguments to create many Treasure_connection_cards.
     * @example
     * // Create many Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends treasure_connection_cardsCreateManyArgs>(args?: SelectSubset<T, treasure_connection_cardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Treasure_connection_cards and returns the data saved in the database.
     * @param {treasure_connection_cardsCreateManyAndReturnArgs} args - Arguments to create many Treasure_connection_cards.
     * @example
     * // Create many Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Treasure_connection_cards and only return the `id`
     * const treasure_connection_cardsWithIdOnly = await prisma.treasure_connection_cards.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends treasure_connection_cardsCreateManyAndReturnArgs>(args?: SelectSubset<T, treasure_connection_cardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Treasure_connection_cards.
     * @param {treasure_connection_cardsDeleteArgs} args - Arguments to delete one Treasure_connection_cards.
     * @example
     * // Delete one Treasure_connection_cards
     * const Treasure_connection_cards = await prisma.treasure_connection_cards.delete({
     *   where: {
     *     // ... filter to delete one Treasure_connection_cards
     *   }
     * })
     * 
     */
    delete<T extends treasure_connection_cardsDeleteArgs>(args: SelectSubset<T, treasure_connection_cardsDeleteArgs<ExtArgs>>): Prisma__treasure_connection_cardsClient<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Treasure_connection_cards.
     * @param {treasure_connection_cardsUpdateArgs} args - Arguments to update one Treasure_connection_cards.
     * @example
     * // Update one Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends treasure_connection_cardsUpdateArgs>(args: SelectSubset<T, treasure_connection_cardsUpdateArgs<ExtArgs>>): Prisma__treasure_connection_cardsClient<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Treasure_connection_cards.
     * @param {treasure_connection_cardsDeleteManyArgs} args - Arguments to filter Treasure_connection_cards to delete.
     * @example
     * // Delete a few Treasure_connection_cards
     * const { count } = await prisma.treasure_connection_cards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends treasure_connection_cardsDeleteManyArgs>(args?: SelectSubset<T, treasure_connection_cardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treasure_connection_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_connection_cardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends treasure_connection_cardsUpdateManyArgs>(args: SelectSubset<T, treasure_connection_cardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treasure_connection_cards and returns the data updated in the database.
     * @param {treasure_connection_cardsUpdateManyAndReturnArgs} args - Arguments to update many Treasure_connection_cards.
     * @example
     * // Update many Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Treasure_connection_cards and only return the `id`
     * const treasure_connection_cardsWithIdOnly = await prisma.treasure_connection_cards.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends treasure_connection_cardsUpdateManyAndReturnArgs>(args: SelectSubset<T, treasure_connection_cardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Treasure_connection_cards.
     * @param {treasure_connection_cardsUpsertArgs} args - Arguments to update or create a Treasure_connection_cards.
     * @example
     * // Update or create a Treasure_connection_cards
     * const treasure_connection_cards = await prisma.treasure_connection_cards.upsert({
     *   create: {
     *     // ... data to create a Treasure_connection_cards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Treasure_connection_cards we want to update
     *   }
     * })
     */
    upsert<T extends treasure_connection_cardsUpsertArgs>(args: SelectSubset<T, treasure_connection_cardsUpsertArgs<ExtArgs>>): Prisma__treasure_connection_cardsClient<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Treasure_connection_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_connection_cardsCountArgs} args - Arguments to filter Treasure_connection_cards to count.
     * @example
     * // Count the number of Treasure_connection_cards
     * const count = await prisma.treasure_connection_cards.count({
     *   where: {
     *     // ... the filter for the Treasure_connection_cards we want to count
     *   }
     * })
    **/
    count<T extends treasure_connection_cardsCountArgs>(
      args?: Subset<T, treasure_connection_cardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Treasure_connection_cardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Treasure_connection_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Treasure_connection_cardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Treasure_connection_cardsAggregateArgs>(args: Subset<T, Treasure_connection_cardsAggregateArgs>): Prisma.PrismaPromise<GetTreasure_connection_cardsAggregateType<T>>

    /**
     * Group by Treasure_connection_cards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_connection_cardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends treasure_connection_cardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: treasure_connection_cardsGroupByArgs['orderBy'] }
        : { orderBy?: treasure_connection_cardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, treasure_connection_cardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreasure_connection_cardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the treasure_connection_cards model
   */
  readonly fields: treasure_connection_cardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for treasure_connection_cards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__treasure_connection_cardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    treasure_game<T extends treasure_connection_cards$treasure_gameArgs<ExtArgs> = {}>(args?: Subset<T, treasure_connection_cards$treasure_gameArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the treasure_connection_cards model
   */
  interface treasure_connection_cardsFieldRefs {
    readonly id: FieldRef<"treasure_connection_cards", 'Int'>
    readonly treasure_game_id: FieldRef<"treasure_connection_cards", 'Int'>
    readonly card_type: FieldRef<"treasure_connection_cards", 'card_type_enum'>
    readonly card_value: FieldRef<"treasure_connection_cards", 'String'>
    readonly image_url: FieldRef<"treasure_connection_cards", 'String'>
    readonly pair_id: FieldRef<"treasure_connection_cards", 'Int'>
    readonly position: FieldRef<"treasure_connection_cards", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * treasure_connection_cards findUnique
   */
  export type treasure_connection_cardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    /**
     * Filter, which treasure_connection_cards to fetch.
     */
    where: treasure_connection_cardsWhereUniqueInput
  }

  /**
   * treasure_connection_cards findUniqueOrThrow
   */
  export type treasure_connection_cardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    /**
     * Filter, which treasure_connection_cards to fetch.
     */
    where: treasure_connection_cardsWhereUniqueInput
  }

  /**
   * treasure_connection_cards findFirst
   */
  export type treasure_connection_cardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    /**
     * Filter, which treasure_connection_cards to fetch.
     */
    where?: treasure_connection_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasure_connection_cards to fetch.
     */
    orderBy?: treasure_connection_cardsOrderByWithRelationInput | treasure_connection_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for treasure_connection_cards.
     */
    cursor?: treasure_connection_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasure_connection_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasure_connection_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of treasure_connection_cards.
     */
    distinct?: Treasure_connection_cardsScalarFieldEnum | Treasure_connection_cardsScalarFieldEnum[]
  }

  /**
   * treasure_connection_cards findFirstOrThrow
   */
  export type treasure_connection_cardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    /**
     * Filter, which treasure_connection_cards to fetch.
     */
    where?: treasure_connection_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasure_connection_cards to fetch.
     */
    orderBy?: treasure_connection_cardsOrderByWithRelationInput | treasure_connection_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for treasure_connection_cards.
     */
    cursor?: treasure_connection_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasure_connection_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasure_connection_cards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of treasure_connection_cards.
     */
    distinct?: Treasure_connection_cardsScalarFieldEnum | Treasure_connection_cardsScalarFieldEnum[]
  }

  /**
   * treasure_connection_cards findMany
   */
  export type treasure_connection_cardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    /**
     * Filter, which treasure_connection_cards to fetch.
     */
    where?: treasure_connection_cardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasure_connection_cards to fetch.
     */
    orderBy?: treasure_connection_cardsOrderByWithRelationInput | treasure_connection_cardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing treasure_connection_cards.
     */
    cursor?: treasure_connection_cardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasure_connection_cards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasure_connection_cards.
     */
    skip?: number
    distinct?: Treasure_connection_cardsScalarFieldEnum | Treasure_connection_cardsScalarFieldEnum[]
  }

  /**
   * treasure_connection_cards create
   */
  export type treasure_connection_cardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    /**
     * The data needed to create a treasure_connection_cards.
     */
    data: XOR<treasure_connection_cardsCreateInput, treasure_connection_cardsUncheckedCreateInput>
  }

  /**
   * treasure_connection_cards createMany
   */
  export type treasure_connection_cardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many treasure_connection_cards.
     */
    data: treasure_connection_cardsCreateManyInput | treasure_connection_cardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * treasure_connection_cards createManyAndReturn
   */
  export type treasure_connection_cardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * The data used to create many treasure_connection_cards.
     */
    data: treasure_connection_cardsCreateManyInput | treasure_connection_cardsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * treasure_connection_cards update
   */
  export type treasure_connection_cardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    /**
     * The data needed to update a treasure_connection_cards.
     */
    data: XOR<treasure_connection_cardsUpdateInput, treasure_connection_cardsUncheckedUpdateInput>
    /**
     * Choose, which treasure_connection_cards to update.
     */
    where: treasure_connection_cardsWhereUniqueInput
  }

  /**
   * treasure_connection_cards updateMany
   */
  export type treasure_connection_cardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update treasure_connection_cards.
     */
    data: XOR<treasure_connection_cardsUpdateManyMutationInput, treasure_connection_cardsUncheckedUpdateManyInput>
    /**
     * Filter which treasure_connection_cards to update
     */
    where?: treasure_connection_cardsWhereInput
    /**
     * Limit how many treasure_connection_cards to update.
     */
    limit?: number
  }

  /**
   * treasure_connection_cards updateManyAndReturn
   */
  export type treasure_connection_cardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * The data used to update treasure_connection_cards.
     */
    data: XOR<treasure_connection_cardsUpdateManyMutationInput, treasure_connection_cardsUncheckedUpdateManyInput>
    /**
     * Filter which treasure_connection_cards to update
     */
    where?: treasure_connection_cardsWhereInput
    /**
     * Limit how many treasure_connection_cards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * treasure_connection_cards upsert
   */
  export type treasure_connection_cardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    /**
     * The filter to search for the treasure_connection_cards to update in case it exists.
     */
    where: treasure_connection_cardsWhereUniqueInput
    /**
     * In case the treasure_connection_cards found by the `where` argument doesn't exist, create a new treasure_connection_cards with this data.
     */
    create: XOR<treasure_connection_cardsCreateInput, treasure_connection_cardsUncheckedCreateInput>
    /**
     * In case the treasure_connection_cards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<treasure_connection_cardsUpdateInput, treasure_connection_cardsUncheckedUpdateInput>
  }

  /**
   * treasure_connection_cards delete
   */
  export type treasure_connection_cardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    /**
     * Filter which treasure_connection_cards to delete.
     */
    where: treasure_connection_cardsWhereUniqueInput
  }

  /**
   * treasure_connection_cards deleteMany
   */
  export type treasure_connection_cardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which treasure_connection_cards to delete
     */
    where?: treasure_connection_cardsWhereInput
    /**
     * Limit how many treasure_connection_cards to delete.
     */
    limit?: number
  }

  /**
   * treasure_connection_cards.treasure_game
   */
  export type treasure_connection_cards$treasure_gameArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    where?: treasure_gameWhereInput
  }

  /**
   * treasure_connection_cards without action
   */
  export type treasure_connection_cardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
  }


  /**
   * Model treasure_game
   */

  export type AggregateTreasure_game = {
    _count: Treasure_gameCountAggregateOutputType | null
    _avg: Treasure_gameAvgAggregateOutputType | null
    _sum: Treasure_gameSumAggregateOutputType | null
    _min: Treasure_gameMinAggregateOutputType | null
    _max: Treasure_gameMaxAggregateOutputType | null
  }

  export type Treasure_gameAvgAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
  }

  export type Treasure_gameSumAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
  }

  export type Treasure_gameMinAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
    title: string | null
    description: string | null
  }

  export type Treasure_gameMaxAggregateOutputType = {
    id: number | null
    regionid: number | null
    gametype: number | null
    title: string | null
    description: string | null
  }

  export type Treasure_gameCountAggregateOutputType = {
    id: number
    regionid: number
    gametype: number
    title: number
    description: number
    _all: number
  }


  export type Treasure_gameAvgAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
  }

  export type Treasure_gameSumAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
  }

  export type Treasure_gameMinAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
    title?: true
    description?: true
  }

  export type Treasure_gameMaxAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
    title?: true
    description?: true
  }

  export type Treasure_gameCountAggregateInputType = {
    id?: true
    regionid?: true
    gametype?: true
    title?: true
    description?: true
    _all?: true
  }

  export type Treasure_gameAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which treasure_game to aggregate.
     */
    where?: treasure_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasure_games to fetch.
     */
    orderBy?: treasure_gameOrderByWithRelationInput | treasure_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: treasure_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasure_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasure_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned treasure_games
    **/
    _count?: true | Treasure_gameCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Treasure_gameAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Treasure_gameSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Treasure_gameMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Treasure_gameMaxAggregateInputType
  }

  export type GetTreasure_gameAggregateType<T extends Treasure_gameAggregateArgs> = {
        [P in keyof T & keyof AggregateTreasure_game]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreasure_game[P]>
      : GetScalarType<T[P], AggregateTreasure_game[P]>
  }




  export type treasure_gameGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: treasure_gameWhereInput
    orderBy?: treasure_gameOrderByWithAggregationInput | treasure_gameOrderByWithAggregationInput[]
    by: Treasure_gameScalarFieldEnum[] | Treasure_gameScalarFieldEnum
    having?: treasure_gameScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Treasure_gameCountAggregateInputType | true
    _avg?: Treasure_gameAvgAggregateInputType
    _sum?: Treasure_gameSumAggregateInputType
    _min?: Treasure_gameMinAggregateInputType
    _max?: Treasure_gameMaxAggregateInputType
  }

  export type Treasure_gameGroupByOutputType = {
    id: number
    regionid: number | null
    gametype: number | null
    title: string | null
    description: string | null
    _count: Treasure_gameCountAggregateOutputType | null
    _avg: Treasure_gameAvgAggregateOutputType | null
    _sum: Treasure_gameSumAggregateOutputType | null
    _min: Treasure_gameMinAggregateOutputType | null
    _max: Treasure_gameMaxAggregateOutputType | null
  }

  type GetTreasure_gameGroupByPayload<T extends treasure_gameGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Treasure_gameGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Treasure_gameGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Treasure_gameGroupByOutputType[P]>
            : GetScalarType<T[P], Treasure_gameGroupByOutputType[P]>
        }
      >
    >


  export type treasure_gameSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    title?: boolean
    description?: boolean
    AfterQuestionInformation?: boolean | treasure_game$AfterQuestionInformationArgs<ExtArgs>
    treasure_connection_cards?: boolean | treasure_game$treasure_connection_cardsArgs<ExtArgs>
    game_type?: boolean | treasure_game$game_typeArgs<ExtArgs>
    Region?: boolean | treasure_game$RegionArgs<ExtArgs>
    _count?: boolean | Treasure_gameCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["treasure_game"]>

  export type treasure_gameSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    title?: boolean
    description?: boolean
    game_type?: boolean | treasure_game$game_typeArgs<ExtArgs>
    Region?: boolean | treasure_game$RegionArgs<ExtArgs>
  }, ExtArgs["result"]["treasure_game"]>

  export type treasure_gameSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    title?: boolean
    description?: boolean
    game_type?: boolean | treasure_game$game_typeArgs<ExtArgs>
    Region?: boolean | treasure_game$RegionArgs<ExtArgs>
  }, ExtArgs["result"]["treasure_game"]>

  export type treasure_gameSelectScalar = {
    id?: boolean
    regionid?: boolean
    gametype?: boolean
    title?: boolean
    description?: boolean
  }

  export type treasure_gameOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "regionid" | "gametype" | "title" | "description", ExtArgs["result"]["treasure_game"]>
  export type treasure_gameInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AfterQuestionInformation?: boolean | treasure_game$AfterQuestionInformationArgs<ExtArgs>
    treasure_connection_cards?: boolean | treasure_game$treasure_connection_cardsArgs<ExtArgs>
    game_type?: boolean | treasure_game$game_typeArgs<ExtArgs>
    Region?: boolean | treasure_game$RegionArgs<ExtArgs>
    _count?: boolean | Treasure_gameCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type treasure_gameIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game_type?: boolean | treasure_game$game_typeArgs<ExtArgs>
    Region?: boolean | treasure_game$RegionArgs<ExtArgs>
  }
  export type treasure_gameIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    game_type?: boolean | treasure_game$game_typeArgs<ExtArgs>
    Region?: boolean | treasure_game$RegionArgs<ExtArgs>
  }

  export type $treasure_gamePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "treasure_game"
    objects: {
      AfterQuestionInformation: Prisma.$AfterQuestionInformationPayload<ExtArgs>[]
      treasure_connection_cards: Prisma.$treasure_connection_cardsPayload<ExtArgs>[]
      game_type: Prisma.$game_typePayload<ExtArgs> | null
      Region: Prisma.$RegionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      regionid: number | null
      gametype: number | null
      title: string | null
      description: string | null
    }, ExtArgs["result"]["treasure_game"]>
    composites: {}
  }

  type treasure_gameGetPayload<S extends boolean | null | undefined | treasure_gameDefaultArgs> = $Result.GetResult<Prisma.$treasure_gamePayload, S>

  type treasure_gameCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<treasure_gameFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Treasure_gameCountAggregateInputType | true
    }

  export interface treasure_gameDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['treasure_game'], meta: { name: 'treasure_game' } }
    /**
     * Find zero or one Treasure_game that matches the filter.
     * @param {treasure_gameFindUniqueArgs} args - Arguments to find a Treasure_game
     * @example
     * // Get one Treasure_game
     * const treasure_game = await prisma.treasure_game.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends treasure_gameFindUniqueArgs>(args: SelectSubset<T, treasure_gameFindUniqueArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Treasure_game that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {treasure_gameFindUniqueOrThrowArgs} args - Arguments to find a Treasure_game
     * @example
     * // Get one Treasure_game
     * const treasure_game = await prisma.treasure_game.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends treasure_gameFindUniqueOrThrowArgs>(args: SelectSubset<T, treasure_gameFindUniqueOrThrowArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Treasure_game that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_gameFindFirstArgs} args - Arguments to find a Treasure_game
     * @example
     * // Get one Treasure_game
     * const treasure_game = await prisma.treasure_game.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends treasure_gameFindFirstArgs>(args?: SelectSubset<T, treasure_gameFindFirstArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Treasure_game that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_gameFindFirstOrThrowArgs} args - Arguments to find a Treasure_game
     * @example
     * // Get one Treasure_game
     * const treasure_game = await prisma.treasure_game.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends treasure_gameFindFirstOrThrowArgs>(args?: SelectSubset<T, treasure_gameFindFirstOrThrowArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Treasure_games that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_gameFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Treasure_games
     * const treasure_games = await prisma.treasure_game.findMany()
     * 
     * // Get first 10 Treasure_games
     * const treasure_games = await prisma.treasure_game.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treasure_gameWithIdOnly = await prisma.treasure_game.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends treasure_gameFindManyArgs>(args?: SelectSubset<T, treasure_gameFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Treasure_game.
     * @param {treasure_gameCreateArgs} args - Arguments to create a Treasure_game.
     * @example
     * // Create one Treasure_game
     * const Treasure_game = await prisma.treasure_game.create({
     *   data: {
     *     // ... data to create a Treasure_game
     *   }
     * })
     * 
     */
    create<T extends treasure_gameCreateArgs>(args: SelectSubset<T, treasure_gameCreateArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Treasure_games.
     * @param {treasure_gameCreateManyArgs} args - Arguments to create many Treasure_games.
     * @example
     * // Create many Treasure_games
     * const treasure_game = await prisma.treasure_game.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends treasure_gameCreateManyArgs>(args?: SelectSubset<T, treasure_gameCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Treasure_games and returns the data saved in the database.
     * @param {treasure_gameCreateManyAndReturnArgs} args - Arguments to create many Treasure_games.
     * @example
     * // Create many Treasure_games
     * const treasure_game = await prisma.treasure_game.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Treasure_games and only return the `id`
     * const treasure_gameWithIdOnly = await prisma.treasure_game.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends treasure_gameCreateManyAndReturnArgs>(args?: SelectSubset<T, treasure_gameCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Treasure_game.
     * @param {treasure_gameDeleteArgs} args - Arguments to delete one Treasure_game.
     * @example
     * // Delete one Treasure_game
     * const Treasure_game = await prisma.treasure_game.delete({
     *   where: {
     *     // ... filter to delete one Treasure_game
     *   }
     * })
     * 
     */
    delete<T extends treasure_gameDeleteArgs>(args: SelectSubset<T, treasure_gameDeleteArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Treasure_game.
     * @param {treasure_gameUpdateArgs} args - Arguments to update one Treasure_game.
     * @example
     * // Update one Treasure_game
     * const treasure_game = await prisma.treasure_game.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends treasure_gameUpdateArgs>(args: SelectSubset<T, treasure_gameUpdateArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Treasure_games.
     * @param {treasure_gameDeleteManyArgs} args - Arguments to filter Treasure_games to delete.
     * @example
     * // Delete a few Treasure_games
     * const { count } = await prisma.treasure_game.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends treasure_gameDeleteManyArgs>(args?: SelectSubset<T, treasure_gameDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treasure_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_gameUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Treasure_games
     * const treasure_game = await prisma.treasure_game.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends treasure_gameUpdateManyArgs>(args: SelectSubset<T, treasure_gameUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Treasure_games and returns the data updated in the database.
     * @param {treasure_gameUpdateManyAndReturnArgs} args - Arguments to update many Treasure_games.
     * @example
     * // Update many Treasure_games
     * const treasure_game = await prisma.treasure_game.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Treasure_games and only return the `id`
     * const treasure_gameWithIdOnly = await prisma.treasure_game.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends treasure_gameUpdateManyAndReturnArgs>(args: SelectSubset<T, treasure_gameUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Treasure_game.
     * @param {treasure_gameUpsertArgs} args - Arguments to update or create a Treasure_game.
     * @example
     * // Update or create a Treasure_game
     * const treasure_game = await prisma.treasure_game.upsert({
     *   create: {
     *     // ... data to create a Treasure_game
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Treasure_game we want to update
     *   }
     * })
     */
    upsert<T extends treasure_gameUpsertArgs>(args: SelectSubset<T, treasure_gameUpsertArgs<ExtArgs>>): Prisma__treasure_gameClient<$Result.GetResult<Prisma.$treasure_gamePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Treasure_games.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_gameCountArgs} args - Arguments to filter Treasure_games to count.
     * @example
     * // Count the number of Treasure_games
     * const count = await prisma.treasure_game.count({
     *   where: {
     *     // ... the filter for the Treasure_games we want to count
     *   }
     * })
    **/
    count<T extends treasure_gameCountArgs>(
      args?: Subset<T, treasure_gameCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Treasure_gameCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Treasure_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Treasure_gameAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Treasure_gameAggregateArgs>(args: Subset<T, Treasure_gameAggregateArgs>): Prisma.PrismaPromise<GetTreasure_gameAggregateType<T>>

    /**
     * Group by Treasure_game.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {treasure_gameGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends treasure_gameGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: treasure_gameGroupByArgs['orderBy'] }
        : { orderBy?: treasure_gameGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, treasure_gameGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreasure_gameGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the treasure_game model
   */
  readonly fields: treasure_gameFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for treasure_game.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__treasure_gameClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AfterQuestionInformation<T extends treasure_game$AfterQuestionInformationArgs<ExtArgs> = {}>(args?: Subset<T, treasure_game$AfterQuestionInformationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AfterQuestionInformationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    treasure_connection_cards<T extends treasure_game$treasure_connection_cardsArgs<ExtArgs> = {}>(args?: Subset<T, treasure_game$treasure_connection_cardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$treasure_connection_cardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    game_type<T extends treasure_game$game_typeArgs<ExtArgs> = {}>(args?: Subset<T, treasure_game$game_typeArgs<ExtArgs>>): Prisma__game_typeClient<$Result.GetResult<Prisma.$game_typePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Region<T extends treasure_game$RegionArgs<ExtArgs> = {}>(args?: Subset<T, treasure_game$RegionArgs<ExtArgs>>): Prisma__RegionClient<$Result.GetResult<Prisma.$RegionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the treasure_game model
   */
  interface treasure_gameFieldRefs {
    readonly id: FieldRef<"treasure_game", 'Int'>
    readonly regionid: FieldRef<"treasure_game", 'Int'>
    readonly gametype: FieldRef<"treasure_game", 'Int'>
    readonly title: FieldRef<"treasure_game", 'String'>
    readonly description: FieldRef<"treasure_game", 'String'>
  }
    

  // Custom InputTypes
  /**
   * treasure_game findUnique
   */
  export type treasure_gameFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    /**
     * Filter, which treasure_game to fetch.
     */
    where: treasure_gameWhereUniqueInput
  }

  /**
   * treasure_game findUniqueOrThrow
   */
  export type treasure_gameFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    /**
     * Filter, which treasure_game to fetch.
     */
    where: treasure_gameWhereUniqueInput
  }

  /**
   * treasure_game findFirst
   */
  export type treasure_gameFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    /**
     * Filter, which treasure_game to fetch.
     */
    where?: treasure_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasure_games to fetch.
     */
    orderBy?: treasure_gameOrderByWithRelationInput | treasure_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for treasure_games.
     */
    cursor?: treasure_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasure_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasure_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of treasure_games.
     */
    distinct?: Treasure_gameScalarFieldEnum | Treasure_gameScalarFieldEnum[]
  }

  /**
   * treasure_game findFirstOrThrow
   */
  export type treasure_gameFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    /**
     * Filter, which treasure_game to fetch.
     */
    where?: treasure_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasure_games to fetch.
     */
    orderBy?: treasure_gameOrderByWithRelationInput | treasure_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for treasure_games.
     */
    cursor?: treasure_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasure_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasure_games.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of treasure_games.
     */
    distinct?: Treasure_gameScalarFieldEnum | Treasure_gameScalarFieldEnum[]
  }

  /**
   * treasure_game findMany
   */
  export type treasure_gameFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    /**
     * Filter, which treasure_games to fetch.
     */
    where?: treasure_gameWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of treasure_games to fetch.
     */
    orderBy?: treasure_gameOrderByWithRelationInput | treasure_gameOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing treasure_games.
     */
    cursor?: treasure_gameWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` treasure_games from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` treasure_games.
     */
    skip?: number
    distinct?: Treasure_gameScalarFieldEnum | Treasure_gameScalarFieldEnum[]
  }

  /**
   * treasure_game create
   */
  export type treasure_gameCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    /**
     * The data needed to create a treasure_game.
     */
    data?: XOR<treasure_gameCreateInput, treasure_gameUncheckedCreateInput>
  }

  /**
   * treasure_game createMany
   */
  export type treasure_gameCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many treasure_games.
     */
    data: treasure_gameCreateManyInput | treasure_gameCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * treasure_game createManyAndReturn
   */
  export type treasure_gameCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * The data used to create many treasure_games.
     */
    data: treasure_gameCreateManyInput | treasure_gameCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * treasure_game update
   */
  export type treasure_gameUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    /**
     * The data needed to update a treasure_game.
     */
    data: XOR<treasure_gameUpdateInput, treasure_gameUncheckedUpdateInput>
    /**
     * Choose, which treasure_game to update.
     */
    where: treasure_gameWhereUniqueInput
  }

  /**
   * treasure_game updateMany
   */
  export type treasure_gameUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update treasure_games.
     */
    data: XOR<treasure_gameUpdateManyMutationInput, treasure_gameUncheckedUpdateManyInput>
    /**
     * Filter which treasure_games to update
     */
    where?: treasure_gameWhereInput
    /**
     * Limit how many treasure_games to update.
     */
    limit?: number
  }

  /**
   * treasure_game updateManyAndReturn
   */
  export type treasure_gameUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * The data used to update treasure_games.
     */
    data: XOR<treasure_gameUpdateManyMutationInput, treasure_gameUncheckedUpdateManyInput>
    /**
     * Filter which treasure_games to update
     */
    where?: treasure_gameWhereInput
    /**
     * Limit how many treasure_games to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * treasure_game upsert
   */
  export type treasure_gameUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    /**
     * The filter to search for the treasure_game to update in case it exists.
     */
    where: treasure_gameWhereUniqueInput
    /**
     * In case the treasure_game found by the `where` argument doesn't exist, create a new treasure_game with this data.
     */
    create: XOR<treasure_gameCreateInput, treasure_gameUncheckedCreateInput>
    /**
     * In case the treasure_game was found with the provided `where` argument, update it with this data.
     */
    update: XOR<treasure_gameUpdateInput, treasure_gameUncheckedUpdateInput>
  }

  /**
   * treasure_game delete
   */
  export type treasure_gameDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
    /**
     * Filter which treasure_game to delete.
     */
    where: treasure_gameWhereUniqueInput
  }

  /**
   * treasure_game deleteMany
   */
  export type treasure_gameDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which treasure_games to delete
     */
    where?: treasure_gameWhereInput
    /**
     * Limit how many treasure_games to delete.
     */
    limit?: number
  }

  /**
   * treasure_game.AfterQuestionInformation
   */
  export type treasure_game$AfterQuestionInformationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AfterQuestionInformation
     */
    select?: AfterQuestionInformationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AfterQuestionInformation
     */
    omit?: AfterQuestionInformationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AfterQuestionInformationInclude<ExtArgs> | null
    where?: AfterQuestionInformationWhereInput
    orderBy?: AfterQuestionInformationOrderByWithRelationInput | AfterQuestionInformationOrderByWithRelationInput[]
    cursor?: AfterQuestionInformationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AfterQuestionInformationScalarFieldEnum | AfterQuestionInformationScalarFieldEnum[]
  }

  /**
   * treasure_game.treasure_connection_cards
   */
  export type treasure_game$treasure_connection_cardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_connection_cards
     */
    select?: treasure_connection_cardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_connection_cards
     */
    omit?: treasure_connection_cardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_connection_cardsInclude<ExtArgs> | null
    where?: treasure_connection_cardsWhereInput
    orderBy?: treasure_connection_cardsOrderByWithRelationInput | treasure_connection_cardsOrderByWithRelationInput[]
    cursor?: treasure_connection_cardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Treasure_connection_cardsScalarFieldEnum | Treasure_connection_cardsScalarFieldEnum[]
  }

  /**
   * treasure_game.game_type
   */
  export type treasure_game$game_typeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the game_type
     */
    select?: game_typeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the game_type
     */
    omit?: game_typeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: game_typeInclude<ExtArgs> | null
    where?: game_typeWhereInput
  }

  /**
   * treasure_game.Region
   */
  export type treasure_game$RegionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Region
     */
    select?: RegionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Region
     */
    omit?: RegionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionInclude<ExtArgs> | null
    where?: RegionWhereInput
  }

  /**
   * treasure_game without action
   */
  export type treasure_gameDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the treasure_game
     */
    select?: treasure_gameSelect<ExtArgs> | null
    /**
     * Omit specific fields from the treasure_game
     */
    omit?: treasure_gameOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: treasure_gameInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    stars: 'stars'
  };

  export type AchievementScalarFieldEnum = (typeof AchievementScalarFieldEnum)[keyof typeof AchievementScalarFieldEnum]


  export const AfterQuestionInformationScalarFieldEnum: {
    id: 'id',
    gameId: 'gameId',
    questionNumber: 'questionNumber',
    images: 'images',
    texts: 'texts'
  };

  export type AfterQuestionInformationScalarFieldEnum = (typeof AfterQuestionInformationScalarFieldEnum)[keyof typeof AfterQuestionInformationScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    content: 'content',
    likes: 'likes',
    dislikes: 'dislikes',
    parentId: 'parentId'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const EmailVerificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    otp: 'otp',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type EmailVerificationScalarFieldEnum = (typeof EmailVerificationScalarFieldEnum)[keyof typeof EmailVerificationScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    question: 'question',
    media: 'media'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    hashedToken: 'hashedToken',
    userId: 'userId',
    revoked: 'revoked',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    expireAt: 'expireAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const RegionScalarFieldEnum: {
    id: 'id',
    regionName: 'regionName',
    regionCode: 'regionCode',
    mediaUrl: 'mediaUrl',
    description: 'description'
  };

  export type RegionScalarFieldEnum = (typeof RegionScalarFieldEnum)[keyof typeof RegionScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    username: 'username',
    email: 'email',
    password: 'password',
    avatarUrl: 'avatarUrl',
    dateOfBirth: 'dateOfBirth',
    location: 'location',
    gender: 'gender',
    isVerified: 'isVerified'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const Comment_reactionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    comment_id: 'comment_id',
    reaction_type: 'reaction_type',
    created_at: 'created_at'
  };

  export type Comment_reactionScalarFieldEnum = (typeof Comment_reactionScalarFieldEnum)[keyof typeof Comment_reactionScalarFieldEnum]


  export const Game_typeScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name'
  };

  export type Game_typeScalarFieldEnum = (typeof Game_typeScalarFieldEnum)[keyof typeof Game_typeScalarFieldEnum]


  export const Password_resetsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt'
  };

  export type Password_resetsScalarFieldEnum = (typeof Password_resetsScalarFieldEnum)[keyof typeof Password_resetsScalarFieldEnum]


  export const Puzzle_gameScalarFieldEnum: {
    id: 'id',
    regionid: 'regionid',
    gametype: 'gametype',
    imageurl: 'imageurl'
  };

  export type Puzzle_gameScalarFieldEnum = (typeof Puzzle_gameScalarFieldEnum)[keyof typeof Puzzle_gameScalarFieldEnum]


  export const Puzzle_piecesScalarFieldEnum: {
    id: 'id',
    puzzleid: 'puzzleid',
    piece_index: 'piece_index',
    x_position: 'x_position',
    y_position: 'y_position',
    correct_x: 'correct_x',
    correct_y: 'correct_y',
    image_piece_url: 'image_piece_url'
  };

  export type Puzzle_piecesScalarFieldEnum = (typeof Puzzle_piecesScalarFieldEnum)[keyof typeof Puzzle_piecesScalarFieldEnum]


  export const Quiz_gameScalarFieldEnum: {
    id: 'id',
    regionid: 'regionid',
    gametype: 'gametype',
    title: 'title',
    description: 'description'
  };

  export type Quiz_gameScalarFieldEnum = (typeof Quiz_gameScalarFieldEnum)[keyof typeof Quiz_gameScalarFieldEnum]


  export const Quiz_game_qaScalarFieldEnum: {
    id: 'id',
    quiz_game_id: 'quiz_game_id',
    question: 'question',
    wrong_answers: 'wrong_answers',
    correct_answer: 'correct_answer'
  };

  export type Quiz_game_qaScalarFieldEnum = (typeof Quiz_game_qaScalarFieldEnum)[keyof typeof Quiz_game_qaScalarFieldEnum]


  export const Treasure_connection_cardsScalarFieldEnum: {
    id: 'id',
    treasure_game_id: 'treasure_game_id',
    card_type: 'card_type',
    card_value: 'card_value',
    image_url: 'image_url',
    pair_id: 'pair_id',
    position: 'position'
  };

  export type Treasure_connection_cardsScalarFieldEnum = (typeof Treasure_connection_cardsScalarFieldEnum)[keyof typeof Treasure_connection_cardsScalarFieldEnum]


  export const Treasure_gameScalarFieldEnum: {
    id: 'id',
    regionid: 'regionid',
    gametype: 'gametype',
    title: 'title',
    description: 'description'
  };

  export type Treasure_gameScalarFieldEnum = (typeof Treasure_gameScalarFieldEnum)[keyof typeof Treasure_gameScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'reaction_type_enum'
   */
  export type Enumreaction_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'reaction_type_enum'>
    


  /**
   * Reference to a field of type 'reaction_type_enum[]'
   */
  export type ListEnumreaction_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'reaction_type_enum[]'>
    


  /**
   * Reference to a field of type 'game_code_enum'
   */
  export type Enumgame_code_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'game_code_enum'>
    


  /**
   * Reference to a field of type 'game_code_enum[]'
   */
  export type ListEnumgame_code_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'game_code_enum[]'>
    


  /**
   * Reference to a field of type 'card_type_enum'
   */
  export type Enumcard_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'card_type_enum'>
    


  /**
   * Reference to a field of type 'card_type_enum[]'
   */
  export type ListEnumcard_type_enumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'card_type_enum[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AchievementWhereInput = {
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    id?: IntFilter<"Achievement"> | number
    userId?: IntFilter<"Achievement"> | number
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    stars?: IntFilter<"Achievement"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    stars?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type AchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AchievementWhereInput | AchievementWhereInput[]
    OR?: AchievementWhereInput[]
    NOT?: AchievementWhereInput | AchievementWhereInput[]
    userId?: IntFilter<"Achievement"> | number
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    stars?: IntFilter<"Achievement"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    stars?: SortOrder
    _count?: AchievementCountOrderByAggregateInput
    _avg?: AchievementAvgOrderByAggregateInput
    _max?: AchievementMaxOrderByAggregateInput
    _min?: AchievementMinOrderByAggregateInput
    _sum?: AchievementSumOrderByAggregateInput
  }

  export type AchievementScalarWhereWithAggregatesInput = {
    AND?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    OR?: AchievementScalarWhereWithAggregatesInput[]
    NOT?: AchievementScalarWhereWithAggregatesInput | AchievementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Achievement"> | number
    userId?: IntWithAggregatesFilter<"Achievement"> | number
    name?: StringWithAggregatesFilter<"Achievement"> | string
    description?: StringWithAggregatesFilter<"Achievement"> | string
    stars?: IntWithAggregatesFilter<"Achievement"> | number
  }

  export type AfterQuestionInformationWhereInput = {
    AND?: AfterQuestionInformationWhereInput | AfterQuestionInformationWhereInput[]
    OR?: AfterQuestionInformationWhereInput[]
    NOT?: AfterQuestionInformationWhereInput | AfterQuestionInformationWhereInput[]
    id?: IntFilter<"AfterQuestionInformation"> | number
    gameId?: IntFilter<"AfterQuestionInformation"> | number
    questionNumber?: IntFilter<"AfterQuestionInformation"> | number
    images?: JsonFilter<"AfterQuestionInformation">
    texts?: JsonFilter<"AfterQuestionInformation">
    puzzle_game?: XOR<Puzzle_gameScalarRelationFilter, puzzle_gameWhereInput>
    quiz_game?: XOR<Quiz_gameScalarRelationFilter, quiz_gameWhereInput>
    treasure_game?: XOR<Treasure_gameScalarRelationFilter, treasure_gameWhereInput>
  }

  export type AfterQuestionInformationOrderByWithRelationInput = {
    id?: SortOrder
    gameId?: SortOrder
    questionNumber?: SortOrder
    images?: SortOrder
    texts?: SortOrder
    puzzle_game?: puzzle_gameOrderByWithRelationInput
    quiz_game?: quiz_gameOrderByWithRelationInput
    treasure_game?: treasure_gameOrderByWithRelationInput
  }

  export type AfterQuestionInformationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AfterQuestionInformationWhereInput | AfterQuestionInformationWhereInput[]
    OR?: AfterQuestionInformationWhereInput[]
    NOT?: AfterQuestionInformationWhereInput | AfterQuestionInformationWhereInput[]
    gameId?: IntFilter<"AfterQuestionInformation"> | number
    questionNumber?: IntFilter<"AfterQuestionInformation"> | number
    images?: JsonFilter<"AfterQuestionInformation">
    texts?: JsonFilter<"AfterQuestionInformation">
    puzzle_game?: XOR<Puzzle_gameScalarRelationFilter, puzzle_gameWhereInput>
    quiz_game?: XOR<Quiz_gameScalarRelationFilter, quiz_gameWhereInput>
    treasure_game?: XOR<Treasure_gameScalarRelationFilter, treasure_gameWhereInput>
  }, "id">

  export type AfterQuestionInformationOrderByWithAggregationInput = {
    id?: SortOrder
    gameId?: SortOrder
    questionNumber?: SortOrder
    images?: SortOrder
    texts?: SortOrder
    _count?: AfterQuestionInformationCountOrderByAggregateInput
    _avg?: AfterQuestionInformationAvgOrderByAggregateInput
    _max?: AfterQuestionInformationMaxOrderByAggregateInput
    _min?: AfterQuestionInformationMinOrderByAggregateInput
    _sum?: AfterQuestionInformationSumOrderByAggregateInput
  }

  export type AfterQuestionInformationScalarWhereWithAggregatesInput = {
    AND?: AfterQuestionInformationScalarWhereWithAggregatesInput | AfterQuestionInformationScalarWhereWithAggregatesInput[]
    OR?: AfterQuestionInformationScalarWhereWithAggregatesInput[]
    NOT?: AfterQuestionInformationScalarWhereWithAggregatesInput | AfterQuestionInformationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AfterQuestionInformation"> | number
    gameId?: IntWithAggregatesFilter<"AfterQuestionInformation"> | number
    questionNumber?: IntWithAggregatesFilter<"AfterQuestionInformation"> | number
    images?: JsonWithAggregatesFilter<"AfterQuestionInformation">
    texts?: JsonWithAggregatesFilter<"AfterQuestionInformation">
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    likes?: IntFilter<"Comment"> | number
    dislikes?: IntFilter<"Comment"> | number
    parentId?: IntNullableFilter<"Comment"> | number | null
    Comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    other_Comment?: CommentListRelationFilter
    Post?: XOR<PostScalarRelationFilter, PostWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    comment_reaction?: Comment_reactionListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    parentId?: SortOrderInput | SortOrder
    Comment?: CommentOrderByWithRelationInput
    other_Comment?: CommentOrderByRelationAggregateInput
    Post?: PostOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    comment_reaction?: comment_reactionOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    likes?: IntFilter<"Comment"> | number
    dislikes?: IntFilter<"Comment"> | number
    parentId?: IntNullableFilter<"Comment"> | number | null
    Comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    other_Comment?: CommentListRelationFilter
    Post?: XOR<PostScalarRelationFilter, PostWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    comment_reaction?: Comment_reactionListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    parentId?: SortOrderInput | SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    postId?: IntWithAggregatesFilter<"Comment"> | number
    userId?: IntWithAggregatesFilter<"Comment"> | number
    content?: StringWithAggregatesFilter<"Comment"> | string
    likes?: IntWithAggregatesFilter<"Comment"> | number
    dislikes?: IntWithAggregatesFilter<"Comment"> | number
    parentId?: IntNullableWithAggregatesFilter<"Comment"> | number | null
  }

  export type EmailVerificationWhereInput = {
    AND?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    OR?: EmailVerificationWhereInput[]
    NOT?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    id?: IntFilter<"EmailVerification"> | number
    userId?: IntFilter<"EmailVerification"> | number
    otp?: StringFilter<"EmailVerification"> | string
    createdAt?: DateTimeFilter<"EmailVerification"> | Date | string
    expiresAt?: DateTimeFilter<"EmailVerification"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailVerificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type EmailVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    OR?: EmailVerificationWhereInput[]
    NOT?: EmailVerificationWhereInput | EmailVerificationWhereInput[]
    otp?: StringFilter<"EmailVerification"> | string
    createdAt?: DateTimeFilter<"EmailVerification"> | Date | string
    expiresAt?: DateTimeFilter<"EmailVerification"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type EmailVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: EmailVerificationCountOrderByAggregateInput
    _avg?: EmailVerificationAvgOrderByAggregateInput
    _max?: EmailVerificationMaxOrderByAggregateInput
    _min?: EmailVerificationMinOrderByAggregateInput
    _sum?: EmailVerificationSumOrderByAggregateInput
  }

  export type EmailVerificationScalarWhereWithAggregatesInput = {
    AND?: EmailVerificationScalarWhereWithAggregatesInput | EmailVerificationScalarWhereWithAggregatesInput[]
    OR?: EmailVerificationScalarWhereWithAggregatesInput[]
    NOT?: EmailVerificationScalarWhereWithAggregatesInput | EmailVerificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailVerification"> | number
    userId?: IntWithAggregatesFilter<"EmailVerification"> | number
    otp?: StringWithAggregatesFilter<"EmailVerification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailVerification"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"EmailVerification"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: IntFilter<"Post"> | number
    userId?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    question?: StringFilter<"Post"> | string
    media?: JsonFilter<"Post">
    Comment?: CommentListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Tags?: TagsListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    question?: SortOrder
    media?: SortOrder
    Comment?: CommentOrderByRelationAggregateInput
    User?: UserOrderByWithRelationInput
    Tags?: TagsOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    userId?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    question?: StringFilter<"Post"> | string
    media?: JsonFilter<"Post">
    Comment?: CommentListRelationFilter
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Tags?: TagsListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    question?: SortOrder
    media?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Post"> | number
    userId?: IntWithAggregatesFilter<"Post"> | number
    title?: StringWithAggregatesFilter<"Post"> | string
    question?: StringWithAggregatesFilter<"Post"> | string
    media?: JsonWithAggregatesFilter<"Post">
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    hashedToken?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expireAt?: DateTimeFilter<"RefreshToken"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    hashedToken?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expireAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    hashedToken?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: IntFilter<"RefreshToken"> | number
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expireAt?: DateTimeFilter<"RefreshToken"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "hashedToken">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    hashedToken?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expireAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _avg?: RefreshTokenAvgOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
    _sum?: RefreshTokenSumOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    hashedToken?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: IntWithAggregatesFilter<"RefreshToken"> | number
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    expireAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type RegionWhereInput = {
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    id?: IntFilter<"Region"> | number
    regionName?: StringFilter<"Region"> | string
    regionCode?: StringFilter<"Region"> | string
    mediaUrl?: StringNullableFilter<"Region"> | string | null
    description?: StringNullableFilter<"Region"> | string | null
    puzzle_game?: Puzzle_gameListRelationFilter
    quiz_game?: Quiz_gameListRelationFilter
    treasure_game?: Treasure_gameListRelationFilter
  }

  export type RegionOrderByWithRelationInput = {
    id?: SortOrder
    regionName?: SortOrder
    regionCode?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    puzzle_game?: puzzle_gameOrderByRelationAggregateInput
    quiz_game?: quiz_gameOrderByRelationAggregateInput
    treasure_game?: treasure_gameOrderByRelationAggregateInput
  }

  export type RegionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    regionCode?: string
    AND?: RegionWhereInput | RegionWhereInput[]
    OR?: RegionWhereInput[]
    NOT?: RegionWhereInput | RegionWhereInput[]
    regionName?: StringFilter<"Region"> | string
    mediaUrl?: StringNullableFilter<"Region"> | string | null
    description?: StringNullableFilter<"Region"> | string | null
    puzzle_game?: Puzzle_gameListRelationFilter
    quiz_game?: Quiz_gameListRelationFilter
    treasure_game?: Treasure_gameListRelationFilter
  }, "id" | "regionCode">

  export type RegionOrderByWithAggregationInput = {
    id?: SortOrder
    regionName?: SortOrder
    regionCode?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RegionCountOrderByAggregateInput
    _avg?: RegionAvgOrderByAggregateInput
    _max?: RegionMaxOrderByAggregateInput
    _min?: RegionMinOrderByAggregateInput
    _sum?: RegionSumOrderByAggregateInput
  }

  export type RegionScalarWhereWithAggregatesInput = {
    AND?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    OR?: RegionScalarWhereWithAggregatesInput[]
    NOT?: RegionScalarWhereWithAggregatesInput | RegionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Region"> | number
    regionName?: StringWithAggregatesFilter<"Region"> | string
    regionCode?: StringWithAggregatesFilter<"Region"> | string
    mediaUrl?: StringNullableWithAggregatesFilter<"Region"> | string | null
    description?: StringNullableWithAggregatesFilter<"Region"> | string | null
  }

  export type TagsWhereInput = {
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    id?: IntFilter<"Tags"> | number
    name?: StringFilter<"Tags"> | string
    Post?: PostListRelationFilter
  }

  export type TagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    Post?: PostOrderByRelationAggregateInput
  }

  export type TagsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: TagsWhereInput | TagsWhereInput[]
    OR?: TagsWhereInput[]
    NOT?: TagsWhereInput | TagsWhereInput[]
    Post?: PostListRelationFilter
  }, "id" | "name">

  export type TagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TagsCountOrderByAggregateInput
    _avg?: TagsAvgOrderByAggregateInput
    _max?: TagsMaxOrderByAggregateInput
    _min?: TagsMinOrderByAggregateInput
    _sum?: TagsSumOrderByAggregateInput
  }

  export type TagsScalarWhereWithAggregatesInput = {
    AND?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    OR?: TagsScalarWhereWithAggregatesInput[]
    NOT?: TagsScalarWhereWithAggregatesInput | TagsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tags"> | number
    name?: StringWithAggregatesFilter<"Tags"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    full_name?: StringFilter<"User"> | string
    username?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    location?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    Achievement?: AchievementListRelationFilter
    Comment?: CommentListRelationFilter
    EmailVerification?: XOR<EmailVerificationNullableScalarRelationFilter, EmailVerificationWhereInput> | null
    Post?: PostListRelationFilter
    RefreshToken?: RefreshTokenListRelationFilter
    comment_reaction?: Comment_reactionListRelationFilter
    password_resets?: Password_resetsListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    Achievement?: AchievementOrderByRelationAggregateInput
    Comment?: CommentOrderByRelationAggregateInput
    EmailVerification?: EmailVerificationOrderByWithRelationInput
    Post?: PostOrderByRelationAggregateInput
    RefreshToken?: RefreshTokenOrderByRelationAggregateInput
    comment_reaction?: comment_reactionOrderByRelationAggregateInput
    password_resets?: password_resetsOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    full_name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    avatarUrl?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    location?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    Achievement?: AchievementListRelationFilter
    Comment?: CommentListRelationFilter
    EmailVerification?: XOR<EmailVerificationNullableScalarRelationFilter, EmailVerificationWhereInput> | null
    Post?: PostListRelationFilter
    RefreshToken?: RefreshTokenListRelationFilter
    comment_reaction?: Comment_reactionListRelationFilter
    password_resets?: Password_resetsListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    full_name?: StringWithAggregatesFilter<"User"> | string
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    location?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type comment_reactionWhereInput = {
    AND?: comment_reactionWhereInput | comment_reactionWhereInput[]
    OR?: comment_reactionWhereInput[]
    NOT?: comment_reactionWhereInput | comment_reactionWhereInput[]
    id?: IntFilter<"comment_reaction"> | number
    user_id?: IntFilter<"comment_reaction"> | number
    comment_id?: IntFilter<"comment_reaction"> | number
    reaction_type?: Enumreaction_type_enumFilter<"comment_reaction"> | $Enums.reaction_type_enum
    created_at?: DateTimeNullableFilter<"comment_reaction"> | Date | string | null
    Comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type comment_reactionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    comment_id?: SortOrder
    reaction_type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    Comment?: CommentOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type comment_reactionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: comment_reactionWhereInput | comment_reactionWhereInput[]
    OR?: comment_reactionWhereInput[]
    NOT?: comment_reactionWhereInput | comment_reactionWhereInput[]
    user_id?: IntFilter<"comment_reaction"> | number
    comment_id?: IntFilter<"comment_reaction"> | number
    reaction_type?: Enumreaction_type_enumFilter<"comment_reaction"> | $Enums.reaction_type_enum
    created_at?: DateTimeNullableFilter<"comment_reaction"> | Date | string | null
    Comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type comment_reactionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    comment_id?: SortOrder
    reaction_type?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: comment_reactionCountOrderByAggregateInput
    _avg?: comment_reactionAvgOrderByAggregateInput
    _max?: comment_reactionMaxOrderByAggregateInput
    _min?: comment_reactionMinOrderByAggregateInput
    _sum?: comment_reactionSumOrderByAggregateInput
  }

  export type comment_reactionScalarWhereWithAggregatesInput = {
    AND?: comment_reactionScalarWhereWithAggregatesInput | comment_reactionScalarWhereWithAggregatesInput[]
    OR?: comment_reactionScalarWhereWithAggregatesInput[]
    NOT?: comment_reactionScalarWhereWithAggregatesInput | comment_reactionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"comment_reaction"> | number
    user_id?: IntWithAggregatesFilter<"comment_reaction"> | number
    comment_id?: IntWithAggregatesFilter<"comment_reaction"> | number
    reaction_type?: Enumreaction_type_enumWithAggregatesFilter<"comment_reaction"> | $Enums.reaction_type_enum
    created_at?: DateTimeNullableWithAggregatesFilter<"comment_reaction"> | Date | string | null
  }

  export type game_typeWhereInput = {
    AND?: game_typeWhereInput | game_typeWhereInput[]
    OR?: game_typeWhereInput[]
    NOT?: game_typeWhereInput | game_typeWhereInput[]
    id?: IntFilter<"game_type"> | number
    code?: Enumgame_code_enumFilter<"game_type"> | $Enums.game_code_enum
    name?: StringFilter<"game_type"> | string
    puzzle_game?: Puzzle_gameListRelationFilter
    quiz_game?: Quiz_gameListRelationFilter
    treasure_game?: Treasure_gameListRelationFilter
  }

  export type game_typeOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    puzzle_game?: puzzle_gameOrderByRelationAggregateInput
    quiz_game?: quiz_gameOrderByRelationAggregateInput
    treasure_game?: treasure_gameOrderByRelationAggregateInput
  }

  export type game_typeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: $Enums.game_code_enum
    AND?: game_typeWhereInput | game_typeWhereInput[]
    OR?: game_typeWhereInput[]
    NOT?: game_typeWhereInput | game_typeWhereInput[]
    name?: StringFilter<"game_type"> | string
    puzzle_game?: Puzzle_gameListRelationFilter
    quiz_game?: Quiz_gameListRelationFilter
    treasure_game?: Treasure_gameListRelationFilter
  }, "id" | "code">

  export type game_typeOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    _count?: game_typeCountOrderByAggregateInput
    _avg?: game_typeAvgOrderByAggregateInput
    _max?: game_typeMaxOrderByAggregateInput
    _min?: game_typeMinOrderByAggregateInput
    _sum?: game_typeSumOrderByAggregateInput
  }

  export type game_typeScalarWhereWithAggregatesInput = {
    AND?: game_typeScalarWhereWithAggregatesInput | game_typeScalarWhereWithAggregatesInput[]
    OR?: game_typeScalarWhereWithAggregatesInput[]
    NOT?: game_typeScalarWhereWithAggregatesInput | game_typeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"game_type"> | number
    code?: Enumgame_code_enumWithAggregatesFilter<"game_type"> | $Enums.game_code_enum
    name?: StringWithAggregatesFilter<"game_type"> | string
  }

  export type password_resetsWhereInput = {
    AND?: password_resetsWhereInput | password_resetsWhereInput[]
    OR?: password_resetsWhereInput[]
    NOT?: password_resetsWhereInput | password_resetsWhereInput[]
    id?: IntFilter<"password_resets"> | number
    userId?: IntFilter<"password_resets"> | number
    token?: StringFilter<"password_resets"> | string
    expiresAt?: DateTimeFilter<"password_resets"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type password_resetsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type password_resetsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: password_resetsWhereInput | password_resetsWhereInput[]
    OR?: password_resetsWhereInput[]
    NOT?: password_resetsWhereInput | password_resetsWhereInput[]
    userId?: IntFilter<"password_resets"> | number
    expiresAt?: DateTimeFilter<"password_resets"> | Date | string
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type password_resetsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    _count?: password_resetsCountOrderByAggregateInput
    _avg?: password_resetsAvgOrderByAggregateInput
    _max?: password_resetsMaxOrderByAggregateInput
    _min?: password_resetsMinOrderByAggregateInput
    _sum?: password_resetsSumOrderByAggregateInput
  }

  export type password_resetsScalarWhereWithAggregatesInput = {
    AND?: password_resetsScalarWhereWithAggregatesInput | password_resetsScalarWhereWithAggregatesInput[]
    OR?: password_resetsScalarWhereWithAggregatesInput[]
    NOT?: password_resetsScalarWhereWithAggregatesInput | password_resetsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"password_resets"> | number
    userId?: IntWithAggregatesFilter<"password_resets"> | number
    token?: StringWithAggregatesFilter<"password_resets"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"password_resets"> | Date | string
  }

  export type puzzle_gameWhereInput = {
    AND?: puzzle_gameWhereInput | puzzle_gameWhereInput[]
    OR?: puzzle_gameWhereInput[]
    NOT?: puzzle_gameWhereInput | puzzle_gameWhereInput[]
    id?: IntFilter<"puzzle_game"> | number
    regionid?: IntNullableFilter<"puzzle_game"> | number | null
    gametype?: IntNullableFilter<"puzzle_game"> | number | null
    imageurl?: StringNullableFilter<"puzzle_game"> | string | null
    AfterQuestionInformation?: AfterQuestionInformationListRelationFilter
    Region?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null
    game_type?: XOR<Game_typeNullableScalarRelationFilter, game_typeWhereInput> | null
    puzzle_pieces?: Puzzle_piecesListRelationFilter
  }

  export type puzzle_gameOrderByWithRelationInput = {
    id?: SortOrder
    regionid?: SortOrderInput | SortOrder
    gametype?: SortOrderInput | SortOrder
    imageurl?: SortOrderInput | SortOrder
    AfterQuestionInformation?: AfterQuestionInformationOrderByRelationAggregateInput
    Region?: RegionOrderByWithRelationInput
    game_type?: game_typeOrderByWithRelationInput
    puzzle_pieces?: puzzle_piecesOrderByRelationAggregateInput
  }

  export type puzzle_gameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: puzzle_gameWhereInput | puzzle_gameWhereInput[]
    OR?: puzzle_gameWhereInput[]
    NOT?: puzzle_gameWhereInput | puzzle_gameWhereInput[]
    regionid?: IntNullableFilter<"puzzle_game"> | number | null
    gametype?: IntNullableFilter<"puzzle_game"> | number | null
    imageurl?: StringNullableFilter<"puzzle_game"> | string | null
    AfterQuestionInformation?: AfterQuestionInformationListRelationFilter
    Region?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null
    game_type?: XOR<Game_typeNullableScalarRelationFilter, game_typeWhereInput> | null
    puzzle_pieces?: Puzzle_piecesListRelationFilter
  }, "id">

  export type puzzle_gameOrderByWithAggregationInput = {
    id?: SortOrder
    regionid?: SortOrderInput | SortOrder
    gametype?: SortOrderInput | SortOrder
    imageurl?: SortOrderInput | SortOrder
    _count?: puzzle_gameCountOrderByAggregateInput
    _avg?: puzzle_gameAvgOrderByAggregateInput
    _max?: puzzle_gameMaxOrderByAggregateInput
    _min?: puzzle_gameMinOrderByAggregateInput
    _sum?: puzzle_gameSumOrderByAggregateInput
  }

  export type puzzle_gameScalarWhereWithAggregatesInput = {
    AND?: puzzle_gameScalarWhereWithAggregatesInput | puzzle_gameScalarWhereWithAggregatesInput[]
    OR?: puzzle_gameScalarWhereWithAggregatesInput[]
    NOT?: puzzle_gameScalarWhereWithAggregatesInput | puzzle_gameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"puzzle_game"> | number
    regionid?: IntNullableWithAggregatesFilter<"puzzle_game"> | number | null
    gametype?: IntNullableWithAggregatesFilter<"puzzle_game"> | number | null
    imageurl?: StringNullableWithAggregatesFilter<"puzzle_game"> | string | null
  }

  export type puzzle_piecesWhereInput = {
    AND?: puzzle_piecesWhereInput | puzzle_piecesWhereInput[]
    OR?: puzzle_piecesWhereInput[]
    NOT?: puzzle_piecesWhereInput | puzzle_piecesWhereInput[]
    id?: IntFilter<"puzzle_pieces"> | number
    puzzleid?: IntNullableFilter<"puzzle_pieces"> | number | null
    piece_index?: IntFilter<"puzzle_pieces"> | number
    x_position?: IntNullableFilter<"puzzle_pieces"> | number | null
    y_position?: IntNullableFilter<"puzzle_pieces"> | number | null
    correct_x?: IntFilter<"puzzle_pieces"> | number
    correct_y?: IntFilter<"puzzle_pieces"> | number
    image_piece_url?: StringNullableFilter<"puzzle_pieces"> | string | null
    puzzle_game?: XOR<Puzzle_gameNullableScalarRelationFilter, puzzle_gameWhereInput> | null
  }

  export type puzzle_piecesOrderByWithRelationInput = {
    id?: SortOrder
    puzzleid?: SortOrderInput | SortOrder
    piece_index?: SortOrder
    x_position?: SortOrderInput | SortOrder
    y_position?: SortOrderInput | SortOrder
    correct_x?: SortOrder
    correct_y?: SortOrder
    image_piece_url?: SortOrderInput | SortOrder
    puzzle_game?: puzzle_gameOrderByWithRelationInput
  }

  export type puzzle_piecesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: puzzle_piecesWhereInput | puzzle_piecesWhereInput[]
    OR?: puzzle_piecesWhereInput[]
    NOT?: puzzle_piecesWhereInput | puzzle_piecesWhereInput[]
    puzzleid?: IntNullableFilter<"puzzle_pieces"> | number | null
    piece_index?: IntFilter<"puzzle_pieces"> | number
    x_position?: IntNullableFilter<"puzzle_pieces"> | number | null
    y_position?: IntNullableFilter<"puzzle_pieces"> | number | null
    correct_x?: IntFilter<"puzzle_pieces"> | number
    correct_y?: IntFilter<"puzzle_pieces"> | number
    image_piece_url?: StringNullableFilter<"puzzle_pieces"> | string | null
    puzzle_game?: XOR<Puzzle_gameNullableScalarRelationFilter, puzzle_gameWhereInput> | null
  }, "id">

  export type puzzle_piecesOrderByWithAggregationInput = {
    id?: SortOrder
    puzzleid?: SortOrderInput | SortOrder
    piece_index?: SortOrder
    x_position?: SortOrderInput | SortOrder
    y_position?: SortOrderInput | SortOrder
    correct_x?: SortOrder
    correct_y?: SortOrder
    image_piece_url?: SortOrderInput | SortOrder
    _count?: puzzle_piecesCountOrderByAggregateInput
    _avg?: puzzle_piecesAvgOrderByAggregateInput
    _max?: puzzle_piecesMaxOrderByAggregateInput
    _min?: puzzle_piecesMinOrderByAggregateInput
    _sum?: puzzle_piecesSumOrderByAggregateInput
  }

  export type puzzle_piecesScalarWhereWithAggregatesInput = {
    AND?: puzzle_piecesScalarWhereWithAggregatesInput | puzzle_piecesScalarWhereWithAggregatesInput[]
    OR?: puzzle_piecesScalarWhereWithAggregatesInput[]
    NOT?: puzzle_piecesScalarWhereWithAggregatesInput | puzzle_piecesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"puzzle_pieces"> | number
    puzzleid?: IntNullableWithAggregatesFilter<"puzzle_pieces"> | number | null
    piece_index?: IntWithAggregatesFilter<"puzzle_pieces"> | number
    x_position?: IntNullableWithAggregatesFilter<"puzzle_pieces"> | number | null
    y_position?: IntNullableWithAggregatesFilter<"puzzle_pieces"> | number | null
    correct_x?: IntWithAggregatesFilter<"puzzle_pieces"> | number
    correct_y?: IntWithAggregatesFilter<"puzzle_pieces"> | number
    image_piece_url?: StringNullableWithAggregatesFilter<"puzzle_pieces"> | string | null
  }

  export type quiz_gameWhereInput = {
    AND?: quiz_gameWhereInput | quiz_gameWhereInput[]
    OR?: quiz_gameWhereInput[]
    NOT?: quiz_gameWhereInput | quiz_gameWhereInput[]
    id?: IntFilter<"quiz_game"> | number
    regionid?: IntNullableFilter<"quiz_game"> | number | null
    gametype?: IntNullableFilter<"quiz_game"> | number | null
    title?: StringFilter<"quiz_game"> | string
    description?: StringNullableFilter<"quiz_game"> | string | null
    AfterQuestionInformation?: AfterQuestionInformationListRelationFilter
    game_type?: XOR<Game_typeNullableScalarRelationFilter, game_typeWhereInput> | null
    Region?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null
    quiz_game_qa?: Quiz_game_qaListRelationFilter
  }

  export type quiz_gameOrderByWithRelationInput = {
    id?: SortOrder
    regionid?: SortOrderInput | SortOrder
    gametype?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    AfterQuestionInformation?: AfterQuestionInformationOrderByRelationAggregateInput
    game_type?: game_typeOrderByWithRelationInput
    Region?: RegionOrderByWithRelationInput
    quiz_game_qa?: quiz_game_qaOrderByRelationAggregateInput
  }

  export type quiz_gameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: quiz_gameWhereInput | quiz_gameWhereInput[]
    OR?: quiz_gameWhereInput[]
    NOT?: quiz_gameWhereInput | quiz_gameWhereInput[]
    regionid?: IntNullableFilter<"quiz_game"> | number | null
    gametype?: IntNullableFilter<"quiz_game"> | number | null
    title?: StringFilter<"quiz_game"> | string
    description?: StringNullableFilter<"quiz_game"> | string | null
    AfterQuestionInformation?: AfterQuestionInformationListRelationFilter
    game_type?: XOR<Game_typeNullableScalarRelationFilter, game_typeWhereInput> | null
    Region?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null
    quiz_game_qa?: Quiz_game_qaListRelationFilter
  }, "id">

  export type quiz_gameOrderByWithAggregationInput = {
    id?: SortOrder
    regionid?: SortOrderInput | SortOrder
    gametype?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: quiz_gameCountOrderByAggregateInput
    _avg?: quiz_gameAvgOrderByAggregateInput
    _max?: quiz_gameMaxOrderByAggregateInput
    _min?: quiz_gameMinOrderByAggregateInput
    _sum?: quiz_gameSumOrderByAggregateInput
  }

  export type quiz_gameScalarWhereWithAggregatesInput = {
    AND?: quiz_gameScalarWhereWithAggregatesInput | quiz_gameScalarWhereWithAggregatesInput[]
    OR?: quiz_gameScalarWhereWithAggregatesInput[]
    NOT?: quiz_gameScalarWhereWithAggregatesInput | quiz_gameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"quiz_game"> | number
    regionid?: IntNullableWithAggregatesFilter<"quiz_game"> | number | null
    gametype?: IntNullableWithAggregatesFilter<"quiz_game"> | number | null
    title?: StringWithAggregatesFilter<"quiz_game"> | string
    description?: StringNullableWithAggregatesFilter<"quiz_game"> | string | null
  }

  export type quiz_game_qaWhereInput = {
    AND?: quiz_game_qaWhereInput | quiz_game_qaWhereInput[]
    OR?: quiz_game_qaWhereInput[]
    NOT?: quiz_game_qaWhereInput | quiz_game_qaWhereInput[]
    id?: IntFilter<"quiz_game_qa"> | number
    quiz_game_id?: IntNullableFilter<"quiz_game_qa"> | number | null
    question?: StringFilter<"quiz_game_qa"> | string
    wrong_answers?: JsonFilter<"quiz_game_qa">
    correct_answer?: StringFilter<"quiz_game_qa"> | string
    quiz_game?: XOR<Quiz_gameNullableScalarRelationFilter, quiz_gameWhereInput> | null
  }

  export type quiz_game_qaOrderByWithRelationInput = {
    id?: SortOrder
    quiz_game_id?: SortOrderInput | SortOrder
    question?: SortOrder
    wrong_answers?: SortOrder
    correct_answer?: SortOrder
    quiz_game?: quiz_gameOrderByWithRelationInput
  }

  export type quiz_game_qaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: quiz_game_qaWhereInput | quiz_game_qaWhereInput[]
    OR?: quiz_game_qaWhereInput[]
    NOT?: quiz_game_qaWhereInput | quiz_game_qaWhereInput[]
    quiz_game_id?: IntNullableFilter<"quiz_game_qa"> | number | null
    question?: StringFilter<"quiz_game_qa"> | string
    wrong_answers?: JsonFilter<"quiz_game_qa">
    correct_answer?: StringFilter<"quiz_game_qa"> | string
    quiz_game?: XOR<Quiz_gameNullableScalarRelationFilter, quiz_gameWhereInput> | null
  }, "id">

  export type quiz_game_qaOrderByWithAggregationInput = {
    id?: SortOrder
    quiz_game_id?: SortOrderInput | SortOrder
    question?: SortOrder
    wrong_answers?: SortOrder
    correct_answer?: SortOrder
    _count?: quiz_game_qaCountOrderByAggregateInput
    _avg?: quiz_game_qaAvgOrderByAggregateInput
    _max?: quiz_game_qaMaxOrderByAggregateInput
    _min?: quiz_game_qaMinOrderByAggregateInput
    _sum?: quiz_game_qaSumOrderByAggregateInput
  }

  export type quiz_game_qaScalarWhereWithAggregatesInput = {
    AND?: quiz_game_qaScalarWhereWithAggregatesInput | quiz_game_qaScalarWhereWithAggregatesInput[]
    OR?: quiz_game_qaScalarWhereWithAggregatesInput[]
    NOT?: quiz_game_qaScalarWhereWithAggregatesInput | quiz_game_qaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"quiz_game_qa"> | number
    quiz_game_id?: IntNullableWithAggregatesFilter<"quiz_game_qa"> | number | null
    question?: StringWithAggregatesFilter<"quiz_game_qa"> | string
    wrong_answers?: JsonWithAggregatesFilter<"quiz_game_qa">
    correct_answer?: StringWithAggregatesFilter<"quiz_game_qa"> | string
  }

  export type treasure_connection_cardsWhereInput = {
    AND?: treasure_connection_cardsWhereInput | treasure_connection_cardsWhereInput[]
    OR?: treasure_connection_cardsWhereInput[]
    NOT?: treasure_connection_cardsWhereInput | treasure_connection_cardsWhereInput[]
    id?: IntFilter<"treasure_connection_cards"> | number
    treasure_game_id?: IntNullableFilter<"treasure_connection_cards"> | number | null
    card_type?: Enumcard_type_enumFilter<"treasure_connection_cards"> | $Enums.card_type_enum
    card_value?: StringNullableFilter<"treasure_connection_cards"> | string | null
    image_url?: StringNullableFilter<"treasure_connection_cards"> | string | null
    pair_id?: IntFilter<"treasure_connection_cards"> | number
    position?: IntNullableFilter<"treasure_connection_cards"> | number | null
    treasure_game?: XOR<Treasure_gameNullableScalarRelationFilter, treasure_gameWhereInput> | null
  }

  export type treasure_connection_cardsOrderByWithRelationInput = {
    id?: SortOrder
    treasure_game_id?: SortOrderInput | SortOrder
    card_type?: SortOrder
    card_value?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    pair_id?: SortOrder
    position?: SortOrderInput | SortOrder
    treasure_game?: treasure_gameOrderByWithRelationInput
  }

  export type treasure_connection_cardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: treasure_connection_cardsWhereInput | treasure_connection_cardsWhereInput[]
    OR?: treasure_connection_cardsWhereInput[]
    NOT?: treasure_connection_cardsWhereInput | treasure_connection_cardsWhereInput[]
    treasure_game_id?: IntNullableFilter<"treasure_connection_cards"> | number | null
    card_type?: Enumcard_type_enumFilter<"treasure_connection_cards"> | $Enums.card_type_enum
    card_value?: StringNullableFilter<"treasure_connection_cards"> | string | null
    image_url?: StringNullableFilter<"treasure_connection_cards"> | string | null
    pair_id?: IntFilter<"treasure_connection_cards"> | number
    position?: IntNullableFilter<"treasure_connection_cards"> | number | null
    treasure_game?: XOR<Treasure_gameNullableScalarRelationFilter, treasure_gameWhereInput> | null
  }, "id">

  export type treasure_connection_cardsOrderByWithAggregationInput = {
    id?: SortOrder
    treasure_game_id?: SortOrderInput | SortOrder
    card_type?: SortOrder
    card_value?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    pair_id?: SortOrder
    position?: SortOrderInput | SortOrder
    _count?: treasure_connection_cardsCountOrderByAggregateInput
    _avg?: treasure_connection_cardsAvgOrderByAggregateInput
    _max?: treasure_connection_cardsMaxOrderByAggregateInput
    _min?: treasure_connection_cardsMinOrderByAggregateInput
    _sum?: treasure_connection_cardsSumOrderByAggregateInput
  }

  export type treasure_connection_cardsScalarWhereWithAggregatesInput = {
    AND?: treasure_connection_cardsScalarWhereWithAggregatesInput | treasure_connection_cardsScalarWhereWithAggregatesInput[]
    OR?: treasure_connection_cardsScalarWhereWithAggregatesInput[]
    NOT?: treasure_connection_cardsScalarWhereWithAggregatesInput | treasure_connection_cardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"treasure_connection_cards"> | number
    treasure_game_id?: IntNullableWithAggregatesFilter<"treasure_connection_cards"> | number | null
    card_type?: Enumcard_type_enumWithAggregatesFilter<"treasure_connection_cards"> | $Enums.card_type_enum
    card_value?: StringNullableWithAggregatesFilter<"treasure_connection_cards"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"treasure_connection_cards"> | string | null
    pair_id?: IntWithAggregatesFilter<"treasure_connection_cards"> | number
    position?: IntNullableWithAggregatesFilter<"treasure_connection_cards"> | number | null
  }

  export type treasure_gameWhereInput = {
    AND?: treasure_gameWhereInput | treasure_gameWhereInput[]
    OR?: treasure_gameWhereInput[]
    NOT?: treasure_gameWhereInput | treasure_gameWhereInput[]
    id?: IntFilter<"treasure_game"> | number
    regionid?: IntNullableFilter<"treasure_game"> | number | null
    gametype?: IntNullableFilter<"treasure_game"> | number | null
    title?: StringNullableFilter<"treasure_game"> | string | null
    description?: StringNullableFilter<"treasure_game"> | string | null
    AfterQuestionInformation?: AfterQuestionInformationListRelationFilter
    treasure_connection_cards?: Treasure_connection_cardsListRelationFilter
    game_type?: XOR<Game_typeNullableScalarRelationFilter, game_typeWhereInput> | null
    Region?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null
  }

  export type treasure_gameOrderByWithRelationInput = {
    id?: SortOrder
    regionid?: SortOrderInput | SortOrder
    gametype?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    AfterQuestionInformation?: AfterQuestionInformationOrderByRelationAggregateInput
    treasure_connection_cards?: treasure_connection_cardsOrderByRelationAggregateInput
    game_type?: game_typeOrderByWithRelationInput
    Region?: RegionOrderByWithRelationInput
  }

  export type treasure_gameWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: treasure_gameWhereInput | treasure_gameWhereInput[]
    OR?: treasure_gameWhereInput[]
    NOT?: treasure_gameWhereInput | treasure_gameWhereInput[]
    regionid?: IntNullableFilter<"treasure_game"> | number | null
    gametype?: IntNullableFilter<"treasure_game"> | number | null
    title?: StringNullableFilter<"treasure_game"> | string | null
    description?: StringNullableFilter<"treasure_game"> | string | null
    AfterQuestionInformation?: AfterQuestionInformationListRelationFilter
    treasure_connection_cards?: Treasure_connection_cardsListRelationFilter
    game_type?: XOR<Game_typeNullableScalarRelationFilter, game_typeWhereInput> | null
    Region?: XOR<RegionNullableScalarRelationFilter, RegionWhereInput> | null
  }, "id">

  export type treasure_gameOrderByWithAggregationInput = {
    id?: SortOrder
    regionid?: SortOrderInput | SortOrder
    gametype?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: treasure_gameCountOrderByAggregateInput
    _avg?: treasure_gameAvgOrderByAggregateInput
    _max?: treasure_gameMaxOrderByAggregateInput
    _min?: treasure_gameMinOrderByAggregateInput
    _sum?: treasure_gameSumOrderByAggregateInput
  }

  export type treasure_gameScalarWhereWithAggregatesInput = {
    AND?: treasure_gameScalarWhereWithAggregatesInput | treasure_gameScalarWhereWithAggregatesInput[]
    OR?: treasure_gameScalarWhereWithAggregatesInput[]
    NOT?: treasure_gameScalarWhereWithAggregatesInput | treasure_gameScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"treasure_game"> | number
    regionid?: IntNullableWithAggregatesFilter<"treasure_game"> | number | null
    gametype?: IntNullableWithAggregatesFilter<"treasure_game"> | number | null
    title?: StringNullableWithAggregatesFilter<"treasure_game"> | string | null
    description?: StringNullableWithAggregatesFilter<"treasure_game"> | string | null
  }

  export type AchievementCreateInput = {
    name: string
    description: string
    stars: number
    User: UserCreateNestedOneWithoutAchievementInput
  }

  export type AchievementUncheckedCreateInput = {
    id?: number
    userId: number
    name: string
    description: string
    stars: number
  }

  export type AchievementUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
    User?: UserUpdateOneRequiredWithoutAchievementNestedInput
  }

  export type AchievementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementCreateManyInput = {
    id?: number
    userId: number
    name: string
    description: string
    stars: number
  }

  export type AchievementUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
  }

  export type AfterQuestionInformationCreateInput = {
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
    puzzle_game: puzzle_gameCreateNestedOneWithoutAfterQuestionInformationInput
    quiz_game: quiz_gameCreateNestedOneWithoutAfterQuestionInformationInput
    treasure_game: treasure_gameCreateNestedOneWithoutAfterQuestionInformationInput
  }

  export type AfterQuestionInformationUncheckedCreateInput = {
    id?: number
    gameId: number
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationUpdateInput = {
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
    puzzle_game?: puzzle_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput
    quiz_game?: quiz_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput
    treasure_game?: treasure_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput
  }

  export type AfterQuestionInformationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationCreateManyInput = {
    id?: number
    gameId: number
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationUpdateManyMutationInput = {
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    gameId?: IntFieldUpdateOperationsInput | number
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
  }

  export type CommentCreateInput = {
    content: string
    likes?: number
    dislikes?: number
    Comment?: CommentCreateNestedOneWithoutOther_CommentInput
    other_Comment?: CommentCreateNestedManyWithoutCommentInput
    Post: PostCreateNestedOneWithoutCommentInput
    User: UserCreateNestedOneWithoutCommentInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    content: string
    likes?: number
    dislikes?: number
    parentId?: number | null
    other_Comment?: CommentUncheckedCreateNestedManyWithoutCommentInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    Comment?: CommentUpdateOneWithoutOther_CommentNestedInput
    other_Comment?: CommentUpdateManyWithoutCommentNestedInput
    Post?: PostUpdateOneRequiredWithoutCommentNestedInput
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    other_Comment?: CommentUncheckedUpdateManyWithoutCommentNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: number
    postId: number
    userId: number
    content: string
    likes?: number
    dislikes?: number
    parentId?: number | null
  }

  export type CommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EmailVerificationCreateInput = {
    otp: string
    createdAt?: Date | string
    expiresAt: Date | string
    User: UserCreateNestedOneWithoutEmailVerificationInput
  }

  export type EmailVerificationUncheckedCreateInput = {
    id?: number
    userId: number
    otp: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailVerificationUpdateInput = {
    otp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutEmailVerificationNestedInput
  }

  export type EmailVerificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    otp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationCreateManyInput = {
    id?: number
    userId: number
    otp: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailVerificationUpdateManyMutationInput = {
    otp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    otp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
    Comment?: CommentCreateNestedManyWithoutPostInput
    User: UserCreateNestedOneWithoutPostInput
    Tags?: TagsCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: number
    userId: number
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
    Comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    Tags?: TagsUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    Comment?: CommentUpdateManyWithoutPostNestedInput
    User?: UserUpdateOneRequiredWithoutPostNestedInput
    Tags?: TagsUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    Comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: number
    userId: number
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
  }

  export type PostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
  }

  export type PostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
  }

  export type RefreshTokenCreateInput = {
    id: string
    hashedToken: string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    expireAt: Date | string
    User: UserCreateNestedOneWithoutRefreshTokenInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id: string
    hashedToken: string
    userId: number
    revoked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    expireAt: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutRefreshTokenNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id: string
    hashedToken: string
    userId: number
    revoked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    expireAt: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionCreateInput = {
    regionName: string
    regionCode: string
    mediaUrl?: string | null
    description?: string | null
    puzzle_game?: puzzle_gameCreateNestedManyWithoutRegionInput
    quiz_game?: quiz_gameCreateNestedManyWithoutRegionInput
    treasure_game?: treasure_gameCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateInput = {
    id?: number
    regionName: string
    regionCode: string
    mediaUrl?: string | null
    description?: string | null
    puzzle_game?: puzzle_gameUncheckedCreateNestedManyWithoutRegionInput
    quiz_game?: quiz_gameUncheckedCreateNestedManyWithoutRegionInput
    treasure_game?: treasure_gameUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionUpdateInput = {
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puzzle_game?: puzzle_gameUpdateManyWithoutRegionNestedInput
    quiz_game?: quiz_gameUpdateManyWithoutRegionNestedInput
    treasure_game?: treasure_gameUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puzzle_game?: puzzle_gameUncheckedUpdateManyWithoutRegionNestedInput
    quiz_game?: quiz_gameUncheckedUpdateManyWithoutRegionNestedInput
    treasure_game?: treasure_gameUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type RegionCreateManyInput = {
    id?: number
    regionName: string
    regionCode: string
    mediaUrl?: string | null
    description?: string | null
  }

  export type RegionUpdateManyMutationInput = {
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TagsCreateInput = {
    name: string
    Post?: PostCreateNestedManyWithoutTagsInput
  }

  export type TagsUncheckedCreateInput = {
    id?: number
    name: string
    Post?: PostUncheckedCreateNestedManyWithoutTagsInput
  }

  export type TagsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Post?: PostUpdateManyWithoutTagsNestedInput
  }

  export type TagsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Post?: PostUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type TagsCreateManyInput = {
    id?: number
    name: string
  }

  export type TagsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutUserInput
    password_resets?: password_resetsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutUserInput
    password_resets?: password_resetsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
  }

  export type UserUpdateManyMutationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type comment_reactionCreateInput = {
    reaction_type: $Enums.reaction_type_enum
    created_at?: Date | string | null
    Comment: CommentCreateNestedOneWithoutComment_reactionInput
    User: UserCreateNestedOneWithoutComment_reactionInput
  }

  export type comment_reactionUncheckedCreateInput = {
    id?: number
    user_id: number
    comment_id: number
    reaction_type: $Enums.reaction_type_enum
    created_at?: Date | string | null
  }

  export type comment_reactionUpdateInput = {
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Comment?: CommentUpdateOneRequiredWithoutComment_reactionNestedInput
    User?: UserUpdateOneRequiredWithoutComment_reactionNestedInput
  }

  export type comment_reactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment_id?: IntFieldUpdateOperationsInput | number
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type comment_reactionCreateManyInput = {
    id?: number
    user_id: number
    comment_id: number
    reaction_type: $Enums.reaction_type_enum
    created_at?: Date | string | null
  }

  export type comment_reactionUpdateManyMutationInput = {
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type comment_reactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    comment_id?: IntFieldUpdateOperationsInput | number
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type game_typeCreateInput = {
    code: $Enums.game_code_enum
    name: string
    puzzle_game?: puzzle_gameCreateNestedManyWithoutGame_typeInput
    quiz_game?: quiz_gameCreateNestedManyWithoutGame_typeInput
    treasure_game?: treasure_gameCreateNestedManyWithoutGame_typeInput
  }

  export type game_typeUncheckedCreateInput = {
    id?: number
    code: $Enums.game_code_enum
    name: string
    puzzle_game?: puzzle_gameUncheckedCreateNestedManyWithoutGame_typeInput
    quiz_game?: quiz_gameUncheckedCreateNestedManyWithoutGame_typeInput
    treasure_game?: treasure_gameUncheckedCreateNestedManyWithoutGame_typeInput
  }

  export type game_typeUpdateInput = {
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
    puzzle_game?: puzzle_gameUpdateManyWithoutGame_typeNestedInput
    quiz_game?: quiz_gameUpdateManyWithoutGame_typeNestedInput
    treasure_game?: treasure_gameUpdateManyWithoutGame_typeNestedInput
  }

  export type game_typeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
    puzzle_game?: puzzle_gameUncheckedUpdateManyWithoutGame_typeNestedInput
    quiz_game?: quiz_gameUncheckedUpdateManyWithoutGame_typeNestedInput
    treasure_game?: treasure_gameUncheckedUpdateManyWithoutGame_typeNestedInput
  }

  export type game_typeCreateManyInput = {
    id?: number
    code: $Enums.game_code_enum
    name: string
  }

  export type game_typeUpdateManyMutationInput = {
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
  }

  export type game_typeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
  }

  export type password_resetsCreateInput = {
    token: string
    expiresAt: Date | string
    User: UserCreateNestedOneWithoutPassword_resetsInput
  }

  export type password_resetsUncheckedCreateInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
  }

  export type password_resetsUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneRequiredWithoutPassword_resetsNestedInput
  }

  export type password_resetsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_resetsCreateManyInput = {
    id?: number
    userId: number
    token: string
    expiresAt: Date | string
  }

  export type password_resetsUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_resetsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type puzzle_gameCreateInput = {
    imageurl?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutPuzzle_gameInput
    Region?: RegionCreateNestedOneWithoutPuzzle_gameInput
    game_type?: game_typeCreateNestedOneWithoutPuzzle_gameInput
    puzzle_pieces?: puzzle_piecesCreateNestedManyWithoutPuzzle_gameInput
  }

  export type puzzle_gameUncheckedCreateInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    imageurl?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutPuzzle_gameInput
    puzzle_pieces?: puzzle_piecesUncheckedCreateNestedManyWithoutPuzzle_gameInput
  }

  export type puzzle_gameUpdateInput = {
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutPuzzle_gameNestedInput
    Region?: RegionUpdateOneWithoutPuzzle_gameNestedInput
    game_type?: game_typeUpdateOneWithoutPuzzle_gameNestedInput
    puzzle_pieces?: puzzle_piecesUpdateManyWithoutPuzzle_gameNestedInput
  }

  export type puzzle_gameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutPuzzle_gameNestedInput
    puzzle_pieces?: puzzle_piecesUncheckedUpdateManyWithoutPuzzle_gameNestedInput
  }

  export type puzzle_gameCreateManyInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    imageurl?: string | null
  }

  export type puzzle_gameUpdateManyMutationInput = {
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type puzzle_gameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type puzzle_piecesCreateInput = {
    piece_index: number
    x_position?: number | null
    y_position?: number | null
    correct_x: number
    correct_y: number
    image_piece_url?: string | null
    puzzle_game?: puzzle_gameCreateNestedOneWithoutPuzzle_piecesInput
  }

  export type puzzle_piecesUncheckedCreateInput = {
    id?: number
    puzzleid?: number | null
    piece_index: number
    x_position?: number | null
    y_position?: number | null
    correct_x: number
    correct_y: number
    image_piece_url?: string | null
  }

  export type puzzle_piecesUpdateInput = {
    piece_index?: IntFieldUpdateOperationsInput | number
    x_position?: NullableIntFieldUpdateOperationsInput | number | null
    y_position?: NullableIntFieldUpdateOperationsInput | number | null
    correct_x?: IntFieldUpdateOperationsInput | number
    correct_y?: IntFieldUpdateOperationsInput | number
    image_piece_url?: NullableStringFieldUpdateOperationsInput | string | null
    puzzle_game?: puzzle_gameUpdateOneWithoutPuzzle_piecesNestedInput
  }

  export type puzzle_piecesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    puzzleid?: NullableIntFieldUpdateOperationsInput | number | null
    piece_index?: IntFieldUpdateOperationsInput | number
    x_position?: NullableIntFieldUpdateOperationsInput | number | null
    y_position?: NullableIntFieldUpdateOperationsInput | number | null
    correct_x?: IntFieldUpdateOperationsInput | number
    correct_y?: IntFieldUpdateOperationsInput | number
    image_piece_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type puzzle_piecesCreateManyInput = {
    id?: number
    puzzleid?: number | null
    piece_index: number
    x_position?: number | null
    y_position?: number | null
    correct_x: number
    correct_y: number
    image_piece_url?: string | null
  }

  export type puzzle_piecesUpdateManyMutationInput = {
    piece_index?: IntFieldUpdateOperationsInput | number
    x_position?: NullableIntFieldUpdateOperationsInput | number | null
    y_position?: NullableIntFieldUpdateOperationsInput | number | null
    correct_x?: IntFieldUpdateOperationsInput | number
    correct_y?: IntFieldUpdateOperationsInput | number
    image_piece_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type puzzle_piecesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    puzzleid?: NullableIntFieldUpdateOperationsInput | number | null
    piece_index?: IntFieldUpdateOperationsInput | number
    x_position?: NullableIntFieldUpdateOperationsInput | number | null
    y_position?: NullableIntFieldUpdateOperationsInput | number | null
    correct_x?: IntFieldUpdateOperationsInput | number
    correct_y?: IntFieldUpdateOperationsInput | number
    image_piece_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quiz_gameCreateInput = {
    title: string
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutQuiz_gameInput
    game_type?: game_typeCreateNestedOneWithoutQuiz_gameInput
    Region?: RegionCreateNestedOneWithoutQuiz_gameInput
    quiz_game_qa?: quiz_game_qaCreateNestedManyWithoutQuiz_gameInput
  }

  export type quiz_gameUncheckedCreateInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    title: string
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutQuiz_gameInput
    quiz_game_qa?: quiz_game_qaUncheckedCreateNestedManyWithoutQuiz_gameInput
  }

  export type quiz_gameUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutQuiz_gameNestedInput
    game_type?: game_typeUpdateOneWithoutQuiz_gameNestedInput
    Region?: RegionUpdateOneWithoutQuiz_gameNestedInput
    quiz_game_qa?: quiz_game_qaUpdateManyWithoutQuiz_gameNestedInput
  }

  export type quiz_gameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutQuiz_gameNestedInput
    quiz_game_qa?: quiz_game_qaUncheckedUpdateManyWithoutQuiz_gameNestedInput
  }

  export type quiz_gameCreateManyInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    title: string
    description?: string | null
  }

  export type quiz_gameUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quiz_gameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quiz_game_qaCreateInput = {
    question: string
    wrong_answers: JsonNullValueInput | InputJsonValue
    correct_answer: string
    quiz_game?: quiz_gameCreateNestedOneWithoutQuiz_game_qaInput
  }

  export type quiz_game_qaUncheckedCreateInput = {
    id?: number
    quiz_game_id?: number | null
    question: string
    wrong_answers: JsonNullValueInput | InputJsonValue
    correct_answer: string
  }

  export type quiz_game_qaUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    wrong_answers?: JsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
    quiz_game?: quiz_gameUpdateOneWithoutQuiz_game_qaNestedInput
  }

  export type quiz_game_qaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quiz_game_id?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    wrong_answers?: JsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
  }

  export type quiz_game_qaCreateManyInput = {
    id?: number
    quiz_game_id?: number | null
    question: string
    wrong_answers: JsonNullValueInput | InputJsonValue
    correct_answer: string
  }

  export type quiz_game_qaUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
    wrong_answers?: JsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
  }

  export type quiz_game_qaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quiz_game_id?: NullableIntFieldUpdateOperationsInput | number | null
    question?: StringFieldUpdateOperationsInput | string
    wrong_answers?: JsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
  }

  export type treasure_connection_cardsCreateInput = {
    card_type: $Enums.card_type_enum
    card_value?: string | null
    image_url?: string | null
    pair_id: number
    position?: number | null
    treasure_game?: treasure_gameCreateNestedOneWithoutTreasure_connection_cardsInput
  }

  export type treasure_connection_cardsUncheckedCreateInput = {
    id?: number
    treasure_game_id?: number | null
    card_type: $Enums.card_type_enum
    card_value?: string | null
    image_url?: string | null
    pair_id: number
    position?: number | null
  }

  export type treasure_connection_cardsUpdateInput = {
    card_type?: Enumcard_type_enumFieldUpdateOperationsInput | $Enums.card_type_enum
    card_value?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pair_id?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
    treasure_game?: treasure_gameUpdateOneWithoutTreasure_connection_cardsNestedInput
  }

  export type treasure_connection_cardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    treasure_game_id?: NullableIntFieldUpdateOperationsInput | number | null
    card_type?: Enumcard_type_enumFieldUpdateOperationsInput | $Enums.card_type_enum
    card_value?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pair_id?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type treasure_connection_cardsCreateManyInput = {
    id?: number
    treasure_game_id?: number | null
    card_type: $Enums.card_type_enum
    card_value?: string | null
    image_url?: string | null
    pair_id: number
    position?: number | null
  }

  export type treasure_connection_cardsUpdateManyMutationInput = {
    card_type?: Enumcard_type_enumFieldUpdateOperationsInput | $Enums.card_type_enum
    card_value?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pair_id?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type treasure_connection_cardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    treasure_game_id?: NullableIntFieldUpdateOperationsInput | number | null
    card_type?: Enumcard_type_enumFieldUpdateOperationsInput | $Enums.card_type_enum
    card_value?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pair_id?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type treasure_gameCreateInput = {
    title?: string | null
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutTreasure_gameInput
    treasure_connection_cards?: treasure_connection_cardsCreateNestedManyWithoutTreasure_gameInput
    game_type?: game_typeCreateNestedOneWithoutTreasure_gameInput
    Region?: RegionCreateNestedOneWithoutTreasure_gameInput
  }

  export type treasure_gameUncheckedCreateInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    title?: string | null
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutTreasure_gameInput
    treasure_connection_cards?: treasure_connection_cardsUncheckedCreateNestedManyWithoutTreasure_gameInput
  }

  export type treasure_gameUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutTreasure_gameNestedInput
    treasure_connection_cards?: treasure_connection_cardsUpdateManyWithoutTreasure_gameNestedInput
    game_type?: game_typeUpdateOneWithoutTreasure_gameNestedInput
    Region?: RegionUpdateOneWithoutTreasure_gameNestedInput
  }

  export type treasure_gameUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutTreasure_gameNestedInput
    treasure_connection_cards?: treasure_connection_cardsUncheckedUpdateManyWithoutTreasure_gameNestedInput
  }

  export type treasure_gameCreateManyInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    title?: string | null
    description?: string | null
  }

  export type treasure_gameUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type treasure_gameUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    stars?: SortOrder
  }

  export type AchievementAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stars?: SortOrder
  }

  export type AchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    stars?: SortOrder
  }

  export type AchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    stars?: SortOrder
  }

  export type AchievementSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stars?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Puzzle_gameScalarRelationFilter = {
    is?: puzzle_gameWhereInput
    isNot?: puzzle_gameWhereInput
  }

  export type Quiz_gameScalarRelationFilter = {
    is?: quiz_gameWhereInput
    isNot?: quiz_gameWhereInput
  }

  export type Treasure_gameScalarRelationFilter = {
    is?: treasure_gameWhereInput
    isNot?: treasure_gameWhereInput
  }

  export type AfterQuestionInformationCountOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    questionNumber?: SortOrder
    images?: SortOrder
    texts?: SortOrder
  }

  export type AfterQuestionInformationAvgOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    questionNumber?: SortOrder
  }

  export type AfterQuestionInformationMaxOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    questionNumber?: SortOrder
  }

  export type AfterQuestionInformationMinOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    questionNumber?: SortOrder
  }

  export type AfterQuestionInformationSumOrderByAggregateInput = {
    id?: SortOrder
    gameId?: SortOrder
    questionNumber?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type Comment_reactionListRelationFilter = {
    every?: comment_reactionWhereInput
    some?: comment_reactionWhereInput
    none?: comment_reactionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type comment_reactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    parentId?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    parentId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    parentId?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    parentId?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    likes?: SortOrder
    dislikes?: SortOrder
    parentId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EmailVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailVerificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type EmailVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type EmailVerificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TagsListRelationFilter = {
    every?: TagsWhereInput
    some?: TagsWhereInput
    none?: TagsWhereInput
  }

  export type TagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    question?: SortOrder
    media?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    question?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    question?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    hashedToken?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expireAt?: SortOrder
  }

  export type RefreshTokenAvgOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    hashedToken?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expireAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    hashedToken?: SortOrder
    userId?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    expireAt?: SortOrder
  }

  export type RefreshTokenSumOrderByAggregateInput = {
    userId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Puzzle_gameListRelationFilter = {
    every?: puzzle_gameWhereInput
    some?: puzzle_gameWhereInput
    none?: puzzle_gameWhereInput
  }

  export type Quiz_gameListRelationFilter = {
    every?: quiz_gameWhereInput
    some?: quiz_gameWhereInput
    none?: quiz_gameWhereInput
  }

  export type Treasure_gameListRelationFilter = {
    every?: treasure_gameWhereInput
    some?: treasure_gameWhereInput
    none?: treasure_gameWhereInput
  }

  export type puzzle_gameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quiz_gameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type treasure_gameOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RegionCountOrderByAggregateInput = {
    id?: SortOrder
    regionName?: SortOrder
    regionCode?: SortOrder
    mediaUrl?: SortOrder
    description?: SortOrder
  }

  export type RegionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RegionMaxOrderByAggregateInput = {
    id?: SortOrder
    regionName?: SortOrder
    regionCode?: SortOrder
    mediaUrl?: SortOrder
    description?: SortOrder
  }

  export type RegionMinOrderByAggregateInput = {
    id?: SortOrder
    regionName?: SortOrder
    regionCode?: SortOrder
    mediaUrl?: SortOrder
    description?: SortOrder
  }

  export type RegionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TagsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AchievementListRelationFilter = {
    every?: AchievementWhereInput
    some?: AchievementWhereInput
    none?: AchievementWhereInput
  }

  export type EmailVerificationNullableScalarRelationFilter = {
    is?: EmailVerificationWhereInput | null
    isNot?: EmailVerificationWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type Password_resetsListRelationFilter = {
    every?: password_resetsWhereInput
    some?: password_resetsWhereInput
    none?: password_resetsWhereInput
  }

  export type AchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type password_resetsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    dateOfBirth?: SortOrder
    location?: SortOrder
    gender?: SortOrder
    isVerified?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    dateOfBirth?: SortOrder
    location?: SortOrder
    gender?: SortOrder
    isVerified?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    avatarUrl?: SortOrder
    dateOfBirth?: SortOrder
    location?: SortOrder
    gender?: SortOrder
    isVerified?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumreaction_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.reaction_type_enum | Enumreaction_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.reaction_type_enum[] | ListEnumreaction_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.reaction_type_enum[] | ListEnumreaction_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumreaction_type_enumFilter<$PrismaModel> | $Enums.reaction_type_enum
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type comment_reactionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    comment_id?: SortOrder
    reaction_type?: SortOrder
    created_at?: SortOrder
  }

  export type comment_reactionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    comment_id?: SortOrder
  }

  export type comment_reactionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    comment_id?: SortOrder
    reaction_type?: SortOrder
    created_at?: SortOrder
  }

  export type comment_reactionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    comment_id?: SortOrder
    reaction_type?: SortOrder
    created_at?: SortOrder
  }

  export type comment_reactionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    comment_id?: SortOrder
  }

  export type Enumreaction_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reaction_type_enum | Enumreaction_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.reaction_type_enum[] | ListEnumreaction_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.reaction_type_enum[] | ListEnumreaction_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumreaction_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.reaction_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreaction_type_enumFilter<$PrismaModel>
    _max?: NestedEnumreaction_type_enumFilter<$PrismaModel>
  }

  export type Enumgame_code_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.game_code_enum | Enumgame_code_enumFieldRefInput<$PrismaModel>
    in?: $Enums.game_code_enum[] | ListEnumgame_code_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.game_code_enum[] | ListEnumgame_code_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumgame_code_enumFilter<$PrismaModel> | $Enums.game_code_enum
  }

  export type game_typeCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type game_typeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type game_typeMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type game_typeMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
  }

  export type game_typeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumgame_code_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.game_code_enum | Enumgame_code_enumFieldRefInput<$PrismaModel>
    in?: $Enums.game_code_enum[] | ListEnumgame_code_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.game_code_enum[] | ListEnumgame_code_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumgame_code_enumWithAggregatesFilter<$PrismaModel> | $Enums.game_code_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgame_code_enumFilter<$PrismaModel>
    _max?: NestedEnumgame_code_enumFilter<$PrismaModel>
  }

  export type password_resetsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type password_resetsAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type password_resetsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type password_resetsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
  }

  export type password_resetsSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type AfterQuestionInformationListRelationFilter = {
    every?: AfterQuestionInformationWhereInput
    some?: AfterQuestionInformationWhereInput
    none?: AfterQuestionInformationWhereInput
  }

  export type RegionNullableScalarRelationFilter = {
    is?: RegionWhereInput | null
    isNot?: RegionWhereInput | null
  }

  export type Game_typeNullableScalarRelationFilter = {
    is?: game_typeWhereInput | null
    isNot?: game_typeWhereInput | null
  }

  export type Puzzle_piecesListRelationFilter = {
    every?: puzzle_piecesWhereInput
    some?: puzzle_piecesWhereInput
    none?: puzzle_piecesWhereInput
  }

  export type AfterQuestionInformationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type puzzle_piecesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type puzzle_gameCountOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
    imageurl?: SortOrder
  }

  export type puzzle_gameAvgOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
  }

  export type puzzle_gameMaxOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
    imageurl?: SortOrder
  }

  export type puzzle_gameMinOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
    imageurl?: SortOrder
  }

  export type puzzle_gameSumOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
  }

  export type Puzzle_gameNullableScalarRelationFilter = {
    is?: puzzle_gameWhereInput | null
    isNot?: puzzle_gameWhereInput | null
  }

  export type puzzle_piecesCountOrderByAggregateInput = {
    id?: SortOrder
    puzzleid?: SortOrder
    piece_index?: SortOrder
    x_position?: SortOrder
    y_position?: SortOrder
    correct_x?: SortOrder
    correct_y?: SortOrder
    image_piece_url?: SortOrder
  }

  export type puzzle_piecesAvgOrderByAggregateInput = {
    id?: SortOrder
    puzzleid?: SortOrder
    piece_index?: SortOrder
    x_position?: SortOrder
    y_position?: SortOrder
    correct_x?: SortOrder
    correct_y?: SortOrder
  }

  export type puzzle_piecesMaxOrderByAggregateInput = {
    id?: SortOrder
    puzzleid?: SortOrder
    piece_index?: SortOrder
    x_position?: SortOrder
    y_position?: SortOrder
    correct_x?: SortOrder
    correct_y?: SortOrder
    image_piece_url?: SortOrder
  }

  export type puzzle_piecesMinOrderByAggregateInput = {
    id?: SortOrder
    puzzleid?: SortOrder
    piece_index?: SortOrder
    x_position?: SortOrder
    y_position?: SortOrder
    correct_x?: SortOrder
    correct_y?: SortOrder
    image_piece_url?: SortOrder
  }

  export type puzzle_piecesSumOrderByAggregateInput = {
    id?: SortOrder
    puzzleid?: SortOrder
    piece_index?: SortOrder
    x_position?: SortOrder
    y_position?: SortOrder
    correct_x?: SortOrder
    correct_y?: SortOrder
  }

  export type Quiz_game_qaListRelationFilter = {
    every?: quiz_game_qaWhereInput
    some?: quiz_game_qaWhereInput
    none?: quiz_game_qaWhereInput
  }

  export type quiz_game_qaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type quiz_gameCountOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type quiz_gameAvgOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
  }

  export type quiz_gameMaxOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type quiz_gameMinOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type quiz_gameSumOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
  }

  export type Quiz_gameNullableScalarRelationFilter = {
    is?: quiz_gameWhereInput | null
    isNot?: quiz_gameWhereInput | null
  }

  export type quiz_game_qaCountOrderByAggregateInput = {
    id?: SortOrder
    quiz_game_id?: SortOrder
    question?: SortOrder
    wrong_answers?: SortOrder
    correct_answer?: SortOrder
  }

  export type quiz_game_qaAvgOrderByAggregateInput = {
    id?: SortOrder
    quiz_game_id?: SortOrder
  }

  export type quiz_game_qaMaxOrderByAggregateInput = {
    id?: SortOrder
    quiz_game_id?: SortOrder
    question?: SortOrder
    correct_answer?: SortOrder
  }

  export type quiz_game_qaMinOrderByAggregateInput = {
    id?: SortOrder
    quiz_game_id?: SortOrder
    question?: SortOrder
    correct_answer?: SortOrder
  }

  export type quiz_game_qaSumOrderByAggregateInput = {
    id?: SortOrder
    quiz_game_id?: SortOrder
  }

  export type Enumcard_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.card_type_enum | Enumcard_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.card_type_enum[] | ListEnumcard_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.card_type_enum[] | ListEnumcard_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumcard_type_enumFilter<$PrismaModel> | $Enums.card_type_enum
  }

  export type Treasure_gameNullableScalarRelationFilter = {
    is?: treasure_gameWhereInput | null
    isNot?: treasure_gameWhereInput | null
  }

  export type treasure_connection_cardsCountOrderByAggregateInput = {
    id?: SortOrder
    treasure_game_id?: SortOrder
    card_type?: SortOrder
    card_value?: SortOrder
    image_url?: SortOrder
    pair_id?: SortOrder
    position?: SortOrder
  }

  export type treasure_connection_cardsAvgOrderByAggregateInput = {
    id?: SortOrder
    treasure_game_id?: SortOrder
    pair_id?: SortOrder
    position?: SortOrder
  }

  export type treasure_connection_cardsMaxOrderByAggregateInput = {
    id?: SortOrder
    treasure_game_id?: SortOrder
    card_type?: SortOrder
    card_value?: SortOrder
    image_url?: SortOrder
    pair_id?: SortOrder
    position?: SortOrder
  }

  export type treasure_connection_cardsMinOrderByAggregateInput = {
    id?: SortOrder
    treasure_game_id?: SortOrder
    card_type?: SortOrder
    card_value?: SortOrder
    image_url?: SortOrder
    pair_id?: SortOrder
    position?: SortOrder
  }

  export type treasure_connection_cardsSumOrderByAggregateInput = {
    id?: SortOrder
    treasure_game_id?: SortOrder
    pair_id?: SortOrder
    position?: SortOrder
  }

  export type Enumcard_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.card_type_enum | Enumcard_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.card_type_enum[] | ListEnumcard_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.card_type_enum[] | ListEnumcard_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumcard_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.card_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcard_type_enumFilter<$PrismaModel>
    _max?: NestedEnumcard_type_enumFilter<$PrismaModel>
  }

  export type Treasure_connection_cardsListRelationFilter = {
    every?: treasure_connection_cardsWhereInput
    some?: treasure_connection_cardsWhereInput
    none?: treasure_connection_cardsWhereInput
  }

  export type treasure_connection_cardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type treasure_gameCountOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type treasure_gameAvgOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
  }

  export type treasure_gameMaxOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type treasure_gameMinOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type treasure_gameSumOrderByAggregateInput = {
    id?: SortOrder
    regionid?: SortOrder
    gametype?: SortOrder
  }

  export type UserCreateNestedOneWithoutAchievementInput = {
    create?: XOR<UserCreateWithoutAchievementInput, UserUncheckedCreateWithoutAchievementInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAchievementNestedInput = {
    create?: XOR<UserCreateWithoutAchievementInput, UserUncheckedCreateWithoutAchievementInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementInput
    upsert?: UserUpsertWithoutAchievementInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementInput, UserUpdateWithoutAchievementInput>, UserUncheckedUpdateWithoutAchievementInput>
  }

  export type puzzle_gameCreateNestedOneWithoutAfterQuestionInformationInput = {
    create?: XOR<puzzle_gameCreateWithoutAfterQuestionInformationInput, puzzle_gameUncheckedCreateWithoutAfterQuestionInformationInput>
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutAfterQuestionInformationInput
    connect?: puzzle_gameWhereUniqueInput
  }

  export type quiz_gameCreateNestedOneWithoutAfterQuestionInformationInput = {
    create?: XOR<quiz_gameCreateWithoutAfterQuestionInformationInput, quiz_gameUncheckedCreateWithoutAfterQuestionInformationInput>
    connectOrCreate?: quiz_gameCreateOrConnectWithoutAfterQuestionInformationInput
    connect?: quiz_gameWhereUniqueInput
  }

  export type treasure_gameCreateNestedOneWithoutAfterQuestionInformationInput = {
    create?: XOR<treasure_gameCreateWithoutAfterQuestionInformationInput, treasure_gameUncheckedCreateWithoutAfterQuestionInformationInput>
    connectOrCreate?: treasure_gameCreateOrConnectWithoutAfterQuestionInformationInput
    connect?: treasure_gameWhereUniqueInput
  }

  export type puzzle_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput = {
    create?: XOR<puzzle_gameCreateWithoutAfterQuestionInformationInput, puzzle_gameUncheckedCreateWithoutAfterQuestionInformationInput>
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutAfterQuestionInformationInput
    upsert?: puzzle_gameUpsertWithoutAfterQuestionInformationInput
    connect?: puzzle_gameWhereUniqueInput
    update?: XOR<XOR<puzzle_gameUpdateToOneWithWhereWithoutAfterQuestionInformationInput, puzzle_gameUpdateWithoutAfterQuestionInformationInput>, puzzle_gameUncheckedUpdateWithoutAfterQuestionInformationInput>
  }

  export type quiz_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput = {
    create?: XOR<quiz_gameCreateWithoutAfterQuestionInformationInput, quiz_gameUncheckedCreateWithoutAfterQuestionInformationInput>
    connectOrCreate?: quiz_gameCreateOrConnectWithoutAfterQuestionInformationInput
    upsert?: quiz_gameUpsertWithoutAfterQuestionInformationInput
    connect?: quiz_gameWhereUniqueInput
    update?: XOR<XOR<quiz_gameUpdateToOneWithWhereWithoutAfterQuestionInformationInput, quiz_gameUpdateWithoutAfterQuestionInformationInput>, quiz_gameUncheckedUpdateWithoutAfterQuestionInformationInput>
  }

  export type treasure_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput = {
    create?: XOR<treasure_gameCreateWithoutAfterQuestionInformationInput, treasure_gameUncheckedCreateWithoutAfterQuestionInformationInput>
    connectOrCreate?: treasure_gameCreateOrConnectWithoutAfterQuestionInformationInput
    upsert?: treasure_gameUpsertWithoutAfterQuestionInformationInput
    connect?: treasure_gameWhereUniqueInput
    update?: XOR<XOR<treasure_gameUpdateToOneWithWhereWithoutAfterQuestionInformationInput, treasure_gameUpdateWithoutAfterQuestionInformationInput>, treasure_gameUncheckedUpdateWithoutAfterQuestionInformationInput>
  }

  export type CommentCreateNestedOneWithoutOther_CommentInput = {
    create?: XOR<CommentCreateWithoutOther_CommentInput, CommentUncheckedCreateWithoutOther_CommentInput>
    connectOrCreate?: CommentCreateOrConnectWithoutOther_CommentInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput> | CommentCreateWithoutCommentInput[] | CommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCommentInput | CommentCreateOrConnectWithoutCommentInput[]
    createMany?: CommentCreateManyCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostCreateNestedOneWithoutCommentInput = {
    create?: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentInput
    connect?: PostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    connect?: UserWhereUniqueInput
  }

  export type comment_reactionCreateNestedManyWithoutCommentInput = {
    create?: XOR<comment_reactionCreateWithoutCommentInput, comment_reactionUncheckedCreateWithoutCommentInput> | comment_reactionCreateWithoutCommentInput[] | comment_reactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: comment_reactionCreateOrConnectWithoutCommentInput | comment_reactionCreateOrConnectWithoutCommentInput[]
    createMany?: comment_reactionCreateManyCommentInputEnvelope
    connect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput> | CommentCreateWithoutCommentInput[] | CommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCommentInput | CommentCreateOrConnectWithoutCommentInput[]
    createMany?: CommentCreateManyCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type comment_reactionUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<comment_reactionCreateWithoutCommentInput, comment_reactionUncheckedCreateWithoutCommentInput> | comment_reactionCreateWithoutCommentInput[] | comment_reactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: comment_reactionCreateOrConnectWithoutCommentInput | comment_reactionCreateOrConnectWithoutCommentInput[]
    createMany?: comment_reactionCreateManyCommentInputEnvelope
    connect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
  }

  export type CommentUpdateOneWithoutOther_CommentNestedInput = {
    create?: XOR<CommentCreateWithoutOther_CommentInput, CommentUncheckedCreateWithoutOther_CommentInput>
    connectOrCreate?: CommentCreateOrConnectWithoutOther_CommentInput
    upsert?: CommentUpsertWithoutOther_CommentInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutOther_CommentInput, CommentUpdateWithoutOther_CommentInput>, CommentUncheckedUpdateWithoutOther_CommentInput>
  }

  export type CommentUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput> | CommentCreateWithoutCommentInput[] | CommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCommentInput | CommentCreateOrConnectWithoutCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCommentInput | CommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentCreateManyCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCommentInput | CommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCommentInput | CommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentInput
    upsert?: PostUpsertWithoutCommentInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentInput, PostUpdateWithoutCommentInput>, PostUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateOneRequiredWithoutCommentNestedInput = {
    create?: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentInput
    upsert?: UserUpsertWithoutCommentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentInput, UserUpdateWithoutCommentInput>, UserUncheckedUpdateWithoutCommentInput>
  }

  export type comment_reactionUpdateManyWithoutCommentNestedInput = {
    create?: XOR<comment_reactionCreateWithoutCommentInput, comment_reactionUncheckedCreateWithoutCommentInput> | comment_reactionCreateWithoutCommentInput[] | comment_reactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: comment_reactionCreateOrConnectWithoutCommentInput | comment_reactionCreateOrConnectWithoutCommentInput[]
    upsert?: comment_reactionUpsertWithWhereUniqueWithoutCommentInput | comment_reactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: comment_reactionCreateManyCommentInputEnvelope
    set?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    disconnect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    delete?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    connect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    update?: comment_reactionUpdateWithWhereUniqueWithoutCommentInput | comment_reactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: comment_reactionUpdateManyWithWhereWithoutCommentInput | comment_reactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: comment_reactionScalarWhereInput | comment_reactionScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommentUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput> | CommentCreateWithoutCommentInput[] | CommentUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutCommentInput | CommentCreateOrConnectWithoutCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutCommentInput | CommentUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentCreateManyCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutCommentInput | CommentUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutCommentInput | CommentUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type comment_reactionUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<comment_reactionCreateWithoutCommentInput, comment_reactionUncheckedCreateWithoutCommentInput> | comment_reactionCreateWithoutCommentInput[] | comment_reactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: comment_reactionCreateOrConnectWithoutCommentInput | comment_reactionCreateOrConnectWithoutCommentInput[]
    upsert?: comment_reactionUpsertWithWhereUniqueWithoutCommentInput | comment_reactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: comment_reactionCreateManyCommentInputEnvelope
    set?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    disconnect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    delete?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    connect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    update?: comment_reactionUpdateWithWhereUniqueWithoutCommentInput | comment_reactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: comment_reactionUpdateManyWithWhereWithoutCommentInput | comment_reactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: comment_reactionScalarWhereInput | comment_reactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmailVerificationInput = {
    create?: XOR<UserCreateWithoutEmailVerificationInput, UserUncheckedCreateWithoutEmailVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutEmailVerificationNestedInput = {
    create?: XOR<UserCreateWithoutEmailVerificationInput, UserUncheckedCreateWithoutEmailVerificationInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailVerificationInput
    upsert?: UserUpsertWithoutEmailVerificationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailVerificationInput, UserUpdateWithoutEmailVerificationInput>, UserUncheckedUpdateWithoutEmailVerificationInput>
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutPostInput = {
    create?: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostInput
    connect?: UserWhereUniqueInput
  }

  export type TagsCreateNestedManyWithoutPostInput = {
    create?: XOR<TagsCreateWithoutPostInput, TagsUncheckedCreateWithoutPostInput> | TagsCreateWithoutPostInput[] | TagsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutPostInput | TagsCreateOrConnectWithoutPostInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type TagsUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<TagsCreateWithoutPostInput, TagsUncheckedCreateWithoutPostInput> | TagsCreateWithoutPostInput[] | TagsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutPostInput | TagsCreateOrConnectWithoutPostInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutPostNestedInput = {
    create?: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostInput
    upsert?: UserUpsertWithoutPostInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostInput, UserUpdateWithoutPostInput>, UserUncheckedUpdateWithoutPostInput>
  }

  export type TagsUpdateManyWithoutPostNestedInput = {
    create?: XOR<TagsCreateWithoutPostInput, TagsUncheckedCreateWithoutPostInput> | TagsCreateWithoutPostInput[] | TagsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutPostInput | TagsCreateOrConnectWithoutPostInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutPostInput | TagsUpsertWithWhereUniqueWithoutPostInput[]
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutPostInput | TagsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutPostInput | TagsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type TagsUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<TagsCreateWithoutPostInput, TagsUncheckedCreateWithoutPostInput> | TagsCreateWithoutPostInput[] | TagsUncheckedCreateWithoutPostInput[]
    connectOrCreate?: TagsCreateOrConnectWithoutPostInput | TagsCreateOrConnectWithoutPostInput[]
    upsert?: TagsUpsertWithWhereUniqueWithoutPostInput | TagsUpsertWithWhereUniqueWithoutPostInput[]
    set?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    disconnect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    delete?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    connect?: TagsWhereUniqueInput | TagsWhereUniqueInput[]
    update?: TagsUpdateWithWhereUniqueWithoutPostInput | TagsUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: TagsUpdateManyWithWhereWithoutPostInput | TagsUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: TagsScalarWhereInput | TagsScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokenInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutRefreshTokenNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokenInput
    upsert?: UserUpsertWithoutRefreshTokenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokenInput, UserUpdateWithoutRefreshTokenInput>, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type puzzle_gameCreateNestedManyWithoutRegionInput = {
    create?: XOR<puzzle_gameCreateWithoutRegionInput, puzzle_gameUncheckedCreateWithoutRegionInput> | puzzle_gameCreateWithoutRegionInput[] | puzzle_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutRegionInput | puzzle_gameCreateOrConnectWithoutRegionInput[]
    createMany?: puzzle_gameCreateManyRegionInputEnvelope
    connect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
  }

  export type quiz_gameCreateNestedManyWithoutRegionInput = {
    create?: XOR<quiz_gameCreateWithoutRegionInput, quiz_gameUncheckedCreateWithoutRegionInput> | quiz_gameCreateWithoutRegionInput[] | quiz_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: quiz_gameCreateOrConnectWithoutRegionInput | quiz_gameCreateOrConnectWithoutRegionInput[]
    createMany?: quiz_gameCreateManyRegionInputEnvelope
    connect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
  }

  export type treasure_gameCreateNestedManyWithoutRegionInput = {
    create?: XOR<treasure_gameCreateWithoutRegionInput, treasure_gameUncheckedCreateWithoutRegionInput> | treasure_gameCreateWithoutRegionInput[] | treasure_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: treasure_gameCreateOrConnectWithoutRegionInput | treasure_gameCreateOrConnectWithoutRegionInput[]
    createMany?: treasure_gameCreateManyRegionInputEnvelope
    connect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
  }

  export type puzzle_gameUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<puzzle_gameCreateWithoutRegionInput, puzzle_gameUncheckedCreateWithoutRegionInput> | puzzle_gameCreateWithoutRegionInput[] | puzzle_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutRegionInput | puzzle_gameCreateOrConnectWithoutRegionInput[]
    createMany?: puzzle_gameCreateManyRegionInputEnvelope
    connect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
  }

  export type quiz_gameUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<quiz_gameCreateWithoutRegionInput, quiz_gameUncheckedCreateWithoutRegionInput> | quiz_gameCreateWithoutRegionInput[] | quiz_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: quiz_gameCreateOrConnectWithoutRegionInput | quiz_gameCreateOrConnectWithoutRegionInput[]
    createMany?: quiz_gameCreateManyRegionInputEnvelope
    connect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
  }

  export type treasure_gameUncheckedCreateNestedManyWithoutRegionInput = {
    create?: XOR<treasure_gameCreateWithoutRegionInput, treasure_gameUncheckedCreateWithoutRegionInput> | treasure_gameCreateWithoutRegionInput[] | treasure_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: treasure_gameCreateOrConnectWithoutRegionInput | treasure_gameCreateOrConnectWithoutRegionInput[]
    createMany?: treasure_gameCreateManyRegionInputEnvelope
    connect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type puzzle_gameUpdateManyWithoutRegionNestedInput = {
    create?: XOR<puzzle_gameCreateWithoutRegionInput, puzzle_gameUncheckedCreateWithoutRegionInput> | puzzle_gameCreateWithoutRegionInput[] | puzzle_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutRegionInput | puzzle_gameCreateOrConnectWithoutRegionInput[]
    upsert?: puzzle_gameUpsertWithWhereUniqueWithoutRegionInput | puzzle_gameUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: puzzle_gameCreateManyRegionInputEnvelope
    set?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    disconnect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    delete?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    connect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    update?: puzzle_gameUpdateWithWhereUniqueWithoutRegionInput | puzzle_gameUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: puzzle_gameUpdateManyWithWhereWithoutRegionInput | puzzle_gameUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: puzzle_gameScalarWhereInput | puzzle_gameScalarWhereInput[]
  }

  export type quiz_gameUpdateManyWithoutRegionNestedInput = {
    create?: XOR<quiz_gameCreateWithoutRegionInput, quiz_gameUncheckedCreateWithoutRegionInput> | quiz_gameCreateWithoutRegionInput[] | quiz_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: quiz_gameCreateOrConnectWithoutRegionInput | quiz_gameCreateOrConnectWithoutRegionInput[]
    upsert?: quiz_gameUpsertWithWhereUniqueWithoutRegionInput | quiz_gameUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: quiz_gameCreateManyRegionInputEnvelope
    set?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    disconnect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    delete?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    connect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    update?: quiz_gameUpdateWithWhereUniqueWithoutRegionInput | quiz_gameUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: quiz_gameUpdateManyWithWhereWithoutRegionInput | quiz_gameUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: quiz_gameScalarWhereInput | quiz_gameScalarWhereInput[]
  }

  export type treasure_gameUpdateManyWithoutRegionNestedInput = {
    create?: XOR<treasure_gameCreateWithoutRegionInput, treasure_gameUncheckedCreateWithoutRegionInput> | treasure_gameCreateWithoutRegionInput[] | treasure_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: treasure_gameCreateOrConnectWithoutRegionInput | treasure_gameCreateOrConnectWithoutRegionInput[]
    upsert?: treasure_gameUpsertWithWhereUniqueWithoutRegionInput | treasure_gameUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: treasure_gameCreateManyRegionInputEnvelope
    set?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    disconnect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    delete?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    connect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    update?: treasure_gameUpdateWithWhereUniqueWithoutRegionInput | treasure_gameUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: treasure_gameUpdateManyWithWhereWithoutRegionInput | treasure_gameUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: treasure_gameScalarWhereInput | treasure_gameScalarWhereInput[]
  }

  export type puzzle_gameUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<puzzle_gameCreateWithoutRegionInput, puzzle_gameUncheckedCreateWithoutRegionInput> | puzzle_gameCreateWithoutRegionInput[] | puzzle_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutRegionInput | puzzle_gameCreateOrConnectWithoutRegionInput[]
    upsert?: puzzle_gameUpsertWithWhereUniqueWithoutRegionInput | puzzle_gameUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: puzzle_gameCreateManyRegionInputEnvelope
    set?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    disconnect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    delete?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    connect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    update?: puzzle_gameUpdateWithWhereUniqueWithoutRegionInput | puzzle_gameUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: puzzle_gameUpdateManyWithWhereWithoutRegionInput | puzzle_gameUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: puzzle_gameScalarWhereInput | puzzle_gameScalarWhereInput[]
  }

  export type quiz_gameUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<quiz_gameCreateWithoutRegionInput, quiz_gameUncheckedCreateWithoutRegionInput> | quiz_gameCreateWithoutRegionInput[] | quiz_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: quiz_gameCreateOrConnectWithoutRegionInput | quiz_gameCreateOrConnectWithoutRegionInput[]
    upsert?: quiz_gameUpsertWithWhereUniqueWithoutRegionInput | quiz_gameUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: quiz_gameCreateManyRegionInputEnvelope
    set?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    disconnect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    delete?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    connect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    update?: quiz_gameUpdateWithWhereUniqueWithoutRegionInput | quiz_gameUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: quiz_gameUpdateManyWithWhereWithoutRegionInput | quiz_gameUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: quiz_gameScalarWhereInput | quiz_gameScalarWhereInput[]
  }

  export type treasure_gameUncheckedUpdateManyWithoutRegionNestedInput = {
    create?: XOR<treasure_gameCreateWithoutRegionInput, treasure_gameUncheckedCreateWithoutRegionInput> | treasure_gameCreateWithoutRegionInput[] | treasure_gameUncheckedCreateWithoutRegionInput[]
    connectOrCreate?: treasure_gameCreateOrConnectWithoutRegionInput | treasure_gameCreateOrConnectWithoutRegionInput[]
    upsert?: treasure_gameUpsertWithWhereUniqueWithoutRegionInput | treasure_gameUpsertWithWhereUniqueWithoutRegionInput[]
    createMany?: treasure_gameCreateManyRegionInputEnvelope
    set?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    disconnect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    delete?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    connect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    update?: treasure_gameUpdateWithWhereUniqueWithoutRegionInput | treasure_gameUpdateWithWhereUniqueWithoutRegionInput[]
    updateMany?: treasure_gameUpdateManyWithWhereWithoutRegionInput | treasure_gameUpdateManyWithWhereWithoutRegionInput[]
    deleteMany?: treasure_gameScalarWhereInput | treasure_gameScalarWhereInput[]
  }

  export type PostCreateNestedManyWithoutTagsInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutTagsInput | PostUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutTagsInput | PostUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutTagsInput | PostUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput> | PostCreateWithoutTagsInput[] | PostUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: PostCreateOrConnectWithoutTagsInput | PostCreateOrConnectWithoutTagsInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutTagsInput | PostUpsertWithWhereUniqueWithoutTagsInput[]
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutTagsInput | PostUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: PostUpdateManyWithWhereWithoutTagsInput | PostUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type AchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EmailVerificationCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput
    connect?: EmailVerificationWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type comment_reactionCreateNestedManyWithoutUserInput = {
    create?: XOR<comment_reactionCreateWithoutUserInput, comment_reactionUncheckedCreateWithoutUserInput> | comment_reactionCreateWithoutUserInput[] | comment_reactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comment_reactionCreateOrConnectWithoutUserInput | comment_reactionCreateOrConnectWithoutUserInput[]
    createMany?: comment_reactionCreateManyUserInputEnvelope
    connect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
  }

  export type password_resetsCreateNestedManyWithoutUserInput = {
    create?: XOR<password_resetsCreateWithoutUserInput, password_resetsUncheckedCreateWithoutUserInput> | password_resetsCreateWithoutUserInput[] | password_resetsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: password_resetsCreateOrConnectWithoutUserInput | password_resetsCreateOrConnectWithoutUserInput[]
    createMany?: password_resetsCreateManyUserInputEnvelope
    connect?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
  }

  export type AchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type EmailVerificationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput
    connect?: EmailVerificationWhereUniqueInput
  }

  export type PostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type comment_reactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<comment_reactionCreateWithoutUserInput, comment_reactionUncheckedCreateWithoutUserInput> | comment_reactionCreateWithoutUserInput[] | comment_reactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comment_reactionCreateOrConnectWithoutUserInput | comment_reactionCreateOrConnectWithoutUserInput[]
    createMany?: comment_reactionCreateManyUserInputEnvelope
    connect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
  }

  export type password_resetsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<password_resetsCreateWithoutUserInput, password_resetsUncheckedCreateWithoutUserInput> | password_resetsCreateWithoutUserInput[] | password_resetsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: password_resetsCreateOrConnectWithoutUserInput | password_resetsCreateOrConnectWithoutUserInput[]
    createMany?: password_resetsCreateManyUserInputEnvelope
    connect?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type EmailVerificationUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput
    upsert?: EmailVerificationUpsertWithoutUserInput
    disconnect?: EmailVerificationWhereInput | boolean
    delete?: EmailVerificationWhereInput | boolean
    connect?: EmailVerificationWhereUniqueInput
    update?: XOR<XOR<EmailVerificationUpdateToOneWithWhereWithoutUserInput, EmailVerificationUpdateWithoutUserInput>, EmailVerificationUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type comment_reactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<comment_reactionCreateWithoutUserInput, comment_reactionUncheckedCreateWithoutUserInput> | comment_reactionCreateWithoutUserInput[] | comment_reactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comment_reactionCreateOrConnectWithoutUserInput | comment_reactionCreateOrConnectWithoutUserInput[]
    upsert?: comment_reactionUpsertWithWhereUniqueWithoutUserInput | comment_reactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comment_reactionCreateManyUserInputEnvelope
    set?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    disconnect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    delete?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    connect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    update?: comment_reactionUpdateWithWhereUniqueWithoutUserInput | comment_reactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comment_reactionUpdateManyWithWhereWithoutUserInput | comment_reactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comment_reactionScalarWhereInput | comment_reactionScalarWhereInput[]
  }

  export type password_resetsUpdateManyWithoutUserNestedInput = {
    create?: XOR<password_resetsCreateWithoutUserInput, password_resetsUncheckedCreateWithoutUserInput> | password_resetsCreateWithoutUserInput[] | password_resetsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: password_resetsCreateOrConnectWithoutUserInput | password_resetsCreateOrConnectWithoutUserInput[]
    upsert?: password_resetsUpsertWithWhereUniqueWithoutUserInput | password_resetsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: password_resetsCreateManyUserInputEnvelope
    set?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
    disconnect?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
    delete?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
    connect?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
    update?: password_resetsUpdateWithWhereUniqueWithoutUserInput | password_resetsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: password_resetsUpdateManyWithWhereWithoutUserInput | password_resetsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: password_resetsScalarWhereInput | password_resetsScalarWhereInput[]
  }

  export type AchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput> | AchievementCreateWithoutUserInput[] | AchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AchievementCreateOrConnectWithoutUserInput | AchievementCreateOrConnectWithoutUserInput[]
    upsert?: AchievementUpsertWithWhereUniqueWithoutUserInput | AchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AchievementCreateManyUserInputEnvelope
    set?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    disconnect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    delete?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    connect?: AchievementWhereUniqueInput | AchievementWhereUniqueInput[]
    update?: AchievementUpdateWithWhereUniqueWithoutUserInput | AchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AchievementUpdateManyWithWhereWithoutUserInput | AchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput> | CommentCreateWithoutUserInput[] | CommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutUserInput | CommentCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutUserInput | CommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentCreateManyUserInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutUserInput | CommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutUserInput | CommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type EmailVerificationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailVerificationCreateOrConnectWithoutUserInput
    upsert?: EmailVerificationUpsertWithoutUserInput
    disconnect?: EmailVerificationWhereInput | boolean
    delete?: EmailVerificationWhereInput | boolean
    connect?: EmailVerificationWhereUniqueInput
    update?: XOR<XOR<EmailVerificationUpdateToOneWithWhereWithoutUserInput, EmailVerificationUpdateWithoutUserInput>, EmailVerificationUncheckedUpdateWithoutUserInput>
  }

  export type PostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput> | PostCreateWithoutUserInput[] | PostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostCreateOrConnectWithoutUserInput | PostCreateOrConnectWithoutUserInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutUserInput | PostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostCreateManyUserInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutUserInput | PostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpdateManyWithWhereWithoutUserInput | PostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type comment_reactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<comment_reactionCreateWithoutUserInput, comment_reactionUncheckedCreateWithoutUserInput> | comment_reactionCreateWithoutUserInput[] | comment_reactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comment_reactionCreateOrConnectWithoutUserInput | comment_reactionCreateOrConnectWithoutUserInput[]
    upsert?: comment_reactionUpsertWithWhereUniqueWithoutUserInput | comment_reactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comment_reactionCreateManyUserInputEnvelope
    set?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    disconnect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    delete?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    connect?: comment_reactionWhereUniqueInput | comment_reactionWhereUniqueInput[]
    update?: comment_reactionUpdateWithWhereUniqueWithoutUserInput | comment_reactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comment_reactionUpdateManyWithWhereWithoutUserInput | comment_reactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comment_reactionScalarWhereInput | comment_reactionScalarWhereInput[]
  }

  export type password_resetsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<password_resetsCreateWithoutUserInput, password_resetsUncheckedCreateWithoutUserInput> | password_resetsCreateWithoutUserInput[] | password_resetsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: password_resetsCreateOrConnectWithoutUserInput | password_resetsCreateOrConnectWithoutUserInput[]
    upsert?: password_resetsUpsertWithWhereUniqueWithoutUserInput | password_resetsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: password_resetsCreateManyUserInputEnvelope
    set?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
    disconnect?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
    delete?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
    connect?: password_resetsWhereUniqueInput | password_resetsWhereUniqueInput[]
    update?: password_resetsUpdateWithWhereUniqueWithoutUserInput | password_resetsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: password_resetsUpdateManyWithWhereWithoutUserInput | password_resetsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: password_resetsScalarWhereInput | password_resetsScalarWhereInput[]
  }

  export type CommentCreateNestedOneWithoutComment_reactionInput = {
    create?: XOR<CommentCreateWithoutComment_reactionInput, CommentUncheckedCreateWithoutComment_reactionInput>
    connectOrCreate?: CommentCreateOrConnectWithoutComment_reactionInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComment_reactionInput = {
    create?: XOR<UserCreateWithoutComment_reactionInput, UserUncheckedCreateWithoutComment_reactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutComment_reactionInput
    connect?: UserWhereUniqueInput
  }

  export type Enumreaction_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.reaction_type_enum
  }

  export type CommentUpdateOneRequiredWithoutComment_reactionNestedInput = {
    create?: XOR<CommentCreateWithoutComment_reactionInput, CommentUncheckedCreateWithoutComment_reactionInput>
    connectOrCreate?: CommentCreateOrConnectWithoutComment_reactionInput
    upsert?: CommentUpsertWithoutComment_reactionInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutComment_reactionInput, CommentUpdateWithoutComment_reactionInput>, CommentUncheckedUpdateWithoutComment_reactionInput>
  }

  export type UserUpdateOneRequiredWithoutComment_reactionNestedInput = {
    create?: XOR<UserCreateWithoutComment_reactionInput, UserUncheckedCreateWithoutComment_reactionInput>
    connectOrCreate?: UserCreateOrConnectWithoutComment_reactionInput
    upsert?: UserUpsertWithoutComment_reactionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComment_reactionInput, UserUpdateWithoutComment_reactionInput>, UserUncheckedUpdateWithoutComment_reactionInput>
  }

  export type puzzle_gameCreateNestedManyWithoutGame_typeInput = {
    create?: XOR<puzzle_gameCreateWithoutGame_typeInput, puzzle_gameUncheckedCreateWithoutGame_typeInput> | puzzle_gameCreateWithoutGame_typeInput[] | puzzle_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutGame_typeInput | puzzle_gameCreateOrConnectWithoutGame_typeInput[]
    createMany?: puzzle_gameCreateManyGame_typeInputEnvelope
    connect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
  }

  export type quiz_gameCreateNestedManyWithoutGame_typeInput = {
    create?: XOR<quiz_gameCreateWithoutGame_typeInput, quiz_gameUncheckedCreateWithoutGame_typeInput> | quiz_gameCreateWithoutGame_typeInput[] | quiz_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: quiz_gameCreateOrConnectWithoutGame_typeInput | quiz_gameCreateOrConnectWithoutGame_typeInput[]
    createMany?: quiz_gameCreateManyGame_typeInputEnvelope
    connect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
  }

  export type treasure_gameCreateNestedManyWithoutGame_typeInput = {
    create?: XOR<treasure_gameCreateWithoutGame_typeInput, treasure_gameUncheckedCreateWithoutGame_typeInput> | treasure_gameCreateWithoutGame_typeInput[] | treasure_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: treasure_gameCreateOrConnectWithoutGame_typeInput | treasure_gameCreateOrConnectWithoutGame_typeInput[]
    createMany?: treasure_gameCreateManyGame_typeInputEnvelope
    connect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
  }

  export type puzzle_gameUncheckedCreateNestedManyWithoutGame_typeInput = {
    create?: XOR<puzzle_gameCreateWithoutGame_typeInput, puzzle_gameUncheckedCreateWithoutGame_typeInput> | puzzle_gameCreateWithoutGame_typeInput[] | puzzle_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutGame_typeInput | puzzle_gameCreateOrConnectWithoutGame_typeInput[]
    createMany?: puzzle_gameCreateManyGame_typeInputEnvelope
    connect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
  }

  export type quiz_gameUncheckedCreateNestedManyWithoutGame_typeInput = {
    create?: XOR<quiz_gameCreateWithoutGame_typeInput, quiz_gameUncheckedCreateWithoutGame_typeInput> | quiz_gameCreateWithoutGame_typeInput[] | quiz_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: quiz_gameCreateOrConnectWithoutGame_typeInput | quiz_gameCreateOrConnectWithoutGame_typeInput[]
    createMany?: quiz_gameCreateManyGame_typeInputEnvelope
    connect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
  }

  export type treasure_gameUncheckedCreateNestedManyWithoutGame_typeInput = {
    create?: XOR<treasure_gameCreateWithoutGame_typeInput, treasure_gameUncheckedCreateWithoutGame_typeInput> | treasure_gameCreateWithoutGame_typeInput[] | treasure_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: treasure_gameCreateOrConnectWithoutGame_typeInput | treasure_gameCreateOrConnectWithoutGame_typeInput[]
    createMany?: treasure_gameCreateManyGame_typeInputEnvelope
    connect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
  }

  export type Enumgame_code_enumFieldUpdateOperationsInput = {
    set?: $Enums.game_code_enum
  }

  export type puzzle_gameUpdateManyWithoutGame_typeNestedInput = {
    create?: XOR<puzzle_gameCreateWithoutGame_typeInput, puzzle_gameUncheckedCreateWithoutGame_typeInput> | puzzle_gameCreateWithoutGame_typeInput[] | puzzle_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutGame_typeInput | puzzle_gameCreateOrConnectWithoutGame_typeInput[]
    upsert?: puzzle_gameUpsertWithWhereUniqueWithoutGame_typeInput | puzzle_gameUpsertWithWhereUniqueWithoutGame_typeInput[]
    createMany?: puzzle_gameCreateManyGame_typeInputEnvelope
    set?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    disconnect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    delete?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    connect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    update?: puzzle_gameUpdateWithWhereUniqueWithoutGame_typeInput | puzzle_gameUpdateWithWhereUniqueWithoutGame_typeInput[]
    updateMany?: puzzle_gameUpdateManyWithWhereWithoutGame_typeInput | puzzle_gameUpdateManyWithWhereWithoutGame_typeInput[]
    deleteMany?: puzzle_gameScalarWhereInput | puzzle_gameScalarWhereInput[]
  }

  export type quiz_gameUpdateManyWithoutGame_typeNestedInput = {
    create?: XOR<quiz_gameCreateWithoutGame_typeInput, quiz_gameUncheckedCreateWithoutGame_typeInput> | quiz_gameCreateWithoutGame_typeInput[] | quiz_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: quiz_gameCreateOrConnectWithoutGame_typeInput | quiz_gameCreateOrConnectWithoutGame_typeInput[]
    upsert?: quiz_gameUpsertWithWhereUniqueWithoutGame_typeInput | quiz_gameUpsertWithWhereUniqueWithoutGame_typeInput[]
    createMany?: quiz_gameCreateManyGame_typeInputEnvelope
    set?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    disconnect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    delete?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    connect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    update?: quiz_gameUpdateWithWhereUniqueWithoutGame_typeInput | quiz_gameUpdateWithWhereUniqueWithoutGame_typeInput[]
    updateMany?: quiz_gameUpdateManyWithWhereWithoutGame_typeInput | quiz_gameUpdateManyWithWhereWithoutGame_typeInput[]
    deleteMany?: quiz_gameScalarWhereInput | quiz_gameScalarWhereInput[]
  }

  export type treasure_gameUpdateManyWithoutGame_typeNestedInput = {
    create?: XOR<treasure_gameCreateWithoutGame_typeInput, treasure_gameUncheckedCreateWithoutGame_typeInput> | treasure_gameCreateWithoutGame_typeInput[] | treasure_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: treasure_gameCreateOrConnectWithoutGame_typeInput | treasure_gameCreateOrConnectWithoutGame_typeInput[]
    upsert?: treasure_gameUpsertWithWhereUniqueWithoutGame_typeInput | treasure_gameUpsertWithWhereUniqueWithoutGame_typeInput[]
    createMany?: treasure_gameCreateManyGame_typeInputEnvelope
    set?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    disconnect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    delete?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    connect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    update?: treasure_gameUpdateWithWhereUniqueWithoutGame_typeInput | treasure_gameUpdateWithWhereUniqueWithoutGame_typeInput[]
    updateMany?: treasure_gameUpdateManyWithWhereWithoutGame_typeInput | treasure_gameUpdateManyWithWhereWithoutGame_typeInput[]
    deleteMany?: treasure_gameScalarWhereInput | treasure_gameScalarWhereInput[]
  }

  export type puzzle_gameUncheckedUpdateManyWithoutGame_typeNestedInput = {
    create?: XOR<puzzle_gameCreateWithoutGame_typeInput, puzzle_gameUncheckedCreateWithoutGame_typeInput> | puzzle_gameCreateWithoutGame_typeInput[] | puzzle_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutGame_typeInput | puzzle_gameCreateOrConnectWithoutGame_typeInput[]
    upsert?: puzzle_gameUpsertWithWhereUniqueWithoutGame_typeInput | puzzle_gameUpsertWithWhereUniqueWithoutGame_typeInput[]
    createMany?: puzzle_gameCreateManyGame_typeInputEnvelope
    set?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    disconnect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    delete?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    connect?: puzzle_gameWhereUniqueInput | puzzle_gameWhereUniqueInput[]
    update?: puzzle_gameUpdateWithWhereUniqueWithoutGame_typeInput | puzzle_gameUpdateWithWhereUniqueWithoutGame_typeInput[]
    updateMany?: puzzle_gameUpdateManyWithWhereWithoutGame_typeInput | puzzle_gameUpdateManyWithWhereWithoutGame_typeInput[]
    deleteMany?: puzzle_gameScalarWhereInput | puzzle_gameScalarWhereInput[]
  }

  export type quiz_gameUncheckedUpdateManyWithoutGame_typeNestedInput = {
    create?: XOR<quiz_gameCreateWithoutGame_typeInput, quiz_gameUncheckedCreateWithoutGame_typeInput> | quiz_gameCreateWithoutGame_typeInput[] | quiz_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: quiz_gameCreateOrConnectWithoutGame_typeInput | quiz_gameCreateOrConnectWithoutGame_typeInput[]
    upsert?: quiz_gameUpsertWithWhereUniqueWithoutGame_typeInput | quiz_gameUpsertWithWhereUniqueWithoutGame_typeInput[]
    createMany?: quiz_gameCreateManyGame_typeInputEnvelope
    set?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    disconnect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    delete?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    connect?: quiz_gameWhereUniqueInput | quiz_gameWhereUniqueInput[]
    update?: quiz_gameUpdateWithWhereUniqueWithoutGame_typeInput | quiz_gameUpdateWithWhereUniqueWithoutGame_typeInput[]
    updateMany?: quiz_gameUpdateManyWithWhereWithoutGame_typeInput | quiz_gameUpdateManyWithWhereWithoutGame_typeInput[]
    deleteMany?: quiz_gameScalarWhereInput | quiz_gameScalarWhereInput[]
  }

  export type treasure_gameUncheckedUpdateManyWithoutGame_typeNestedInput = {
    create?: XOR<treasure_gameCreateWithoutGame_typeInput, treasure_gameUncheckedCreateWithoutGame_typeInput> | treasure_gameCreateWithoutGame_typeInput[] | treasure_gameUncheckedCreateWithoutGame_typeInput[]
    connectOrCreate?: treasure_gameCreateOrConnectWithoutGame_typeInput | treasure_gameCreateOrConnectWithoutGame_typeInput[]
    upsert?: treasure_gameUpsertWithWhereUniqueWithoutGame_typeInput | treasure_gameUpsertWithWhereUniqueWithoutGame_typeInput[]
    createMany?: treasure_gameCreateManyGame_typeInputEnvelope
    set?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    disconnect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    delete?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    connect?: treasure_gameWhereUniqueInput | treasure_gameWhereUniqueInput[]
    update?: treasure_gameUpdateWithWhereUniqueWithoutGame_typeInput | treasure_gameUpdateWithWhereUniqueWithoutGame_typeInput[]
    updateMany?: treasure_gameUpdateManyWithWhereWithoutGame_typeInput | treasure_gameUpdateManyWithWhereWithoutGame_typeInput[]
    deleteMany?: treasure_gameScalarWhereInput | treasure_gameScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPassword_resetsInput = {
    create?: XOR<UserCreateWithoutPassword_resetsInput, UserUncheckedCreateWithoutPassword_resetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPassword_resetsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPassword_resetsNestedInput = {
    create?: XOR<UserCreateWithoutPassword_resetsInput, UserUncheckedCreateWithoutPassword_resetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPassword_resetsInput
    upsert?: UserUpsertWithoutPassword_resetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPassword_resetsInput, UserUpdateWithoutPassword_resetsInput>, UserUncheckedUpdateWithoutPassword_resetsInput>
  }

  export type AfterQuestionInformationCreateNestedManyWithoutPuzzle_gameInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutPuzzle_gameInput, AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput> | AfterQuestionInformationCreateWithoutPuzzle_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutPuzzle_gameInput | AfterQuestionInformationCreateOrConnectWithoutPuzzle_gameInput[]
    createMany?: AfterQuestionInformationCreateManyPuzzle_gameInputEnvelope
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
  }

  export type RegionCreateNestedOneWithoutPuzzle_gameInput = {
    create?: XOR<RegionCreateWithoutPuzzle_gameInput, RegionUncheckedCreateWithoutPuzzle_gameInput>
    connectOrCreate?: RegionCreateOrConnectWithoutPuzzle_gameInput
    connect?: RegionWhereUniqueInput
  }

  export type game_typeCreateNestedOneWithoutPuzzle_gameInput = {
    create?: XOR<game_typeCreateWithoutPuzzle_gameInput, game_typeUncheckedCreateWithoutPuzzle_gameInput>
    connectOrCreate?: game_typeCreateOrConnectWithoutPuzzle_gameInput
    connect?: game_typeWhereUniqueInput
  }

  export type puzzle_piecesCreateNestedManyWithoutPuzzle_gameInput = {
    create?: XOR<puzzle_piecesCreateWithoutPuzzle_gameInput, puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput> | puzzle_piecesCreateWithoutPuzzle_gameInput[] | puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput[]
    connectOrCreate?: puzzle_piecesCreateOrConnectWithoutPuzzle_gameInput | puzzle_piecesCreateOrConnectWithoutPuzzle_gameInput[]
    createMany?: puzzle_piecesCreateManyPuzzle_gameInputEnvelope
    connect?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
  }

  export type AfterQuestionInformationUncheckedCreateNestedManyWithoutPuzzle_gameInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutPuzzle_gameInput, AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput> | AfterQuestionInformationCreateWithoutPuzzle_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutPuzzle_gameInput | AfterQuestionInformationCreateOrConnectWithoutPuzzle_gameInput[]
    createMany?: AfterQuestionInformationCreateManyPuzzle_gameInputEnvelope
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
  }

  export type puzzle_piecesUncheckedCreateNestedManyWithoutPuzzle_gameInput = {
    create?: XOR<puzzle_piecesCreateWithoutPuzzle_gameInput, puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput> | puzzle_piecesCreateWithoutPuzzle_gameInput[] | puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput[]
    connectOrCreate?: puzzle_piecesCreateOrConnectWithoutPuzzle_gameInput | puzzle_piecesCreateOrConnectWithoutPuzzle_gameInput[]
    createMany?: puzzle_piecesCreateManyPuzzle_gameInputEnvelope
    connect?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
  }

  export type AfterQuestionInformationUpdateManyWithoutPuzzle_gameNestedInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutPuzzle_gameInput, AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput> | AfterQuestionInformationCreateWithoutPuzzle_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutPuzzle_gameInput | AfterQuestionInformationCreateOrConnectWithoutPuzzle_gameInput[]
    upsert?: AfterQuestionInformationUpsertWithWhereUniqueWithoutPuzzle_gameInput | AfterQuestionInformationUpsertWithWhereUniqueWithoutPuzzle_gameInput[]
    createMany?: AfterQuestionInformationCreateManyPuzzle_gameInputEnvelope
    set?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    disconnect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    delete?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    update?: AfterQuestionInformationUpdateWithWhereUniqueWithoutPuzzle_gameInput | AfterQuestionInformationUpdateWithWhereUniqueWithoutPuzzle_gameInput[]
    updateMany?: AfterQuestionInformationUpdateManyWithWhereWithoutPuzzle_gameInput | AfterQuestionInformationUpdateManyWithWhereWithoutPuzzle_gameInput[]
    deleteMany?: AfterQuestionInformationScalarWhereInput | AfterQuestionInformationScalarWhereInput[]
  }

  export type RegionUpdateOneWithoutPuzzle_gameNestedInput = {
    create?: XOR<RegionCreateWithoutPuzzle_gameInput, RegionUncheckedCreateWithoutPuzzle_gameInput>
    connectOrCreate?: RegionCreateOrConnectWithoutPuzzle_gameInput
    upsert?: RegionUpsertWithoutPuzzle_gameInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutPuzzle_gameInput, RegionUpdateWithoutPuzzle_gameInput>, RegionUncheckedUpdateWithoutPuzzle_gameInput>
  }

  export type game_typeUpdateOneWithoutPuzzle_gameNestedInput = {
    create?: XOR<game_typeCreateWithoutPuzzle_gameInput, game_typeUncheckedCreateWithoutPuzzle_gameInput>
    connectOrCreate?: game_typeCreateOrConnectWithoutPuzzle_gameInput
    upsert?: game_typeUpsertWithoutPuzzle_gameInput
    disconnect?: game_typeWhereInput | boolean
    delete?: game_typeWhereInput | boolean
    connect?: game_typeWhereUniqueInput
    update?: XOR<XOR<game_typeUpdateToOneWithWhereWithoutPuzzle_gameInput, game_typeUpdateWithoutPuzzle_gameInput>, game_typeUncheckedUpdateWithoutPuzzle_gameInput>
  }

  export type puzzle_piecesUpdateManyWithoutPuzzle_gameNestedInput = {
    create?: XOR<puzzle_piecesCreateWithoutPuzzle_gameInput, puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput> | puzzle_piecesCreateWithoutPuzzle_gameInput[] | puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput[]
    connectOrCreate?: puzzle_piecesCreateOrConnectWithoutPuzzle_gameInput | puzzle_piecesCreateOrConnectWithoutPuzzle_gameInput[]
    upsert?: puzzle_piecesUpsertWithWhereUniqueWithoutPuzzle_gameInput | puzzle_piecesUpsertWithWhereUniqueWithoutPuzzle_gameInput[]
    createMany?: puzzle_piecesCreateManyPuzzle_gameInputEnvelope
    set?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
    disconnect?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
    delete?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
    connect?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
    update?: puzzle_piecesUpdateWithWhereUniqueWithoutPuzzle_gameInput | puzzle_piecesUpdateWithWhereUniqueWithoutPuzzle_gameInput[]
    updateMany?: puzzle_piecesUpdateManyWithWhereWithoutPuzzle_gameInput | puzzle_piecesUpdateManyWithWhereWithoutPuzzle_gameInput[]
    deleteMany?: puzzle_piecesScalarWhereInput | puzzle_piecesScalarWhereInput[]
  }

  export type AfterQuestionInformationUncheckedUpdateManyWithoutPuzzle_gameNestedInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutPuzzle_gameInput, AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput> | AfterQuestionInformationCreateWithoutPuzzle_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutPuzzle_gameInput | AfterQuestionInformationCreateOrConnectWithoutPuzzle_gameInput[]
    upsert?: AfterQuestionInformationUpsertWithWhereUniqueWithoutPuzzle_gameInput | AfterQuestionInformationUpsertWithWhereUniqueWithoutPuzzle_gameInput[]
    createMany?: AfterQuestionInformationCreateManyPuzzle_gameInputEnvelope
    set?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    disconnect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    delete?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    update?: AfterQuestionInformationUpdateWithWhereUniqueWithoutPuzzle_gameInput | AfterQuestionInformationUpdateWithWhereUniqueWithoutPuzzle_gameInput[]
    updateMany?: AfterQuestionInformationUpdateManyWithWhereWithoutPuzzle_gameInput | AfterQuestionInformationUpdateManyWithWhereWithoutPuzzle_gameInput[]
    deleteMany?: AfterQuestionInformationScalarWhereInput | AfterQuestionInformationScalarWhereInput[]
  }

  export type puzzle_piecesUncheckedUpdateManyWithoutPuzzle_gameNestedInput = {
    create?: XOR<puzzle_piecesCreateWithoutPuzzle_gameInput, puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput> | puzzle_piecesCreateWithoutPuzzle_gameInput[] | puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput[]
    connectOrCreate?: puzzle_piecesCreateOrConnectWithoutPuzzle_gameInput | puzzle_piecesCreateOrConnectWithoutPuzzle_gameInput[]
    upsert?: puzzle_piecesUpsertWithWhereUniqueWithoutPuzzle_gameInput | puzzle_piecesUpsertWithWhereUniqueWithoutPuzzle_gameInput[]
    createMany?: puzzle_piecesCreateManyPuzzle_gameInputEnvelope
    set?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
    disconnect?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
    delete?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
    connect?: puzzle_piecesWhereUniqueInput | puzzle_piecesWhereUniqueInput[]
    update?: puzzle_piecesUpdateWithWhereUniqueWithoutPuzzle_gameInput | puzzle_piecesUpdateWithWhereUniqueWithoutPuzzle_gameInput[]
    updateMany?: puzzle_piecesUpdateManyWithWhereWithoutPuzzle_gameInput | puzzle_piecesUpdateManyWithWhereWithoutPuzzle_gameInput[]
    deleteMany?: puzzle_piecesScalarWhereInput | puzzle_piecesScalarWhereInput[]
  }

  export type puzzle_gameCreateNestedOneWithoutPuzzle_piecesInput = {
    create?: XOR<puzzle_gameCreateWithoutPuzzle_piecesInput, puzzle_gameUncheckedCreateWithoutPuzzle_piecesInput>
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutPuzzle_piecesInput
    connect?: puzzle_gameWhereUniqueInput
  }

  export type puzzle_gameUpdateOneWithoutPuzzle_piecesNestedInput = {
    create?: XOR<puzzle_gameCreateWithoutPuzzle_piecesInput, puzzle_gameUncheckedCreateWithoutPuzzle_piecesInput>
    connectOrCreate?: puzzle_gameCreateOrConnectWithoutPuzzle_piecesInput
    upsert?: puzzle_gameUpsertWithoutPuzzle_piecesInput
    disconnect?: puzzle_gameWhereInput | boolean
    delete?: puzzle_gameWhereInput | boolean
    connect?: puzzle_gameWhereUniqueInput
    update?: XOR<XOR<puzzle_gameUpdateToOneWithWhereWithoutPuzzle_piecesInput, puzzle_gameUpdateWithoutPuzzle_piecesInput>, puzzle_gameUncheckedUpdateWithoutPuzzle_piecesInput>
  }

  export type AfterQuestionInformationCreateNestedManyWithoutQuiz_gameInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutQuiz_gameInput, AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput> | AfterQuestionInformationCreateWithoutQuiz_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutQuiz_gameInput | AfterQuestionInformationCreateOrConnectWithoutQuiz_gameInput[]
    createMany?: AfterQuestionInformationCreateManyQuiz_gameInputEnvelope
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
  }

  export type game_typeCreateNestedOneWithoutQuiz_gameInput = {
    create?: XOR<game_typeCreateWithoutQuiz_gameInput, game_typeUncheckedCreateWithoutQuiz_gameInput>
    connectOrCreate?: game_typeCreateOrConnectWithoutQuiz_gameInput
    connect?: game_typeWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutQuiz_gameInput = {
    create?: XOR<RegionCreateWithoutQuiz_gameInput, RegionUncheckedCreateWithoutQuiz_gameInput>
    connectOrCreate?: RegionCreateOrConnectWithoutQuiz_gameInput
    connect?: RegionWhereUniqueInput
  }

  export type quiz_game_qaCreateNestedManyWithoutQuiz_gameInput = {
    create?: XOR<quiz_game_qaCreateWithoutQuiz_gameInput, quiz_game_qaUncheckedCreateWithoutQuiz_gameInput> | quiz_game_qaCreateWithoutQuiz_gameInput[] | quiz_game_qaUncheckedCreateWithoutQuiz_gameInput[]
    connectOrCreate?: quiz_game_qaCreateOrConnectWithoutQuiz_gameInput | quiz_game_qaCreateOrConnectWithoutQuiz_gameInput[]
    createMany?: quiz_game_qaCreateManyQuiz_gameInputEnvelope
    connect?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
  }

  export type AfterQuestionInformationUncheckedCreateNestedManyWithoutQuiz_gameInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutQuiz_gameInput, AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput> | AfterQuestionInformationCreateWithoutQuiz_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutQuiz_gameInput | AfterQuestionInformationCreateOrConnectWithoutQuiz_gameInput[]
    createMany?: AfterQuestionInformationCreateManyQuiz_gameInputEnvelope
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
  }

  export type quiz_game_qaUncheckedCreateNestedManyWithoutQuiz_gameInput = {
    create?: XOR<quiz_game_qaCreateWithoutQuiz_gameInput, quiz_game_qaUncheckedCreateWithoutQuiz_gameInput> | quiz_game_qaCreateWithoutQuiz_gameInput[] | quiz_game_qaUncheckedCreateWithoutQuiz_gameInput[]
    connectOrCreate?: quiz_game_qaCreateOrConnectWithoutQuiz_gameInput | quiz_game_qaCreateOrConnectWithoutQuiz_gameInput[]
    createMany?: quiz_game_qaCreateManyQuiz_gameInputEnvelope
    connect?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
  }

  export type AfterQuestionInformationUpdateManyWithoutQuiz_gameNestedInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutQuiz_gameInput, AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput> | AfterQuestionInformationCreateWithoutQuiz_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutQuiz_gameInput | AfterQuestionInformationCreateOrConnectWithoutQuiz_gameInput[]
    upsert?: AfterQuestionInformationUpsertWithWhereUniqueWithoutQuiz_gameInput | AfterQuestionInformationUpsertWithWhereUniqueWithoutQuiz_gameInput[]
    createMany?: AfterQuestionInformationCreateManyQuiz_gameInputEnvelope
    set?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    disconnect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    delete?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    update?: AfterQuestionInformationUpdateWithWhereUniqueWithoutQuiz_gameInput | AfterQuestionInformationUpdateWithWhereUniqueWithoutQuiz_gameInput[]
    updateMany?: AfterQuestionInformationUpdateManyWithWhereWithoutQuiz_gameInput | AfterQuestionInformationUpdateManyWithWhereWithoutQuiz_gameInput[]
    deleteMany?: AfterQuestionInformationScalarWhereInput | AfterQuestionInformationScalarWhereInput[]
  }

  export type game_typeUpdateOneWithoutQuiz_gameNestedInput = {
    create?: XOR<game_typeCreateWithoutQuiz_gameInput, game_typeUncheckedCreateWithoutQuiz_gameInput>
    connectOrCreate?: game_typeCreateOrConnectWithoutQuiz_gameInput
    upsert?: game_typeUpsertWithoutQuiz_gameInput
    disconnect?: game_typeWhereInput | boolean
    delete?: game_typeWhereInput | boolean
    connect?: game_typeWhereUniqueInput
    update?: XOR<XOR<game_typeUpdateToOneWithWhereWithoutQuiz_gameInput, game_typeUpdateWithoutQuiz_gameInput>, game_typeUncheckedUpdateWithoutQuiz_gameInput>
  }

  export type RegionUpdateOneWithoutQuiz_gameNestedInput = {
    create?: XOR<RegionCreateWithoutQuiz_gameInput, RegionUncheckedCreateWithoutQuiz_gameInput>
    connectOrCreate?: RegionCreateOrConnectWithoutQuiz_gameInput
    upsert?: RegionUpsertWithoutQuiz_gameInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutQuiz_gameInput, RegionUpdateWithoutQuiz_gameInput>, RegionUncheckedUpdateWithoutQuiz_gameInput>
  }

  export type quiz_game_qaUpdateManyWithoutQuiz_gameNestedInput = {
    create?: XOR<quiz_game_qaCreateWithoutQuiz_gameInput, quiz_game_qaUncheckedCreateWithoutQuiz_gameInput> | quiz_game_qaCreateWithoutQuiz_gameInput[] | quiz_game_qaUncheckedCreateWithoutQuiz_gameInput[]
    connectOrCreate?: quiz_game_qaCreateOrConnectWithoutQuiz_gameInput | quiz_game_qaCreateOrConnectWithoutQuiz_gameInput[]
    upsert?: quiz_game_qaUpsertWithWhereUniqueWithoutQuiz_gameInput | quiz_game_qaUpsertWithWhereUniqueWithoutQuiz_gameInput[]
    createMany?: quiz_game_qaCreateManyQuiz_gameInputEnvelope
    set?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
    disconnect?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
    delete?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
    connect?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
    update?: quiz_game_qaUpdateWithWhereUniqueWithoutQuiz_gameInput | quiz_game_qaUpdateWithWhereUniqueWithoutQuiz_gameInput[]
    updateMany?: quiz_game_qaUpdateManyWithWhereWithoutQuiz_gameInput | quiz_game_qaUpdateManyWithWhereWithoutQuiz_gameInput[]
    deleteMany?: quiz_game_qaScalarWhereInput | quiz_game_qaScalarWhereInput[]
  }

  export type AfterQuestionInformationUncheckedUpdateManyWithoutQuiz_gameNestedInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutQuiz_gameInput, AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput> | AfterQuestionInformationCreateWithoutQuiz_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutQuiz_gameInput | AfterQuestionInformationCreateOrConnectWithoutQuiz_gameInput[]
    upsert?: AfterQuestionInformationUpsertWithWhereUniqueWithoutQuiz_gameInput | AfterQuestionInformationUpsertWithWhereUniqueWithoutQuiz_gameInput[]
    createMany?: AfterQuestionInformationCreateManyQuiz_gameInputEnvelope
    set?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    disconnect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    delete?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    update?: AfterQuestionInformationUpdateWithWhereUniqueWithoutQuiz_gameInput | AfterQuestionInformationUpdateWithWhereUniqueWithoutQuiz_gameInput[]
    updateMany?: AfterQuestionInformationUpdateManyWithWhereWithoutQuiz_gameInput | AfterQuestionInformationUpdateManyWithWhereWithoutQuiz_gameInput[]
    deleteMany?: AfterQuestionInformationScalarWhereInput | AfterQuestionInformationScalarWhereInput[]
  }

  export type quiz_game_qaUncheckedUpdateManyWithoutQuiz_gameNestedInput = {
    create?: XOR<quiz_game_qaCreateWithoutQuiz_gameInput, quiz_game_qaUncheckedCreateWithoutQuiz_gameInput> | quiz_game_qaCreateWithoutQuiz_gameInput[] | quiz_game_qaUncheckedCreateWithoutQuiz_gameInput[]
    connectOrCreate?: quiz_game_qaCreateOrConnectWithoutQuiz_gameInput | quiz_game_qaCreateOrConnectWithoutQuiz_gameInput[]
    upsert?: quiz_game_qaUpsertWithWhereUniqueWithoutQuiz_gameInput | quiz_game_qaUpsertWithWhereUniqueWithoutQuiz_gameInput[]
    createMany?: quiz_game_qaCreateManyQuiz_gameInputEnvelope
    set?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
    disconnect?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
    delete?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
    connect?: quiz_game_qaWhereUniqueInput | quiz_game_qaWhereUniqueInput[]
    update?: quiz_game_qaUpdateWithWhereUniqueWithoutQuiz_gameInput | quiz_game_qaUpdateWithWhereUniqueWithoutQuiz_gameInput[]
    updateMany?: quiz_game_qaUpdateManyWithWhereWithoutQuiz_gameInput | quiz_game_qaUpdateManyWithWhereWithoutQuiz_gameInput[]
    deleteMany?: quiz_game_qaScalarWhereInput | quiz_game_qaScalarWhereInput[]
  }

  export type quiz_gameCreateNestedOneWithoutQuiz_game_qaInput = {
    create?: XOR<quiz_gameCreateWithoutQuiz_game_qaInput, quiz_gameUncheckedCreateWithoutQuiz_game_qaInput>
    connectOrCreate?: quiz_gameCreateOrConnectWithoutQuiz_game_qaInput
    connect?: quiz_gameWhereUniqueInput
  }

  export type quiz_gameUpdateOneWithoutQuiz_game_qaNestedInput = {
    create?: XOR<quiz_gameCreateWithoutQuiz_game_qaInput, quiz_gameUncheckedCreateWithoutQuiz_game_qaInput>
    connectOrCreate?: quiz_gameCreateOrConnectWithoutQuiz_game_qaInput
    upsert?: quiz_gameUpsertWithoutQuiz_game_qaInput
    disconnect?: quiz_gameWhereInput | boolean
    delete?: quiz_gameWhereInput | boolean
    connect?: quiz_gameWhereUniqueInput
    update?: XOR<XOR<quiz_gameUpdateToOneWithWhereWithoutQuiz_game_qaInput, quiz_gameUpdateWithoutQuiz_game_qaInput>, quiz_gameUncheckedUpdateWithoutQuiz_game_qaInput>
  }

  export type treasure_gameCreateNestedOneWithoutTreasure_connection_cardsInput = {
    create?: XOR<treasure_gameCreateWithoutTreasure_connection_cardsInput, treasure_gameUncheckedCreateWithoutTreasure_connection_cardsInput>
    connectOrCreate?: treasure_gameCreateOrConnectWithoutTreasure_connection_cardsInput
    connect?: treasure_gameWhereUniqueInput
  }

  export type Enumcard_type_enumFieldUpdateOperationsInput = {
    set?: $Enums.card_type_enum
  }

  export type treasure_gameUpdateOneWithoutTreasure_connection_cardsNestedInput = {
    create?: XOR<treasure_gameCreateWithoutTreasure_connection_cardsInput, treasure_gameUncheckedCreateWithoutTreasure_connection_cardsInput>
    connectOrCreate?: treasure_gameCreateOrConnectWithoutTreasure_connection_cardsInput
    upsert?: treasure_gameUpsertWithoutTreasure_connection_cardsInput
    disconnect?: treasure_gameWhereInput | boolean
    delete?: treasure_gameWhereInput | boolean
    connect?: treasure_gameWhereUniqueInput
    update?: XOR<XOR<treasure_gameUpdateToOneWithWhereWithoutTreasure_connection_cardsInput, treasure_gameUpdateWithoutTreasure_connection_cardsInput>, treasure_gameUncheckedUpdateWithoutTreasure_connection_cardsInput>
  }

  export type AfterQuestionInformationCreateNestedManyWithoutTreasure_gameInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutTreasure_gameInput, AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput> | AfterQuestionInformationCreateWithoutTreasure_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutTreasure_gameInput | AfterQuestionInformationCreateOrConnectWithoutTreasure_gameInput[]
    createMany?: AfterQuestionInformationCreateManyTreasure_gameInputEnvelope
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
  }

  export type treasure_connection_cardsCreateNestedManyWithoutTreasure_gameInput = {
    create?: XOR<treasure_connection_cardsCreateWithoutTreasure_gameInput, treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput> | treasure_connection_cardsCreateWithoutTreasure_gameInput[] | treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput[]
    connectOrCreate?: treasure_connection_cardsCreateOrConnectWithoutTreasure_gameInput | treasure_connection_cardsCreateOrConnectWithoutTreasure_gameInput[]
    createMany?: treasure_connection_cardsCreateManyTreasure_gameInputEnvelope
    connect?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
  }

  export type game_typeCreateNestedOneWithoutTreasure_gameInput = {
    create?: XOR<game_typeCreateWithoutTreasure_gameInput, game_typeUncheckedCreateWithoutTreasure_gameInput>
    connectOrCreate?: game_typeCreateOrConnectWithoutTreasure_gameInput
    connect?: game_typeWhereUniqueInput
  }

  export type RegionCreateNestedOneWithoutTreasure_gameInput = {
    create?: XOR<RegionCreateWithoutTreasure_gameInput, RegionUncheckedCreateWithoutTreasure_gameInput>
    connectOrCreate?: RegionCreateOrConnectWithoutTreasure_gameInput
    connect?: RegionWhereUniqueInput
  }

  export type AfterQuestionInformationUncheckedCreateNestedManyWithoutTreasure_gameInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutTreasure_gameInput, AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput> | AfterQuestionInformationCreateWithoutTreasure_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutTreasure_gameInput | AfterQuestionInformationCreateOrConnectWithoutTreasure_gameInput[]
    createMany?: AfterQuestionInformationCreateManyTreasure_gameInputEnvelope
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
  }

  export type treasure_connection_cardsUncheckedCreateNestedManyWithoutTreasure_gameInput = {
    create?: XOR<treasure_connection_cardsCreateWithoutTreasure_gameInput, treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput> | treasure_connection_cardsCreateWithoutTreasure_gameInput[] | treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput[]
    connectOrCreate?: treasure_connection_cardsCreateOrConnectWithoutTreasure_gameInput | treasure_connection_cardsCreateOrConnectWithoutTreasure_gameInput[]
    createMany?: treasure_connection_cardsCreateManyTreasure_gameInputEnvelope
    connect?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
  }

  export type AfterQuestionInformationUpdateManyWithoutTreasure_gameNestedInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutTreasure_gameInput, AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput> | AfterQuestionInformationCreateWithoutTreasure_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutTreasure_gameInput | AfterQuestionInformationCreateOrConnectWithoutTreasure_gameInput[]
    upsert?: AfterQuestionInformationUpsertWithWhereUniqueWithoutTreasure_gameInput | AfterQuestionInformationUpsertWithWhereUniqueWithoutTreasure_gameInput[]
    createMany?: AfterQuestionInformationCreateManyTreasure_gameInputEnvelope
    set?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    disconnect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    delete?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    update?: AfterQuestionInformationUpdateWithWhereUniqueWithoutTreasure_gameInput | AfterQuestionInformationUpdateWithWhereUniqueWithoutTreasure_gameInput[]
    updateMany?: AfterQuestionInformationUpdateManyWithWhereWithoutTreasure_gameInput | AfterQuestionInformationUpdateManyWithWhereWithoutTreasure_gameInput[]
    deleteMany?: AfterQuestionInformationScalarWhereInput | AfterQuestionInformationScalarWhereInput[]
  }

  export type treasure_connection_cardsUpdateManyWithoutTreasure_gameNestedInput = {
    create?: XOR<treasure_connection_cardsCreateWithoutTreasure_gameInput, treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput> | treasure_connection_cardsCreateWithoutTreasure_gameInput[] | treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput[]
    connectOrCreate?: treasure_connection_cardsCreateOrConnectWithoutTreasure_gameInput | treasure_connection_cardsCreateOrConnectWithoutTreasure_gameInput[]
    upsert?: treasure_connection_cardsUpsertWithWhereUniqueWithoutTreasure_gameInput | treasure_connection_cardsUpsertWithWhereUniqueWithoutTreasure_gameInput[]
    createMany?: treasure_connection_cardsCreateManyTreasure_gameInputEnvelope
    set?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
    disconnect?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
    delete?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
    connect?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
    update?: treasure_connection_cardsUpdateWithWhereUniqueWithoutTreasure_gameInput | treasure_connection_cardsUpdateWithWhereUniqueWithoutTreasure_gameInput[]
    updateMany?: treasure_connection_cardsUpdateManyWithWhereWithoutTreasure_gameInput | treasure_connection_cardsUpdateManyWithWhereWithoutTreasure_gameInput[]
    deleteMany?: treasure_connection_cardsScalarWhereInput | treasure_connection_cardsScalarWhereInput[]
  }

  export type game_typeUpdateOneWithoutTreasure_gameNestedInput = {
    create?: XOR<game_typeCreateWithoutTreasure_gameInput, game_typeUncheckedCreateWithoutTreasure_gameInput>
    connectOrCreate?: game_typeCreateOrConnectWithoutTreasure_gameInput
    upsert?: game_typeUpsertWithoutTreasure_gameInput
    disconnect?: game_typeWhereInput | boolean
    delete?: game_typeWhereInput | boolean
    connect?: game_typeWhereUniqueInput
    update?: XOR<XOR<game_typeUpdateToOneWithWhereWithoutTreasure_gameInput, game_typeUpdateWithoutTreasure_gameInput>, game_typeUncheckedUpdateWithoutTreasure_gameInput>
  }

  export type RegionUpdateOneWithoutTreasure_gameNestedInput = {
    create?: XOR<RegionCreateWithoutTreasure_gameInput, RegionUncheckedCreateWithoutTreasure_gameInput>
    connectOrCreate?: RegionCreateOrConnectWithoutTreasure_gameInput
    upsert?: RegionUpsertWithoutTreasure_gameInput
    disconnect?: RegionWhereInput | boolean
    delete?: RegionWhereInput | boolean
    connect?: RegionWhereUniqueInput
    update?: XOR<XOR<RegionUpdateToOneWithWhereWithoutTreasure_gameInput, RegionUpdateWithoutTreasure_gameInput>, RegionUncheckedUpdateWithoutTreasure_gameInput>
  }

  export type AfterQuestionInformationUncheckedUpdateManyWithoutTreasure_gameNestedInput = {
    create?: XOR<AfterQuestionInformationCreateWithoutTreasure_gameInput, AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput> | AfterQuestionInformationCreateWithoutTreasure_gameInput[] | AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput[]
    connectOrCreate?: AfterQuestionInformationCreateOrConnectWithoutTreasure_gameInput | AfterQuestionInformationCreateOrConnectWithoutTreasure_gameInput[]
    upsert?: AfterQuestionInformationUpsertWithWhereUniqueWithoutTreasure_gameInput | AfterQuestionInformationUpsertWithWhereUniqueWithoutTreasure_gameInput[]
    createMany?: AfterQuestionInformationCreateManyTreasure_gameInputEnvelope
    set?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    disconnect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    delete?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    connect?: AfterQuestionInformationWhereUniqueInput | AfterQuestionInformationWhereUniqueInput[]
    update?: AfterQuestionInformationUpdateWithWhereUniqueWithoutTreasure_gameInput | AfterQuestionInformationUpdateWithWhereUniqueWithoutTreasure_gameInput[]
    updateMany?: AfterQuestionInformationUpdateManyWithWhereWithoutTreasure_gameInput | AfterQuestionInformationUpdateManyWithWhereWithoutTreasure_gameInput[]
    deleteMany?: AfterQuestionInformationScalarWhereInput | AfterQuestionInformationScalarWhereInput[]
  }

  export type treasure_connection_cardsUncheckedUpdateManyWithoutTreasure_gameNestedInput = {
    create?: XOR<treasure_connection_cardsCreateWithoutTreasure_gameInput, treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput> | treasure_connection_cardsCreateWithoutTreasure_gameInput[] | treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput[]
    connectOrCreate?: treasure_connection_cardsCreateOrConnectWithoutTreasure_gameInput | treasure_connection_cardsCreateOrConnectWithoutTreasure_gameInput[]
    upsert?: treasure_connection_cardsUpsertWithWhereUniqueWithoutTreasure_gameInput | treasure_connection_cardsUpsertWithWhereUniqueWithoutTreasure_gameInput[]
    createMany?: treasure_connection_cardsCreateManyTreasure_gameInputEnvelope
    set?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
    disconnect?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
    delete?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
    connect?: treasure_connection_cardsWhereUniqueInput | treasure_connection_cardsWhereUniqueInput[]
    update?: treasure_connection_cardsUpdateWithWhereUniqueWithoutTreasure_gameInput | treasure_connection_cardsUpdateWithWhereUniqueWithoutTreasure_gameInput[]
    updateMany?: treasure_connection_cardsUpdateManyWithWhereWithoutTreasure_gameInput | treasure_connection_cardsUpdateManyWithWhereWithoutTreasure_gameInput[]
    deleteMany?: treasure_connection_cardsScalarWhereInput | treasure_connection_cardsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumreaction_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.reaction_type_enum | Enumreaction_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.reaction_type_enum[] | ListEnumreaction_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.reaction_type_enum[] | ListEnumreaction_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumreaction_type_enumFilter<$PrismaModel> | $Enums.reaction_type_enum
  }

  export type NestedEnumreaction_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.reaction_type_enum | Enumreaction_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.reaction_type_enum[] | ListEnumreaction_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.reaction_type_enum[] | ListEnumreaction_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumreaction_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.reaction_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumreaction_type_enumFilter<$PrismaModel>
    _max?: NestedEnumreaction_type_enumFilter<$PrismaModel>
  }

  export type NestedEnumgame_code_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.game_code_enum | Enumgame_code_enumFieldRefInput<$PrismaModel>
    in?: $Enums.game_code_enum[] | ListEnumgame_code_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.game_code_enum[] | ListEnumgame_code_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumgame_code_enumFilter<$PrismaModel> | $Enums.game_code_enum
  }

  export type NestedEnumgame_code_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.game_code_enum | Enumgame_code_enumFieldRefInput<$PrismaModel>
    in?: $Enums.game_code_enum[] | ListEnumgame_code_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.game_code_enum[] | ListEnumgame_code_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumgame_code_enumWithAggregatesFilter<$PrismaModel> | $Enums.game_code_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumgame_code_enumFilter<$PrismaModel>
    _max?: NestedEnumgame_code_enumFilter<$PrismaModel>
  }

  export type NestedEnumcard_type_enumFilter<$PrismaModel = never> = {
    equals?: $Enums.card_type_enum | Enumcard_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.card_type_enum[] | ListEnumcard_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.card_type_enum[] | ListEnumcard_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumcard_type_enumFilter<$PrismaModel> | $Enums.card_type_enum
  }

  export type NestedEnumcard_type_enumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.card_type_enum | Enumcard_type_enumFieldRefInput<$PrismaModel>
    in?: $Enums.card_type_enum[] | ListEnumcard_type_enumFieldRefInput<$PrismaModel>
    notIn?: $Enums.card_type_enum[] | ListEnumcard_type_enumFieldRefInput<$PrismaModel>
    not?: NestedEnumcard_type_enumWithAggregatesFilter<$PrismaModel> | $Enums.card_type_enum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcard_type_enumFilter<$PrismaModel>
    _max?: NestedEnumcard_type_enumFilter<$PrismaModel>
  }

  export type UserCreateWithoutAchievementInput = {
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Comment?: CommentCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutUserInput
    password_resets?: password_resetsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAchievementInput = {
    id?: number
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutUserInput
    password_resets?: password_resetsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAchievementInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementInput, UserUncheckedCreateWithoutAchievementInput>
  }

  export type UserUpsertWithoutAchievementInput = {
    update: XOR<UserUpdateWithoutAchievementInput, UserUncheckedUpdateWithoutAchievementInput>
    create: XOR<UserCreateWithoutAchievementInput, UserUncheckedCreateWithoutAchievementInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementInput, UserUncheckedUpdateWithoutAchievementInput>
  }

  export type UserUpdateWithoutAchievementInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Comment?: CommentUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type puzzle_gameCreateWithoutAfterQuestionInformationInput = {
    imageurl?: string | null
    Region?: RegionCreateNestedOneWithoutPuzzle_gameInput
    game_type?: game_typeCreateNestedOneWithoutPuzzle_gameInput
    puzzle_pieces?: puzzle_piecesCreateNestedManyWithoutPuzzle_gameInput
  }

  export type puzzle_gameUncheckedCreateWithoutAfterQuestionInformationInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    imageurl?: string | null
    puzzle_pieces?: puzzle_piecesUncheckedCreateNestedManyWithoutPuzzle_gameInput
  }

  export type puzzle_gameCreateOrConnectWithoutAfterQuestionInformationInput = {
    where: puzzle_gameWhereUniqueInput
    create: XOR<puzzle_gameCreateWithoutAfterQuestionInformationInput, puzzle_gameUncheckedCreateWithoutAfterQuestionInformationInput>
  }

  export type quiz_gameCreateWithoutAfterQuestionInformationInput = {
    title: string
    description?: string | null
    game_type?: game_typeCreateNestedOneWithoutQuiz_gameInput
    Region?: RegionCreateNestedOneWithoutQuiz_gameInput
    quiz_game_qa?: quiz_game_qaCreateNestedManyWithoutQuiz_gameInput
  }

  export type quiz_gameUncheckedCreateWithoutAfterQuestionInformationInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    title: string
    description?: string | null
    quiz_game_qa?: quiz_game_qaUncheckedCreateNestedManyWithoutQuiz_gameInput
  }

  export type quiz_gameCreateOrConnectWithoutAfterQuestionInformationInput = {
    where: quiz_gameWhereUniqueInput
    create: XOR<quiz_gameCreateWithoutAfterQuestionInformationInput, quiz_gameUncheckedCreateWithoutAfterQuestionInformationInput>
  }

  export type treasure_gameCreateWithoutAfterQuestionInformationInput = {
    title?: string | null
    description?: string | null
    treasure_connection_cards?: treasure_connection_cardsCreateNestedManyWithoutTreasure_gameInput
    game_type?: game_typeCreateNestedOneWithoutTreasure_gameInput
    Region?: RegionCreateNestedOneWithoutTreasure_gameInput
  }

  export type treasure_gameUncheckedCreateWithoutAfterQuestionInformationInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    title?: string | null
    description?: string | null
    treasure_connection_cards?: treasure_connection_cardsUncheckedCreateNestedManyWithoutTreasure_gameInput
  }

  export type treasure_gameCreateOrConnectWithoutAfterQuestionInformationInput = {
    where: treasure_gameWhereUniqueInput
    create: XOR<treasure_gameCreateWithoutAfterQuestionInformationInput, treasure_gameUncheckedCreateWithoutAfterQuestionInformationInput>
  }

  export type puzzle_gameUpsertWithoutAfterQuestionInformationInput = {
    update: XOR<puzzle_gameUpdateWithoutAfterQuestionInformationInput, puzzle_gameUncheckedUpdateWithoutAfterQuestionInformationInput>
    create: XOR<puzzle_gameCreateWithoutAfterQuestionInformationInput, puzzle_gameUncheckedCreateWithoutAfterQuestionInformationInput>
    where?: puzzle_gameWhereInput
  }

  export type puzzle_gameUpdateToOneWithWhereWithoutAfterQuestionInformationInput = {
    where?: puzzle_gameWhereInput
    data: XOR<puzzle_gameUpdateWithoutAfterQuestionInformationInput, puzzle_gameUncheckedUpdateWithoutAfterQuestionInformationInput>
  }

  export type puzzle_gameUpdateWithoutAfterQuestionInformationInput = {
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    Region?: RegionUpdateOneWithoutPuzzle_gameNestedInput
    game_type?: game_typeUpdateOneWithoutPuzzle_gameNestedInput
    puzzle_pieces?: puzzle_piecesUpdateManyWithoutPuzzle_gameNestedInput
  }

  export type puzzle_gameUncheckedUpdateWithoutAfterQuestionInformationInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    puzzle_pieces?: puzzle_piecesUncheckedUpdateManyWithoutPuzzle_gameNestedInput
  }

  export type quiz_gameUpsertWithoutAfterQuestionInformationInput = {
    update: XOR<quiz_gameUpdateWithoutAfterQuestionInformationInput, quiz_gameUncheckedUpdateWithoutAfterQuestionInformationInput>
    create: XOR<quiz_gameCreateWithoutAfterQuestionInformationInput, quiz_gameUncheckedCreateWithoutAfterQuestionInformationInput>
    where?: quiz_gameWhereInput
  }

  export type quiz_gameUpdateToOneWithWhereWithoutAfterQuestionInformationInput = {
    where?: quiz_gameWhereInput
    data: XOR<quiz_gameUpdateWithoutAfterQuestionInformationInput, quiz_gameUncheckedUpdateWithoutAfterQuestionInformationInput>
  }

  export type quiz_gameUpdateWithoutAfterQuestionInformationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    game_type?: game_typeUpdateOneWithoutQuiz_gameNestedInput
    Region?: RegionUpdateOneWithoutQuiz_gameNestedInput
    quiz_game_qa?: quiz_game_qaUpdateManyWithoutQuiz_gameNestedInput
  }

  export type quiz_gameUncheckedUpdateWithoutAfterQuestionInformationInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quiz_game_qa?: quiz_game_qaUncheckedUpdateManyWithoutQuiz_gameNestedInput
  }

  export type treasure_gameUpsertWithoutAfterQuestionInformationInput = {
    update: XOR<treasure_gameUpdateWithoutAfterQuestionInformationInput, treasure_gameUncheckedUpdateWithoutAfterQuestionInformationInput>
    create: XOR<treasure_gameCreateWithoutAfterQuestionInformationInput, treasure_gameUncheckedCreateWithoutAfterQuestionInformationInput>
    where?: treasure_gameWhereInput
  }

  export type treasure_gameUpdateToOneWithWhereWithoutAfterQuestionInformationInput = {
    where?: treasure_gameWhereInput
    data: XOR<treasure_gameUpdateWithoutAfterQuestionInformationInput, treasure_gameUncheckedUpdateWithoutAfterQuestionInformationInput>
  }

  export type treasure_gameUpdateWithoutAfterQuestionInformationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    treasure_connection_cards?: treasure_connection_cardsUpdateManyWithoutTreasure_gameNestedInput
    game_type?: game_typeUpdateOneWithoutTreasure_gameNestedInput
    Region?: RegionUpdateOneWithoutTreasure_gameNestedInput
  }

  export type treasure_gameUncheckedUpdateWithoutAfterQuestionInformationInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    treasure_connection_cards?: treasure_connection_cardsUncheckedUpdateManyWithoutTreasure_gameNestedInput
  }

  export type CommentCreateWithoutOther_CommentInput = {
    content: string
    likes?: number
    dislikes?: number
    Comment?: CommentCreateNestedOneWithoutOther_CommentInput
    Post: PostCreateNestedOneWithoutCommentInput
    User: UserCreateNestedOneWithoutCommentInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutOther_CommentInput = {
    id?: number
    postId: number
    userId: number
    content: string
    likes?: number
    dislikes?: number
    parentId?: number | null
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutOther_CommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutOther_CommentInput, CommentUncheckedCreateWithoutOther_CommentInput>
  }

  export type CommentCreateWithoutCommentInput = {
    content: string
    likes?: number
    dislikes?: number
    other_Comment?: CommentCreateNestedManyWithoutCommentInput
    Post: PostCreateNestedOneWithoutCommentInput
    User: UserCreateNestedOneWithoutCommentInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutCommentInput = {
    id?: number
    postId: number
    userId: number
    content: string
    likes?: number
    dislikes?: number
    other_Comment?: CommentUncheckedCreateNestedManyWithoutCommentInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput>
  }

  export type CommentCreateManyCommentInputEnvelope = {
    data: CommentCreateManyCommentInput | CommentCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutCommentInput = {
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
    User: UserCreateNestedOneWithoutPostInput
    Tags?: TagsCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentInput = {
    id?: number
    userId: number
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
    Tags?: TagsUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
  }

  export type UserCreateWithoutCommentInput = {
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutUserInput
    password_resets?: password_resetsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentInput = {
    id?: number
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementUncheckedCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutUserInput
    password_resets?: password_resetsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
  }

  export type comment_reactionCreateWithoutCommentInput = {
    reaction_type: $Enums.reaction_type_enum
    created_at?: Date | string | null
    User: UserCreateNestedOneWithoutComment_reactionInput
  }

  export type comment_reactionUncheckedCreateWithoutCommentInput = {
    id?: number
    user_id: number
    reaction_type: $Enums.reaction_type_enum
    created_at?: Date | string | null
  }

  export type comment_reactionCreateOrConnectWithoutCommentInput = {
    where: comment_reactionWhereUniqueInput
    create: XOR<comment_reactionCreateWithoutCommentInput, comment_reactionUncheckedCreateWithoutCommentInput>
  }

  export type comment_reactionCreateManyCommentInputEnvelope = {
    data: comment_reactionCreateManyCommentInput | comment_reactionCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithoutOther_CommentInput = {
    update: XOR<CommentUpdateWithoutOther_CommentInput, CommentUncheckedUpdateWithoutOther_CommentInput>
    create: XOR<CommentCreateWithoutOther_CommentInput, CommentUncheckedCreateWithoutOther_CommentInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutOther_CommentInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutOther_CommentInput, CommentUncheckedUpdateWithoutOther_CommentInput>
  }

  export type CommentUpdateWithoutOther_CommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    Comment?: CommentUpdateOneWithoutOther_CommentNestedInput
    Post?: PostUpdateOneRequiredWithoutCommentNestedInput
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutOther_CommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutCommentInput, CommentUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentCreateWithoutCommentInput, CommentUncheckedCreateWithoutCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutCommentInput, CommentUncheckedUpdateWithoutCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    postId?: IntFilter<"Comment"> | number
    userId?: IntFilter<"Comment"> | number
    content?: StringFilter<"Comment"> | string
    likes?: IntFilter<"Comment"> | number
    dislikes?: IntFilter<"Comment"> | number
    parentId?: IntNullableFilter<"Comment"> | number | null
  }

  export type PostUpsertWithoutCommentInput = {
    update: XOR<PostUpdateWithoutCommentInput, PostUncheckedUpdateWithoutCommentInput>
    create: XOR<PostCreateWithoutCommentInput, PostUncheckedCreateWithoutCommentInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentInput, PostUncheckedUpdateWithoutCommentInput>
  }

  export type PostUpdateWithoutCommentInput = {
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    User?: UserUpdateOneRequiredWithoutPostNestedInput
    Tags?: TagsUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    Tags?: TagsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutCommentInput = {
    update: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
    create: XOR<UserCreateWithoutCommentInput, UserUncheckedCreateWithoutCommentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentInput, UserUncheckedUpdateWithoutCommentInput>
  }

  export type UserUpdateWithoutCommentInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type comment_reactionUpsertWithWhereUniqueWithoutCommentInput = {
    where: comment_reactionWhereUniqueInput
    update: XOR<comment_reactionUpdateWithoutCommentInput, comment_reactionUncheckedUpdateWithoutCommentInput>
    create: XOR<comment_reactionCreateWithoutCommentInput, comment_reactionUncheckedCreateWithoutCommentInput>
  }

  export type comment_reactionUpdateWithWhereUniqueWithoutCommentInput = {
    where: comment_reactionWhereUniqueInput
    data: XOR<comment_reactionUpdateWithoutCommentInput, comment_reactionUncheckedUpdateWithoutCommentInput>
  }

  export type comment_reactionUpdateManyWithWhereWithoutCommentInput = {
    where: comment_reactionScalarWhereInput
    data: XOR<comment_reactionUpdateManyMutationInput, comment_reactionUncheckedUpdateManyWithoutCommentInput>
  }

  export type comment_reactionScalarWhereInput = {
    AND?: comment_reactionScalarWhereInput | comment_reactionScalarWhereInput[]
    OR?: comment_reactionScalarWhereInput[]
    NOT?: comment_reactionScalarWhereInput | comment_reactionScalarWhereInput[]
    id?: IntFilter<"comment_reaction"> | number
    user_id?: IntFilter<"comment_reaction"> | number
    comment_id?: IntFilter<"comment_reaction"> | number
    reaction_type?: Enumreaction_type_enumFilter<"comment_reaction"> | $Enums.reaction_type_enum
    created_at?: DateTimeNullableFilter<"comment_reaction"> | Date | string | null
  }

  export type UserCreateWithoutEmailVerificationInput = {
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutUserInput
    password_resets?: password_resetsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailVerificationInput = {
    id?: number
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutUserInput
    password_resets?: password_resetsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailVerificationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailVerificationInput, UserUncheckedCreateWithoutEmailVerificationInput>
  }

  export type UserUpsertWithoutEmailVerificationInput = {
    update: XOR<UserUpdateWithoutEmailVerificationInput, UserUncheckedUpdateWithoutEmailVerificationInput>
    create: XOR<UserCreateWithoutEmailVerificationInput, UserUncheckedCreateWithoutEmailVerificationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailVerificationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailVerificationInput, UserUncheckedUpdateWithoutEmailVerificationInput>
  }

  export type UserUpdateWithoutEmailVerificationInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailVerificationInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentCreateWithoutPostInput = {
    content: string
    likes?: number
    dislikes?: number
    Comment?: CommentCreateNestedOneWithoutOther_CommentInput
    other_Comment?: CommentCreateNestedManyWithoutCommentInput
    User: UserCreateNestedOneWithoutCommentInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    content: string
    likes?: number
    dislikes?: number
    parentId?: number | null
    other_Comment?: CommentUncheckedCreateNestedManyWithoutCommentInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutPostInput = {
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutUserInput
    password_resets?: password_resetsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostInput = {
    id?: number
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutUserInput
    password_resets?: password_resetsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
  }

  export type TagsCreateWithoutPostInput = {
    name: string
  }

  export type TagsUncheckedCreateWithoutPostInput = {
    id?: number
    name: string
  }

  export type TagsCreateOrConnectWithoutPostInput = {
    where: TagsWhereUniqueInput
    create: XOR<TagsCreateWithoutPostInput, TagsUncheckedCreateWithoutPostInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type UserUpsertWithoutPostInput = {
    update: XOR<UserUpdateWithoutPostInput, UserUncheckedUpdateWithoutPostInput>
    create: XOR<UserCreateWithoutPostInput, UserUncheckedCreateWithoutPostInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostInput, UserUncheckedUpdateWithoutPostInput>
  }

  export type UserUpdateWithoutPostInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TagsUpsertWithWhereUniqueWithoutPostInput = {
    where: TagsWhereUniqueInput
    update: XOR<TagsUpdateWithoutPostInput, TagsUncheckedUpdateWithoutPostInput>
    create: XOR<TagsCreateWithoutPostInput, TagsUncheckedCreateWithoutPostInput>
  }

  export type TagsUpdateWithWhereUniqueWithoutPostInput = {
    where: TagsWhereUniqueInput
    data: XOR<TagsUpdateWithoutPostInput, TagsUncheckedUpdateWithoutPostInput>
  }

  export type TagsUpdateManyWithWhereWithoutPostInput = {
    where: TagsScalarWhereInput
    data: XOR<TagsUpdateManyMutationInput, TagsUncheckedUpdateManyWithoutPostInput>
  }

  export type TagsScalarWhereInput = {
    AND?: TagsScalarWhereInput | TagsScalarWhereInput[]
    OR?: TagsScalarWhereInput[]
    NOT?: TagsScalarWhereInput | TagsScalarWhereInput[]
    id?: IntFilter<"Tags"> | number
    name?: StringFilter<"Tags"> | string
  }

  export type UserCreateWithoutRefreshTokenInput = {
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutUserInput
    password_resets?: password_resetsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokenInput = {
    id?: number
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutUserInput
    password_resets?: password_resetsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
  }

  export type UserUpsertWithoutRefreshTokenInput = {
    update: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
    create: XOR<UserCreateWithoutRefreshTokenInput, UserUncheckedCreateWithoutRefreshTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokenInput, UserUncheckedUpdateWithoutRefreshTokenInput>
  }

  export type UserUpdateWithoutRefreshTokenInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokenInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type puzzle_gameCreateWithoutRegionInput = {
    imageurl?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutPuzzle_gameInput
    game_type?: game_typeCreateNestedOneWithoutPuzzle_gameInput
    puzzle_pieces?: puzzle_piecesCreateNestedManyWithoutPuzzle_gameInput
  }

  export type puzzle_gameUncheckedCreateWithoutRegionInput = {
    id?: number
    gametype?: number | null
    imageurl?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutPuzzle_gameInput
    puzzle_pieces?: puzzle_piecesUncheckedCreateNestedManyWithoutPuzzle_gameInput
  }

  export type puzzle_gameCreateOrConnectWithoutRegionInput = {
    where: puzzle_gameWhereUniqueInput
    create: XOR<puzzle_gameCreateWithoutRegionInput, puzzle_gameUncheckedCreateWithoutRegionInput>
  }

  export type puzzle_gameCreateManyRegionInputEnvelope = {
    data: puzzle_gameCreateManyRegionInput | puzzle_gameCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type quiz_gameCreateWithoutRegionInput = {
    title: string
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutQuiz_gameInput
    game_type?: game_typeCreateNestedOneWithoutQuiz_gameInput
    quiz_game_qa?: quiz_game_qaCreateNestedManyWithoutQuiz_gameInput
  }

  export type quiz_gameUncheckedCreateWithoutRegionInput = {
    id?: number
    gametype?: number | null
    title: string
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutQuiz_gameInput
    quiz_game_qa?: quiz_game_qaUncheckedCreateNestedManyWithoutQuiz_gameInput
  }

  export type quiz_gameCreateOrConnectWithoutRegionInput = {
    where: quiz_gameWhereUniqueInput
    create: XOR<quiz_gameCreateWithoutRegionInput, quiz_gameUncheckedCreateWithoutRegionInput>
  }

  export type quiz_gameCreateManyRegionInputEnvelope = {
    data: quiz_gameCreateManyRegionInput | quiz_gameCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type treasure_gameCreateWithoutRegionInput = {
    title?: string | null
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutTreasure_gameInput
    treasure_connection_cards?: treasure_connection_cardsCreateNestedManyWithoutTreasure_gameInput
    game_type?: game_typeCreateNestedOneWithoutTreasure_gameInput
  }

  export type treasure_gameUncheckedCreateWithoutRegionInput = {
    id?: number
    gametype?: number | null
    title?: string | null
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutTreasure_gameInput
    treasure_connection_cards?: treasure_connection_cardsUncheckedCreateNestedManyWithoutTreasure_gameInput
  }

  export type treasure_gameCreateOrConnectWithoutRegionInput = {
    where: treasure_gameWhereUniqueInput
    create: XOR<treasure_gameCreateWithoutRegionInput, treasure_gameUncheckedCreateWithoutRegionInput>
  }

  export type treasure_gameCreateManyRegionInputEnvelope = {
    data: treasure_gameCreateManyRegionInput | treasure_gameCreateManyRegionInput[]
    skipDuplicates?: boolean
  }

  export type puzzle_gameUpsertWithWhereUniqueWithoutRegionInput = {
    where: puzzle_gameWhereUniqueInput
    update: XOR<puzzle_gameUpdateWithoutRegionInput, puzzle_gameUncheckedUpdateWithoutRegionInput>
    create: XOR<puzzle_gameCreateWithoutRegionInput, puzzle_gameUncheckedCreateWithoutRegionInput>
  }

  export type puzzle_gameUpdateWithWhereUniqueWithoutRegionInput = {
    where: puzzle_gameWhereUniqueInput
    data: XOR<puzzle_gameUpdateWithoutRegionInput, puzzle_gameUncheckedUpdateWithoutRegionInput>
  }

  export type puzzle_gameUpdateManyWithWhereWithoutRegionInput = {
    where: puzzle_gameScalarWhereInput
    data: XOR<puzzle_gameUpdateManyMutationInput, puzzle_gameUncheckedUpdateManyWithoutRegionInput>
  }

  export type puzzle_gameScalarWhereInput = {
    AND?: puzzle_gameScalarWhereInput | puzzle_gameScalarWhereInput[]
    OR?: puzzle_gameScalarWhereInput[]
    NOT?: puzzle_gameScalarWhereInput | puzzle_gameScalarWhereInput[]
    id?: IntFilter<"puzzle_game"> | number
    regionid?: IntNullableFilter<"puzzle_game"> | number | null
    gametype?: IntNullableFilter<"puzzle_game"> | number | null
    imageurl?: StringNullableFilter<"puzzle_game"> | string | null
  }

  export type quiz_gameUpsertWithWhereUniqueWithoutRegionInput = {
    where: quiz_gameWhereUniqueInput
    update: XOR<quiz_gameUpdateWithoutRegionInput, quiz_gameUncheckedUpdateWithoutRegionInput>
    create: XOR<quiz_gameCreateWithoutRegionInput, quiz_gameUncheckedCreateWithoutRegionInput>
  }

  export type quiz_gameUpdateWithWhereUniqueWithoutRegionInput = {
    where: quiz_gameWhereUniqueInput
    data: XOR<quiz_gameUpdateWithoutRegionInput, quiz_gameUncheckedUpdateWithoutRegionInput>
  }

  export type quiz_gameUpdateManyWithWhereWithoutRegionInput = {
    where: quiz_gameScalarWhereInput
    data: XOR<quiz_gameUpdateManyMutationInput, quiz_gameUncheckedUpdateManyWithoutRegionInput>
  }

  export type quiz_gameScalarWhereInput = {
    AND?: quiz_gameScalarWhereInput | quiz_gameScalarWhereInput[]
    OR?: quiz_gameScalarWhereInput[]
    NOT?: quiz_gameScalarWhereInput | quiz_gameScalarWhereInput[]
    id?: IntFilter<"quiz_game"> | number
    regionid?: IntNullableFilter<"quiz_game"> | number | null
    gametype?: IntNullableFilter<"quiz_game"> | number | null
    title?: StringFilter<"quiz_game"> | string
    description?: StringNullableFilter<"quiz_game"> | string | null
  }

  export type treasure_gameUpsertWithWhereUniqueWithoutRegionInput = {
    where: treasure_gameWhereUniqueInput
    update: XOR<treasure_gameUpdateWithoutRegionInput, treasure_gameUncheckedUpdateWithoutRegionInput>
    create: XOR<treasure_gameCreateWithoutRegionInput, treasure_gameUncheckedCreateWithoutRegionInput>
  }

  export type treasure_gameUpdateWithWhereUniqueWithoutRegionInput = {
    where: treasure_gameWhereUniqueInput
    data: XOR<treasure_gameUpdateWithoutRegionInput, treasure_gameUncheckedUpdateWithoutRegionInput>
  }

  export type treasure_gameUpdateManyWithWhereWithoutRegionInput = {
    where: treasure_gameScalarWhereInput
    data: XOR<treasure_gameUpdateManyMutationInput, treasure_gameUncheckedUpdateManyWithoutRegionInput>
  }

  export type treasure_gameScalarWhereInput = {
    AND?: treasure_gameScalarWhereInput | treasure_gameScalarWhereInput[]
    OR?: treasure_gameScalarWhereInput[]
    NOT?: treasure_gameScalarWhereInput | treasure_gameScalarWhereInput[]
    id?: IntFilter<"treasure_game"> | number
    regionid?: IntNullableFilter<"treasure_game"> | number | null
    gametype?: IntNullableFilter<"treasure_game"> | number | null
    title?: StringNullableFilter<"treasure_game"> | string | null
    description?: StringNullableFilter<"treasure_game"> | string | null
  }

  export type PostCreateWithoutTagsInput = {
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
    Comment?: CommentCreateNestedManyWithoutPostInput
    User: UserCreateNestedOneWithoutPostInput
  }

  export type PostUncheckedCreateWithoutTagsInput = {
    id?: number
    userId: number
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
    Comment?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutTagsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
  }

  export type PostUpsertWithWhereUniqueWithoutTagsInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
    create: XOR<PostCreateWithoutTagsInput, PostUncheckedCreateWithoutTagsInput>
  }

  export type PostUpdateWithWhereUniqueWithoutTagsInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutTagsInput, PostUncheckedUpdateWithoutTagsInput>
  }

  export type PostUpdateManyWithWhereWithoutTagsInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutTagsInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: IntFilter<"Post"> | number
    userId?: IntFilter<"Post"> | number
    title?: StringFilter<"Post"> | string
    question?: StringFilter<"Post"> | string
    media?: JsonFilter<"Post">
  }

  export type AchievementCreateWithoutUserInput = {
    name: string
    description: string
    stars: number
  }

  export type AchievementUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    description: string
    stars: number
  }

  export type AchievementCreateOrConnectWithoutUserInput = {
    where: AchievementWhereUniqueInput
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementCreateManyUserInputEnvelope = {
    data: AchievementCreateManyUserInput | AchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutUserInput = {
    content: string
    likes?: number
    dislikes?: number
    Comment?: CommentCreateNestedOneWithoutOther_CommentInput
    other_Comment?: CommentCreateNestedManyWithoutCommentInput
    Post: PostCreateNestedOneWithoutCommentInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    content: string
    likes?: number
    dislikes?: number
    parentId?: number | null
    other_Comment?: CommentUncheckedCreateNestedManyWithoutCommentInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutUserInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentCreateManyUserInputEnvelope = {
    data: CommentCreateManyUserInput | CommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailVerificationCreateWithoutUserInput = {
    otp: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailVerificationUncheckedCreateWithoutUserInput = {
    id?: number
    otp: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type EmailVerificationCreateOrConnectWithoutUserInput = {
    where: EmailVerificationWhereUniqueInput
    create: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
  }

  export type PostCreateWithoutUserInput = {
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
    Comment?: CommentCreateNestedManyWithoutPostInput
    Tags?: TagsCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutUserInput = {
    id?: number
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
    Comment?: CommentUncheckedCreateNestedManyWithoutPostInput
    Tags?: TagsUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutUserInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostCreateManyUserInputEnvelope = {
    data: PostCreateManyUserInput | PostCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id: string
    hashedToken: string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    expireAt: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id: string
    hashedToken: string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    expireAt: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type comment_reactionCreateWithoutUserInput = {
    reaction_type: $Enums.reaction_type_enum
    created_at?: Date | string | null
    Comment: CommentCreateNestedOneWithoutComment_reactionInput
  }

  export type comment_reactionUncheckedCreateWithoutUserInput = {
    id?: number
    comment_id: number
    reaction_type: $Enums.reaction_type_enum
    created_at?: Date | string | null
  }

  export type comment_reactionCreateOrConnectWithoutUserInput = {
    where: comment_reactionWhereUniqueInput
    create: XOR<comment_reactionCreateWithoutUserInput, comment_reactionUncheckedCreateWithoutUserInput>
  }

  export type comment_reactionCreateManyUserInputEnvelope = {
    data: comment_reactionCreateManyUserInput | comment_reactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type password_resetsCreateWithoutUserInput = {
    token: string
    expiresAt: Date | string
  }

  export type password_resetsUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
  }

  export type password_resetsCreateOrConnectWithoutUserInput = {
    where: password_resetsWhereUniqueInput
    create: XOR<password_resetsCreateWithoutUserInput, password_resetsUncheckedCreateWithoutUserInput>
  }

  export type password_resetsCreateManyUserInputEnvelope = {
    data: password_resetsCreateManyUserInput | password_resetsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    update: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
    create: XOR<AchievementCreateWithoutUserInput, AchievementUncheckedCreateWithoutUserInput>
  }

  export type AchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: AchievementWhereUniqueInput
    data: XOR<AchievementUpdateWithoutUserInput, AchievementUncheckedUpdateWithoutUserInput>
  }

  export type AchievementUpdateManyWithWhereWithoutUserInput = {
    where: AchievementScalarWhereInput
    data: XOR<AchievementUpdateManyMutationInput, AchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type AchievementScalarWhereInput = {
    AND?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    OR?: AchievementScalarWhereInput[]
    NOT?: AchievementScalarWhereInput | AchievementScalarWhereInput[]
    id?: IntFilter<"Achievement"> | number
    userId?: IntFilter<"Achievement"> | number
    name?: StringFilter<"Achievement"> | string
    description?: StringFilter<"Achievement"> | string
    stars?: IntFilter<"Achievement"> | number
  }

  export type CommentUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
    create: XOR<CommentCreateWithoutUserInput, CommentUncheckedCreateWithoutUserInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutUserInput, CommentUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpdateManyWithWhereWithoutUserInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailVerificationUpsertWithoutUserInput = {
    update: XOR<EmailVerificationUpdateWithoutUserInput, EmailVerificationUncheckedUpdateWithoutUserInput>
    create: XOR<EmailVerificationCreateWithoutUserInput, EmailVerificationUncheckedCreateWithoutUserInput>
    where?: EmailVerificationWhereInput
  }

  export type EmailVerificationUpdateToOneWithWhereWithoutUserInput = {
    where?: EmailVerificationWhereInput
    data: XOR<EmailVerificationUpdateWithoutUserInput, EmailVerificationUncheckedUpdateWithoutUserInput>
  }

  export type EmailVerificationUpdateWithoutUserInput = {
    otp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailVerificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    otp?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
    create: XOR<PostCreateWithoutUserInput, PostUncheckedCreateWithoutUserInput>
  }

  export type PostUpdateWithWhereUniqueWithoutUserInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutUserInput, PostUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithWhereWithoutUserInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    hashedToken?: StringFilter<"RefreshToken"> | string
    userId?: IntFilter<"RefreshToken"> | number
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    expireAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type comment_reactionUpsertWithWhereUniqueWithoutUserInput = {
    where: comment_reactionWhereUniqueInput
    update: XOR<comment_reactionUpdateWithoutUserInput, comment_reactionUncheckedUpdateWithoutUserInput>
    create: XOR<comment_reactionCreateWithoutUserInput, comment_reactionUncheckedCreateWithoutUserInput>
  }

  export type comment_reactionUpdateWithWhereUniqueWithoutUserInput = {
    where: comment_reactionWhereUniqueInput
    data: XOR<comment_reactionUpdateWithoutUserInput, comment_reactionUncheckedUpdateWithoutUserInput>
  }

  export type comment_reactionUpdateManyWithWhereWithoutUserInput = {
    where: comment_reactionScalarWhereInput
    data: XOR<comment_reactionUpdateManyMutationInput, comment_reactionUncheckedUpdateManyWithoutUserInput>
  }

  export type password_resetsUpsertWithWhereUniqueWithoutUserInput = {
    where: password_resetsWhereUniqueInput
    update: XOR<password_resetsUpdateWithoutUserInput, password_resetsUncheckedUpdateWithoutUserInput>
    create: XOR<password_resetsCreateWithoutUserInput, password_resetsUncheckedCreateWithoutUserInput>
  }

  export type password_resetsUpdateWithWhereUniqueWithoutUserInput = {
    where: password_resetsWhereUniqueInput
    data: XOR<password_resetsUpdateWithoutUserInput, password_resetsUncheckedUpdateWithoutUserInput>
  }

  export type password_resetsUpdateManyWithWhereWithoutUserInput = {
    where: password_resetsScalarWhereInput
    data: XOR<password_resetsUpdateManyMutationInput, password_resetsUncheckedUpdateManyWithoutUserInput>
  }

  export type password_resetsScalarWhereInput = {
    AND?: password_resetsScalarWhereInput | password_resetsScalarWhereInput[]
    OR?: password_resetsScalarWhereInput[]
    NOT?: password_resetsScalarWhereInput | password_resetsScalarWhereInput[]
    id?: IntFilter<"password_resets"> | number
    userId?: IntFilter<"password_resets"> | number
    token?: StringFilter<"password_resets"> | string
    expiresAt?: DateTimeFilter<"password_resets"> | Date | string
  }

  export type CommentCreateWithoutComment_reactionInput = {
    content: string
    likes?: number
    dislikes?: number
    Comment?: CommentCreateNestedOneWithoutOther_CommentInput
    other_Comment?: CommentCreateNestedManyWithoutCommentInput
    Post: PostCreateNestedOneWithoutCommentInput
    User: UserCreateNestedOneWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutComment_reactionInput = {
    id?: number
    postId: number
    userId: number
    content: string
    likes?: number
    dislikes?: number
    parentId?: number | null
    other_Comment?: CommentUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutComment_reactionInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutComment_reactionInput, CommentUncheckedCreateWithoutComment_reactionInput>
  }

  export type UserCreateWithoutComment_reactionInput = {
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    password_resets?: password_resetsCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutComment_reactionInput = {
    id?: number
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    password_resets?: password_resetsUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutComment_reactionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComment_reactionInput, UserUncheckedCreateWithoutComment_reactionInput>
  }

  export type CommentUpsertWithoutComment_reactionInput = {
    update: XOR<CommentUpdateWithoutComment_reactionInput, CommentUncheckedUpdateWithoutComment_reactionInput>
    create: XOR<CommentCreateWithoutComment_reactionInput, CommentUncheckedCreateWithoutComment_reactionInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutComment_reactionInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutComment_reactionInput, CommentUncheckedUpdateWithoutComment_reactionInput>
  }

  export type CommentUpdateWithoutComment_reactionInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    Comment?: CommentUpdateOneWithoutOther_CommentNestedInput
    other_Comment?: CommentUpdateManyWithoutCommentNestedInput
    Post?: PostUpdateOneRequiredWithoutCommentNestedInput
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutComment_reactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    other_Comment?: CommentUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type UserUpsertWithoutComment_reactionInput = {
    update: XOR<UserUpdateWithoutComment_reactionInput, UserUncheckedUpdateWithoutComment_reactionInput>
    create: XOR<UserCreateWithoutComment_reactionInput, UserUncheckedCreateWithoutComment_reactionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComment_reactionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComment_reactionInput, UserUncheckedUpdateWithoutComment_reactionInput>
  }

  export type UserUpdateWithoutComment_reactionInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutComment_reactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    password_resets?: password_resetsUncheckedUpdateManyWithoutUserNestedInput
  }

  export type puzzle_gameCreateWithoutGame_typeInput = {
    imageurl?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutPuzzle_gameInput
    Region?: RegionCreateNestedOneWithoutPuzzle_gameInput
    puzzle_pieces?: puzzle_piecesCreateNestedManyWithoutPuzzle_gameInput
  }

  export type puzzle_gameUncheckedCreateWithoutGame_typeInput = {
    id?: number
    regionid?: number | null
    imageurl?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutPuzzle_gameInput
    puzzle_pieces?: puzzle_piecesUncheckedCreateNestedManyWithoutPuzzle_gameInput
  }

  export type puzzle_gameCreateOrConnectWithoutGame_typeInput = {
    where: puzzle_gameWhereUniqueInput
    create: XOR<puzzle_gameCreateWithoutGame_typeInput, puzzle_gameUncheckedCreateWithoutGame_typeInput>
  }

  export type puzzle_gameCreateManyGame_typeInputEnvelope = {
    data: puzzle_gameCreateManyGame_typeInput | puzzle_gameCreateManyGame_typeInput[]
    skipDuplicates?: boolean
  }

  export type quiz_gameCreateWithoutGame_typeInput = {
    title: string
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutQuiz_gameInput
    Region?: RegionCreateNestedOneWithoutQuiz_gameInput
    quiz_game_qa?: quiz_game_qaCreateNestedManyWithoutQuiz_gameInput
  }

  export type quiz_gameUncheckedCreateWithoutGame_typeInput = {
    id?: number
    regionid?: number | null
    title: string
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutQuiz_gameInput
    quiz_game_qa?: quiz_game_qaUncheckedCreateNestedManyWithoutQuiz_gameInput
  }

  export type quiz_gameCreateOrConnectWithoutGame_typeInput = {
    where: quiz_gameWhereUniqueInput
    create: XOR<quiz_gameCreateWithoutGame_typeInput, quiz_gameUncheckedCreateWithoutGame_typeInput>
  }

  export type quiz_gameCreateManyGame_typeInputEnvelope = {
    data: quiz_gameCreateManyGame_typeInput | quiz_gameCreateManyGame_typeInput[]
    skipDuplicates?: boolean
  }

  export type treasure_gameCreateWithoutGame_typeInput = {
    title?: string | null
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutTreasure_gameInput
    treasure_connection_cards?: treasure_connection_cardsCreateNestedManyWithoutTreasure_gameInput
    Region?: RegionCreateNestedOneWithoutTreasure_gameInput
  }

  export type treasure_gameUncheckedCreateWithoutGame_typeInput = {
    id?: number
    regionid?: number | null
    title?: string | null
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutTreasure_gameInput
    treasure_connection_cards?: treasure_connection_cardsUncheckedCreateNestedManyWithoutTreasure_gameInput
  }

  export type treasure_gameCreateOrConnectWithoutGame_typeInput = {
    where: treasure_gameWhereUniqueInput
    create: XOR<treasure_gameCreateWithoutGame_typeInput, treasure_gameUncheckedCreateWithoutGame_typeInput>
  }

  export type treasure_gameCreateManyGame_typeInputEnvelope = {
    data: treasure_gameCreateManyGame_typeInput | treasure_gameCreateManyGame_typeInput[]
    skipDuplicates?: boolean
  }

  export type puzzle_gameUpsertWithWhereUniqueWithoutGame_typeInput = {
    where: puzzle_gameWhereUniqueInput
    update: XOR<puzzle_gameUpdateWithoutGame_typeInput, puzzle_gameUncheckedUpdateWithoutGame_typeInput>
    create: XOR<puzzle_gameCreateWithoutGame_typeInput, puzzle_gameUncheckedCreateWithoutGame_typeInput>
  }

  export type puzzle_gameUpdateWithWhereUniqueWithoutGame_typeInput = {
    where: puzzle_gameWhereUniqueInput
    data: XOR<puzzle_gameUpdateWithoutGame_typeInput, puzzle_gameUncheckedUpdateWithoutGame_typeInput>
  }

  export type puzzle_gameUpdateManyWithWhereWithoutGame_typeInput = {
    where: puzzle_gameScalarWhereInput
    data: XOR<puzzle_gameUpdateManyMutationInput, puzzle_gameUncheckedUpdateManyWithoutGame_typeInput>
  }

  export type quiz_gameUpsertWithWhereUniqueWithoutGame_typeInput = {
    where: quiz_gameWhereUniqueInput
    update: XOR<quiz_gameUpdateWithoutGame_typeInput, quiz_gameUncheckedUpdateWithoutGame_typeInput>
    create: XOR<quiz_gameCreateWithoutGame_typeInput, quiz_gameUncheckedCreateWithoutGame_typeInput>
  }

  export type quiz_gameUpdateWithWhereUniqueWithoutGame_typeInput = {
    where: quiz_gameWhereUniqueInput
    data: XOR<quiz_gameUpdateWithoutGame_typeInput, quiz_gameUncheckedUpdateWithoutGame_typeInput>
  }

  export type quiz_gameUpdateManyWithWhereWithoutGame_typeInput = {
    where: quiz_gameScalarWhereInput
    data: XOR<quiz_gameUpdateManyMutationInput, quiz_gameUncheckedUpdateManyWithoutGame_typeInput>
  }

  export type treasure_gameUpsertWithWhereUniqueWithoutGame_typeInput = {
    where: treasure_gameWhereUniqueInput
    update: XOR<treasure_gameUpdateWithoutGame_typeInput, treasure_gameUncheckedUpdateWithoutGame_typeInput>
    create: XOR<treasure_gameCreateWithoutGame_typeInput, treasure_gameUncheckedCreateWithoutGame_typeInput>
  }

  export type treasure_gameUpdateWithWhereUniqueWithoutGame_typeInput = {
    where: treasure_gameWhereUniqueInput
    data: XOR<treasure_gameUpdateWithoutGame_typeInput, treasure_gameUncheckedUpdateWithoutGame_typeInput>
  }

  export type treasure_gameUpdateManyWithWhereWithoutGame_typeInput = {
    where: treasure_gameScalarWhereInput
    data: XOR<treasure_gameUpdateManyMutationInput, treasure_gameUncheckedUpdateManyWithoutGame_typeInput>
  }

  export type UserCreateWithoutPassword_resetsInput = {
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementCreateNestedManyWithoutUserInput
    Comment?: CommentCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationCreateNestedOneWithoutUserInput
    Post?: PostCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPassword_resetsInput = {
    id?: number
    full_name: string
    username?: string | null
    email: string
    password: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    location?: string | null
    gender?: string | null
    isVerified?: boolean
    Achievement?: AchievementUncheckedCreateNestedManyWithoutUserInput
    Comment?: CommentUncheckedCreateNestedManyWithoutUserInput
    EmailVerification?: EmailVerificationUncheckedCreateNestedOneWithoutUserInput
    Post?: PostUncheckedCreateNestedManyWithoutUserInput
    RefreshToken?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    comment_reaction?: comment_reactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPassword_resetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPassword_resetsInput, UserUncheckedCreateWithoutPassword_resetsInput>
  }

  export type UserUpsertWithoutPassword_resetsInput = {
    update: XOR<UserUpdateWithoutPassword_resetsInput, UserUncheckedUpdateWithoutPassword_resetsInput>
    create: XOR<UserCreateWithoutPassword_resetsInput, UserUncheckedCreateWithoutPassword_resetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPassword_resetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPassword_resetsInput, UserUncheckedUpdateWithoutPassword_resetsInput>
  }

  export type UserUpdateWithoutPassword_resetsInput = {
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUpdateManyWithoutUserNestedInput
    Comment?: CommentUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUpdateOneWithoutUserNestedInput
    Post?: PostUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPassword_resetsInput = {
    id?: IntFieldUpdateOperationsInput | number
    full_name?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    Achievement?: AchievementUncheckedUpdateManyWithoutUserNestedInput
    Comment?: CommentUncheckedUpdateManyWithoutUserNestedInput
    EmailVerification?: EmailVerificationUncheckedUpdateOneWithoutUserNestedInput
    Post?: PostUncheckedUpdateManyWithoutUserNestedInput
    RefreshToken?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AfterQuestionInformationCreateWithoutPuzzle_gameInput = {
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
    quiz_game: quiz_gameCreateNestedOneWithoutAfterQuestionInformationInput
    treasure_game: treasure_gameCreateNestedOneWithoutAfterQuestionInformationInput
  }

  export type AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput = {
    id?: number
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationCreateOrConnectWithoutPuzzle_gameInput = {
    where: AfterQuestionInformationWhereUniqueInput
    create: XOR<AfterQuestionInformationCreateWithoutPuzzle_gameInput, AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput>
  }

  export type AfterQuestionInformationCreateManyPuzzle_gameInputEnvelope = {
    data: AfterQuestionInformationCreateManyPuzzle_gameInput | AfterQuestionInformationCreateManyPuzzle_gameInput[]
    skipDuplicates?: boolean
  }

  export type RegionCreateWithoutPuzzle_gameInput = {
    regionName: string
    regionCode: string
    mediaUrl?: string | null
    description?: string | null
    quiz_game?: quiz_gameCreateNestedManyWithoutRegionInput
    treasure_game?: treasure_gameCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutPuzzle_gameInput = {
    id?: number
    regionName: string
    regionCode: string
    mediaUrl?: string | null
    description?: string | null
    quiz_game?: quiz_gameUncheckedCreateNestedManyWithoutRegionInput
    treasure_game?: treasure_gameUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutPuzzle_gameInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutPuzzle_gameInput, RegionUncheckedCreateWithoutPuzzle_gameInput>
  }

  export type game_typeCreateWithoutPuzzle_gameInput = {
    code: $Enums.game_code_enum
    name: string
    quiz_game?: quiz_gameCreateNestedManyWithoutGame_typeInput
    treasure_game?: treasure_gameCreateNestedManyWithoutGame_typeInput
  }

  export type game_typeUncheckedCreateWithoutPuzzle_gameInput = {
    id?: number
    code: $Enums.game_code_enum
    name: string
    quiz_game?: quiz_gameUncheckedCreateNestedManyWithoutGame_typeInput
    treasure_game?: treasure_gameUncheckedCreateNestedManyWithoutGame_typeInput
  }

  export type game_typeCreateOrConnectWithoutPuzzle_gameInput = {
    where: game_typeWhereUniqueInput
    create: XOR<game_typeCreateWithoutPuzzle_gameInput, game_typeUncheckedCreateWithoutPuzzle_gameInput>
  }

  export type puzzle_piecesCreateWithoutPuzzle_gameInput = {
    piece_index: number
    x_position?: number | null
    y_position?: number | null
    correct_x: number
    correct_y: number
    image_piece_url?: string | null
  }

  export type puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput = {
    id?: number
    piece_index: number
    x_position?: number | null
    y_position?: number | null
    correct_x: number
    correct_y: number
    image_piece_url?: string | null
  }

  export type puzzle_piecesCreateOrConnectWithoutPuzzle_gameInput = {
    where: puzzle_piecesWhereUniqueInput
    create: XOR<puzzle_piecesCreateWithoutPuzzle_gameInput, puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput>
  }

  export type puzzle_piecesCreateManyPuzzle_gameInputEnvelope = {
    data: puzzle_piecesCreateManyPuzzle_gameInput | puzzle_piecesCreateManyPuzzle_gameInput[]
    skipDuplicates?: boolean
  }

  export type AfterQuestionInformationUpsertWithWhereUniqueWithoutPuzzle_gameInput = {
    where: AfterQuestionInformationWhereUniqueInput
    update: XOR<AfterQuestionInformationUpdateWithoutPuzzle_gameInput, AfterQuestionInformationUncheckedUpdateWithoutPuzzle_gameInput>
    create: XOR<AfterQuestionInformationCreateWithoutPuzzle_gameInput, AfterQuestionInformationUncheckedCreateWithoutPuzzle_gameInput>
  }

  export type AfterQuestionInformationUpdateWithWhereUniqueWithoutPuzzle_gameInput = {
    where: AfterQuestionInformationWhereUniqueInput
    data: XOR<AfterQuestionInformationUpdateWithoutPuzzle_gameInput, AfterQuestionInformationUncheckedUpdateWithoutPuzzle_gameInput>
  }

  export type AfterQuestionInformationUpdateManyWithWhereWithoutPuzzle_gameInput = {
    where: AfterQuestionInformationScalarWhereInput
    data: XOR<AfterQuestionInformationUpdateManyMutationInput, AfterQuestionInformationUncheckedUpdateManyWithoutPuzzle_gameInput>
  }

  export type AfterQuestionInformationScalarWhereInput = {
    AND?: AfterQuestionInformationScalarWhereInput | AfterQuestionInformationScalarWhereInput[]
    OR?: AfterQuestionInformationScalarWhereInput[]
    NOT?: AfterQuestionInformationScalarWhereInput | AfterQuestionInformationScalarWhereInput[]
    id?: IntFilter<"AfterQuestionInformation"> | number
    gameId?: IntFilter<"AfterQuestionInformation"> | number
    questionNumber?: IntFilter<"AfterQuestionInformation"> | number
    images?: JsonFilter<"AfterQuestionInformation">
    texts?: JsonFilter<"AfterQuestionInformation">
  }

  export type RegionUpsertWithoutPuzzle_gameInput = {
    update: XOR<RegionUpdateWithoutPuzzle_gameInput, RegionUncheckedUpdateWithoutPuzzle_gameInput>
    create: XOR<RegionCreateWithoutPuzzle_gameInput, RegionUncheckedCreateWithoutPuzzle_gameInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutPuzzle_gameInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutPuzzle_gameInput, RegionUncheckedUpdateWithoutPuzzle_gameInput>
  }

  export type RegionUpdateWithoutPuzzle_gameInput = {
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quiz_game?: quiz_gameUpdateManyWithoutRegionNestedInput
    treasure_game?: treasure_gameUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutPuzzle_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    quiz_game?: quiz_gameUncheckedUpdateManyWithoutRegionNestedInput
    treasure_game?: treasure_gameUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type game_typeUpsertWithoutPuzzle_gameInput = {
    update: XOR<game_typeUpdateWithoutPuzzle_gameInput, game_typeUncheckedUpdateWithoutPuzzle_gameInput>
    create: XOR<game_typeCreateWithoutPuzzle_gameInput, game_typeUncheckedCreateWithoutPuzzle_gameInput>
    where?: game_typeWhereInput
  }

  export type game_typeUpdateToOneWithWhereWithoutPuzzle_gameInput = {
    where?: game_typeWhereInput
    data: XOR<game_typeUpdateWithoutPuzzle_gameInput, game_typeUncheckedUpdateWithoutPuzzle_gameInput>
  }

  export type game_typeUpdateWithoutPuzzle_gameInput = {
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
    quiz_game?: quiz_gameUpdateManyWithoutGame_typeNestedInput
    treasure_game?: treasure_gameUpdateManyWithoutGame_typeNestedInput
  }

  export type game_typeUncheckedUpdateWithoutPuzzle_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
    quiz_game?: quiz_gameUncheckedUpdateManyWithoutGame_typeNestedInput
    treasure_game?: treasure_gameUncheckedUpdateManyWithoutGame_typeNestedInput
  }

  export type puzzle_piecesUpsertWithWhereUniqueWithoutPuzzle_gameInput = {
    where: puzzle_piecesWhereUniqueInput
    update: XOR<puzzle_piecesUpdateWithoutPuzzle_gameInput, puzzle_piecesUncheckedUpdateWithoutPuzzle_gameInput>
    create: XOR<puzzle_piecesCreateWithoutPuzzle_gameInput, puzzle_piecesUncheckedCreateWithoutPuzzle_gameInput>
  }

  export type puzzle_piecesUpdateWithWhereUniqueWithoutPuzzle_gameInput = {
    where: puzzle_piecesWhereUniqueInput
    data: XOR<puzzle_piecesUpdateWithoutPuzzle_gameInput, puzzle_piecesUncheckedUpdateWithoutPuzzle_gameInput>
  }

  export type puzzle_piecesUpdateManyWithWhereWithoutPuzzle_gameInput = {
    where: puzzle_piecesScalarWhereInput
    data: XOR<puzzle_piecesUpdateManyMutationInput, puzzle_piecesUncheckedUpdateManyWithoutPuzzle_gameInput>
  }

  export type puzzle_piecesScalarWhereInput = {
    AND?: puzzle_piecesScalarWhereInput | puzzle_piecesScalarWhereInput[]
    OR?: puzzle_piecesScalarWhereInput[]
    NOT?: puzzle_piecesScalarWhereInput | puzzle_piecesScalarWhereInput[]
    id?: IntFilter<"puzzle_pieces"> | number
    puzzleid?: IntNullableFilter<"puzzle_pieces"> | number | null
    piece_index?: IntFilter<"puzzle_pieces"> | number
    x_position?: IntNullableFilter<"puzzle_pieces"> | number | null
    y_position?: IntNullableFilter<"puzzle_pieces"> | number | null
    correct_x?: IntFilter<"puzzle_pieces"> | number
    correct_y?: IntFilter<"puzzle_pieces"> | number
    image_piece_url?: StringNullableFilter<"puzzle_pieces"> | string | null
  }

  export type puzzle_gameCreateWithoutPuzzle_piecesInput = {
    imageurl?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutPuzzle_gameInput
    Region?: RegionCreateNestedOneWithoutPuzzle_gameInput
    game_type?: game_typeCreateNestedOneWithoutPuzzle_gameInput
  }

  export type puzzle_gameUncheckedCreateWithoutPuzzle_piecesInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    imageurl?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutPuzzle_gameInput
  }

  export type puzzle_gameCreateOrConnectWithoutPuzzle_piecesInput = {
    where: puzzle_gameWhereUniqueInput
    create: XOR<puzzle_gameCreateWithoutPuzzle_piecesInput, puzzle_gameUncheckedCreateWithoutPuzzle_piecesInput>
  }

  export type puzzle_gameUpsertWithoutPuzzle_piecesInput = {
    update: XOR<puzzle_gameUpdateWithoutPuzzle_piecesInput, puzzle_gameUncheckedUpdateWithoutPuzzle_piecesInput>
    create: XOR<puzzle_gameCreateWithoutPuzzle_piecesInput, puzzle_gameUncheckedCreateWithoutPuzzle_piecesInput>
    where?: puzzle_gameWhereInput
  }

  export type puzzle_gameUpdateToOneWithWhereWithoutPuzzle_piecesInput = {
    where?: puzzle_gameWhereInput
    data: XOR<puzzle_gameUpdateWithoutPuzzle_piecesInput, puzzle_gameUncheckedUpdateWithoutPuzzle_piecesInput>
  }

  export type puzzle_gameUpdateWithoutPuzzle_piecesInput = {
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutPuzzle_gameNestedInput
    Region?: RegionUpdateOneWithoutPuzzle_gameNestedInput
    game_type?: game_typeUpdateOneWithoutPuzzle_gameNestedInput
  }

  export type puzzle_gameUncheckedUpdateWithoutPuzzle_piecesInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutPuzzle_gameNestedInput
  }

  export type AfterQuestionInformationCreateWithoutQuiz_gameInput = {
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
    puzzle_game: puzzle_gameCreateNestedOneWithoutAfterQuestionInformationInput
    treasure_game: treasure_gameCreateNestedOneWithoutAfterQuestionInformationInput
  }

  export type AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput = {
    id?: number
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationCreateOrConnectWithoutQuiz_gameInput = {
    where: AfterQuestionInformationWhereUniqueInput
    create: XOR<AfterQuestionInformationCreateWithoutQuiz_gameInput, AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput>
  }

  export type AfterQuestionInformationCreateManyQuiz_gameInputEnvelope = {
    data: AfterQuestionInformationCreateManyQuiz_gameInput | AfterQuestionInformationCreateManyQuiz_gameInput[]
    skipDuplicates?: boolean
  }

  export type game_typeCreateWithoutQuiz_gameInput = {
    code: $Enums.game_code_enum
    name: string
    puzzle_game?: puzzle_gameCreateNestedManyWithoutGame_typeInput
    treasure_game?: treasure_gameCreateNestedManyWithoutGame_typeInput
  }

  export type game_typeUncheckedCreateWithoutQuiz_gameInput = {
    id?: number
    code: $Enums.game_code_enum
    name: string
    puzzle_game?: puzzle_gameUncheckedCreateNestedManyWithoutGame_typeInput
    treasure_game?: treasure_gameUncheckedCreateNestedManyWithoutGame_typeInput
  }

  export type game_typeCreateOrConnectWithoutQuiz_gameInput = {
    where: game_typeWhereUniqueInput
    create: XOR<game_typeCreateWithoutQuiz_gameInput, game_typeUncheckedCreateWithoutQuiz_gameInput>
  }

  export type RegionCreateWithoutQuiz_gameInput = {
    regionName: string
    regionCode: string
    mediaUrl?: string | null
    description?: string | null
    puzzle_game?: puzzle_gameCreateNestedManyWithoutRegionInput
    treasure_game?: treasure_gameCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutQuiz_gameInput = {
    id?: number
    regionName: string
    regionCode: string
    mediaUrl?: string | null
    description?: string | null
    puzzle_game?: puzzle_gameUncheckedCreateNestedManyWithoutRegionInput
    treasure_game?: treasure_gameUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutQuiz_gameInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutQuiz_gameInput, RegionUncheckedCreateWithoutQuiz_gameInput>
  }

  export type quiz_game_qaCreateWithoutQuiz_gameInput = {
    question: string
    wrong_answers: JsonNullValueInput | InputJsonValue
    correct_answer: string
  }

  export type quiz_game_qaUncheckedCreateWithoutQuiz_gameInput = {
    id?: number
    question: string
    wrong_answers: JsonNullValueInput | InputJsonValue
    correct_answer: string
  }

  export type quiz_game_qaCreateOrConnectWithoutQuiz_gameInput = {
    where: quiz_game_qaWhereUniqueInput
    create: XOR<quiz_game_qaCreateWithoutQuiz_gameInput, quiz_game_qaUncheckedCreateWithoutQuiz_gameInput>
  }

  export type quiz_game_qaCreateManyQuiz_gameInputEnvelope = {
    data: quiz_game_qaCreateManyQuiz_gameInput | quiz_game_qaCreateManyQuiz_gameInput[]
    skipDuplicates?: boolean
  }

  export type AfterQuestionInformationUpsertWithWhereUniqueWithoutQuiz_gameInput = {
    where: AfterQuestionInformationWhereUniqueInput
    update: XOR<AfterQuestionInformationUpdateWithoutQuiz_gameInput, AfterQuestionInformationUncheckedUpdateWithoutQuiz_gameInput>
    create: XOR<AfterQuestionInformationCreateWithoutQuiz_gameInput, AfterQuestionInformationUncheckedCreateWithoutQuiz_gameInput>
  }

  export type AfterQuestionInformationUpdateWithWhereUniqueWithoutQuiz_gameInput = {
    where: AfterQuestionInformationWhereUniqueInput
    data: XOR<AfterQuestionInformationUpdateWithoutQuiz_gameInput, AfterQuestionInformationUncheckedUpdateWithoutQuiz_gameInput>
  }

  export type AfterQuestionInformationUpdateManyWithWhereWithoutQuiz_gameInput = {
    where: AfterQuestionInformationScalarWhereInput
    data: XOR<AfterQuestionInformationUpdateManyMutationInput, AfterQuestionInformationUncheckedUpdateManyWithoutQuiz_gameInput>
  }

  export type game_typeUpsertWithoutQuiz_gameInput = {
    update: XOR<game_typeUpdateWithoutQuiz_gameInput, game_typeUncheckedUpdateWithoutQuiz_gameInput>
    create: XOR<game_typeCreateWithoutQuiz_gameInput, game_typeUncheckedCreateWithoutQuiz_gameInput>
    where?: game_typeWhereInput
  }

  export type game_typeUpdateToOneWithWhereWithoutQuiz_gameInput = {
    where?: game_typeWhereInput
    data: XOR<game_typeUpdateWithoutQuiz_gameInput, game_typeUncheckedUpdateWithoutQuiz_gameInput>
  }

  export type game_typeUpdateWithoutQuiz_gameInput = {
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
    puzzle_game?: puzzle_gameUpdateManyWithoutGame_typeNestedInput
    treasure_game?: treasure_gameUpdateManyWithoutGame_typeNestedInput
  }

  export type game_typeUncheckedUpdateWithoutQuiz_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
    puzzle_game?: puzzle_gameUncheckedUpdateManyWithoutGame_typeNestedInput
    treasure_game?: treasure_gameUncheckedUpdateManyWithoutGame_typeNestedInput
  }

  export type RegionUpsertWithoutQuiz_gameInput = {
    update: XOR<RegionUpdateWithoutQuiz_gameInput, RegionUncheckedUpdateWithoutQuiz_gameInput>
    create: XOR<RegionCreateWithoutQuiz_gameInput, RegionUncheckedCreateWithoutQuiz_gameInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutQuiz_gameInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutQuiz_gameInput, RegionUncheckedUpdateWithoutQuiz_gameInput>
  }

  export type RegionUpdateWithoutQuiz_gameInput = {
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puzzle_game?: puzzle_gameUpdateManyWithoutRegionNestedInput
    treasure_game?: treasure_gameUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutQuiz_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puzzle_game?: puzzle_gameUncheckedUpdateManyWithoutRegionNestedInput
    treasure_game?: treasure_gameUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type quiz_game_qaUpsertWithWhereUniqueWithoutQuiz_gameInput = {
    where: quiz_game_qaWhereUniqueInput
    update: XOR<quiz_game_qaUpdateWithoutQuiz_gameInput, quiz_game_qaUncheckedUpdateWithoutQuiz_gameInput>
    create: XOR<quiz_game_qaCreateWithoutQuiz_gameInput, quiz_game_qaUncheckedCreateWithoutQuiz_gameInput>
  }

  export type quiz_game_qaUpdateWithWhereUniqueWithoutQuiz_gameInput = {
    where: quiz_game_qaWhereUniqueInput
    data: XOR<quiz_game_qaUpdateWithoutQuiz_gameInput, quiz_game_qaUncheckedUpdateWithoutQuiz_gameInput>
  }

  export type quiz_game_qaUpdateManyWithWhereWithoutQuiz_gameInput = {
    where: quiz_game_qaScalarWhereInput
    data: XOR<quiz_game_qaUpdateManyMutationInput, quiz_game_qaUncheckedUpdateManyWithoutQuiz_gameInput>
  }

  export type quiz_game_qaScalarWhereInput = {
    AND?: quiz_game_qaScalarWhereInput | quiz_game_qaScalarWhereInput[]
    OR?: quiz_game_qaScalarWhereInput[]
    NOT?: quiz_game_qaScalarWhereInput | quiz_game_qaScalarWhereInput[]
    id?: IntFilter<"quiz_game_qa"> | number
    quiz_game_id?: IntNullableFilter<"quiz_game_qa"> | number | null
    question?: StringFilter<"quiz_game_qa"> | string
    wrong_answers?: JsonFilter<"quiz_game_qa">
    correct_answer?: StringFilter<"quiz_game_qa"> | string
  }

  export type quiz_gameCreateWithoutQuiz_game_qaInput = {
    title: string
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutQuiz_gameInput
    game_type?: game_typeCreateNestedOneWithoutQuiz_gameInput
    Region?: RegionCreateNestedOneWithoutQuiz_gameInput
  }

  export type quiz_gameUncheckedCreateWithoutQuiz_game_qaInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    title: string
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutQuiz_gameInput
  }

  export type quiz_gameCreateOrConnectWithoutQuiz_game_qaInput = {
    where: quiz_gameWhereUniqueInput
    create: XOR<quiz_gameCreateWithoutQuiz_game_qaInput, quiz_gameUncheckedCreateWithoutQuiz_game_qaInput>
  }

  export type quiz_gameUpsertWithoutQuiz_game_qaInput = {
    update: XOR<quiz_gameUpdateWithoutQuiz_game_qaInput, quiz_gameUncheckedUpdateWithoutQuiz_game_qaInput>
    create: XOR<quiz_gameCreateWithoutQuiz_game_qaInput, quiz_gameUncheckedCreateWithoutQuiz_game_qaInput>
    where?: quiz_gameWhereInput
  }

  export type quiz_gameUpdateToOneWithWhereWithoutQuiz_game_qaInput = {
    where?: quiz_gameWhereInput
    data: XOR<quiz_gameUpdateWithoutQuiz_game_qaInput, quiz_gameUncheckedUpdateWithoutQuiz_game_qaInput>
  }

  export type quiz_gameUpdateWithoutQuiz_game_qaInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutQuiz_gameNestedInput
    game_type?: game_typeUpdateOneWithoutQuiz_gameNestedInput
    Region?: RegionUpdateOneWithoutQuiz_gameNestedInput
  }

  export type quiz_gameUncheckedUpdateWithoutQuiz_game_qaInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutQuiz_gameNestedInput
  }

  export type treasure_gameCreateWithoutTreasure_connection_cardsInput = {
    title?: string | null
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationCreateNestedManyWithoutTreasure_gameInput
    game_type?: game_typeCreateNestedOneWithoutTreasure_gameInput
    Region?: RegionCreateNestedOneWithoutTreasure_gameInput
  }

  export type treasure_gameUncheckedCreateWithoutTreasure_connection_cardsInput = {
    id?: number
    regionid?: number | null
    gametype?: number | null
    title?: string | null
    description?: string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedCreateNestedManyWithoutTreasure_gameInput
  }

  export type treasure_gameCreateOrConnectWithoutTreasure_connection_cardsInput = {
    where: treasure_gameWhereUniqueInput
    create: XOR<treasure_gameCreateWithoutTreasure_connection_cardsInput, treasure_gameUncheckedCreateWithoutTreasure_connection_cardsInput>
  }

  export type treasure_gameUpsertWithoutTreasure_connection_cardsInput = {
    update: XOR<treasure_gameUpdateWithoutTreasure_connection_cardsInput, treasure_gameUncheckedUpdateWithoutTreasure_connection_cardsInput>
    create: XOR<treasure_gameCreateWithoutTreasure_connection_cardsInput, treasure_gameUncheckedCreateWithoutTreasure_connection_cardsInput>
    where?: treasure_gameWhereInput
  }

  export type treasure_gameUpdateToOneWithWhereWithoutTreasure_connection_cardsInput = {
    where?: treasure_gameWhereInput
    data: XOR<treasure_gameUpdateWithoutTreasure_connection_cardsInput, treasure_gameUncheckedUpdateWithoutTreasure_connection_cardsInput>
  }

  export type treasure_gameUpdateWithoutTreasure_connection_cardsInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutTreasure_gameNestedInput
    game_type?: game_typeUpdateOneWithoutTreasure_gameNestedInput
    Region?: RegionUpdateOneWithoutTreasure_gameNestedInput
  }

  export type treasure_gameUncheckedUpdateWithoutTreasure_connection_cardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutTreasure_gameNestedInput
  }

  export type AfterQuestionInformationCreateWithoutTreasure_gameInput = {
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
    puzzle_game: puzzle_gameCreateNestedOneWithoutAfterQuestionInformationInput
    quiz_game: quiz_gameCreateNestedOneWithoutAfterQuestionInformationInput
  }

  export type AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput = {
    id?: number
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationCreateOrConnectWithoutTreasure_gameInput = {
    where: AfterQuestionInformationWhereUniqueInput
    create: XOR<AfterQuestionInformationCreateWithoutTreasure_gameInput, AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput>
  }

  export type AfterQuestionInformationCreateManyTreasure_gameInputEnvelope = {
    data: AfterQuestionInformationCreateManyTreasure_gameInput | AfterQuestionInformationCreateManyTreasure_gameInput[]
    skipDuplicates?: boolean
  }

  export type treasure_connection_cardsCreateWithoutTreasure_gameInput = {
    card_type: $Enums.card_type_enum
    card_value?: string | null
    image_url?: string | null
    pair_id: number
    position?: number | null
  }

  export type treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput = {
    id?: number
    card_type: $Enums.card_type_enum
    card_value?: string | null
    image_url?: string | null
    pair_id: number
    position?: number | null
  }

  export type treasure_connection_cardsCreateOrConnectWithoutTreasure_gameInput = {
    where: treasure_connection_cardsWhereUniqueInput
    create: XOR<treasure_connection_cardsCreateWithoutTreasure_gameInput, treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput>
  }

  export type treasure_connection_cardsCreateManyTreasure_gameInputEnvelope = {
    data: treasure_connection_cardsCreateManyTreasure_gameInput | treasure_connection_cardsCreateManyTreasure_gameInput[]
    skipDuplicates?: boolean
  }

  export type game_typeCreateWithoutTreasure_gameInput = {
    code: $Enums.game_code_enum
    name: string
    puzzle_game?: puzzle_gameCreateNestedManyWithoutGame_typeInput
    quiz_game?: quiz_gameCreateNestedManyWithoutGame_typeInput
  }

  export type game_typeUncheckedCreateWithoutTreasure_gameInput = {
    id?: number
    code: $Enums.game_code_enum
    name: string
    puzzle_game?: puzzle_gameUncheckedCreateNestedManyWithoutGame_typeInput
    quiz_game?: quiz_gameUncheckedCreateNestedManyWithoutGame_typeInput
  }

  export type game_typeCreateOrConnectWithoutTreasure_gameInput = {
    where: game_typeWhereUniqueInput
    create: XOR<game_typeCreateWithoutTreasure_gameInput, game_typeUncheckedCreateWithoutTreasure_gameInput>
  }

  export type RegionCreateWithoutTreasure_gameInput = {
    regionName: string
    regionCode: string
    mediaUrl?: string | null
    description?: string | null
    puzzle_game?: puzzle_gameCreateNestedManyWithoutRegionInput
    quiz_game?: quiz_gameCreateNestedManyWithoutRegionInput
  }

  export type RegionUncheckedCreateWithoutTreasure_gameInput = {
    id?: number
    regionName: string
    regionCode: string
    mediaUrl?: string | null
    description?: string | null
    puzzle_game?: puzzle_gameUncheckedCreateNestedManyWithoutRegionInput
    quiz_game?: quiz_gameUncheckedCreateNestedManyWithoutRegionInput
  }

  export type RegionCreateOrConnectWithoutTreasure_gameInput = {
    where: RegionWhereUniqueInput
    create: XOR<RegionCreateWithoutTreasure_gameInput, RegionUncheckedCreateWithoutTreasure_gameInput>
  }

  export type AfterQuestionInformationUpsertWithWhereUniqueWithoutTreasure_gameInput = {
    where: AfterQuestionInformationWhereUniqueInput
    update: XOR<AfterQuestionInformationUpdateWithoutTreasure_gameInput, AfterQuestionInformationUncheckedUpdateWithoutTreasure_gameInput>
    create: XOR<AfterQuestionInformationCreateWithoutTreasure_gameInput, AfterQuestionInformationUncheckedCreateWithoutTreasure_gameInput>
  }

  export type AfterQuestionInformationUpdateWithWhereUniqueWithoutTreasure_gameInput = {
    where: AfterQuestionInformationWhereUniqueInput
    data: XOR<AfterQuestionInformationUpdateWithoutTreasure_gameInput, AfterQuestionInformationUncheckedUpdateWithoutTreasure_gameInput>
  }

  export type AfterQuestionInformationUpdateManyWithWhereWithoutTreasure_gameInput = {
    where: AfterQuestionInformationScalarWhereInput
    data: XOR<AfterQuestionInformationUpdateManyMutationInput, AfterQuestionInformationUncheckedUpdateManyWithoutTreasure_gameInput>
  }

  export type treasure_connection_cardsUpsertWithWhereUniqueWithoutTreasure_gameInput = {
    where: treasure_connection_cardsWhereUniqueInput
    update: XOR<treasure_connection_cardsUpdateWithoutTreasure_gameInput, treasure_connection_cardsUncheckedUpdateWithoutTreasure_gameInput>
    create: XOR<treasure_connection_cardsCreateWithoutTreasure_gameInput, treasure_connection_cardsUncheckedCreateWithoutTreasure_gameInput>
  }

  export type treasure_connection_cardsUpdateWithWhereUniqueWithoutTreasure_gameInput = {
    where: treasure_connection_cardsWhereUniqueInput
    data: XOR<treasure_connection_cardsUpdateWithoutTreasure_gameInput, treasure_connection_cardsUncheckedUpdateWithoutTreasure_gameInput>
  }

  export type treasure_connection_cardsUpdateManyWithWhereWithoutTreasure_gameInput = {
    where: treasure_connection_cardsScalarWhereInput
    data: XOR<treasure_connection_cardsUpdateManyMutationInput, treasure_connection_cardsUncheckedUpdateManyWithoutTreasure_gameInput>
  }

  export type treasure_connection_cardsScalarWhereInput = {
    AND?: treasure_connection_cardsScalarWhereInput | treasure_connection_cardsScalarWhereInput[]
    OR?: treasure_connection_cardsScalarWhereInput[]
    NOT?: treasure_connection_cardsScalarWhereInput | treasure_connection_cardsScalarWhereInput[]
    id?: IntFilter<"treasure_connection_cards"> | number
    treasure_game_id?: IntNullableFilter<"treasure_connection_cards"> | number | null
    card_type?: Enumcard_type_enumFilter<"treasure_connection_cards"> | $Enums.card_type_enum
    card_value?: StringNullableFilter<"treasure_connection_cards"> | string | null
    image_url?: StringNullableFilter<"treasure_connection_cards"> | string | null
    pair_id?: IntFilter<"treasure_connection_cards"> | number
    position?: IntNullableFilter<"treasure_connection_cards"> | number | null
  }

  export type game_typeUpsertWithoutTreasure_gameInput = {
    update: XOR<game_typeUpdateWithoutTreasure_gameInput, game_typeUncheckedUpdateWithoutTreasure_gameInput>
    create: XOR<game_typeCreateWithoutTreasure_gameInput, game_typeUncheckedCreateWithoutTreasure_gameInput>
    where?: game_typeWhereInput
  }

  export type game_typeUpdateToOneWithWhereWithoutTreasure_gameInput = {
    where?: game_typeWhereInput
    data: XOR<game_typeUpdateWithoutTreasure_gameInput, game_typeUncheckedUpdateWithoutTreasure_gameInput>
  }

  export type game_typeUpdateWithoutTreasure_gameInput = {
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
    puzzle_game?: puzzle_gameUpdateManyWithoutGame_typeNestedInput
    quiz_game?: quiz_gameUpdateManyWithoutGame_typeNestedInput
  }

  export type game_typeUncheckedUpdateWithoutTreasure_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: Enumgame_code_enumFieldUpdateOperationsInput | $Enums.game_code_enum
    name?: StringFieldUpdateOperationsInput | string
    puzzle_game?: puzzle_gameUncheckedUpdateManyWithoutGame_typeNestedInput
    quiz_game?: quiz_gameUncheckedUpdateManyWithoutGame_typeNestedInput
  }

  export type RegionUpsertWithoutTreasure_gameInput = {
    update: XOR<RegionUpdateWithoutTreasure_gameInput, RegionUncheckedUpdateWithoutTreasure_gameInput>
    create: XOR<RegionCreateWithoutTreasure_gameInput, RegionUncheckedCreateWithoutTreasure_gameInput>
    where?: RegionWhereInput
  }

  export type RegionUpdateToOneWithWhereWithoutTreasure_gameInput = {
    where?: RegionWhereInput
    data: XOR<RegionUpdateWithoutTreasure_gameInput, RegionUncheckedUpdateWithoutTreasure_gameInput>
  }

  export type RegionUpdateWithoutTreasure_gameInput = {
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puzzle_game?: puzzle_gameUpdateManyWithoutRegionNestedInput
    quiz_game?: quiz_gameUpdateManyWithoutRegionNestedInput
  }

  export type RegionUncheckedUpdateWithoutTreasure_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionName?: StringFieldUpdateOperationsInput | string
    regionCode?: StringFieldUpdateOperationsInput | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    puzzle_game?: puzzle_gameUncheckedUpdateManyWithoutRegionNestedInput
    quiz_game?: quiz_gameUncheckedUpdateManyWithoutRegionNestedInput
  }

  export type CommentCreateManyCommentInput = {
    id?: number
    postId: number
    userId: number
    content: string
    likes?: number
    dislikes?: number
  }

  export type comment_reactionCreateManyCommentInput = {
    id?: number
    user_id: number
    reaction_type: $Enums.reaction_type_enum
    created_at?: Date | string | null
  }

  export type CommentUpdateWithoutCommentInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    other_Comment?: CommentUpdateManyWithoutCommentNestedInput
    Post?: PostUpdateOneRequiredWithoutCommentNestedInput
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    other_Comment?: CommentUncheckedUpdateManyWithoutCommentNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
  }

  export type comment_reactionUpdateWithoutCommentInput = {
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    User?: UserUpdateOneRequiredWithoutComment_reactionNestedInput
  }

  export type comment_reactionUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type comment_reactionUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CommentCreateManyPostInput = {
    id?: number
    userId: number
    content: string
    likes?: number
    dislikes?: number
    parentId?: number | null
  }

  export type CommentUpdateWithoutPostInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    Comment?: CommentUpdateOneWithoutOther_CommentNestedInput
    other_Comment?: CommentUpdateManyWithoutCommentNestedInput
    User?: UserUpdateOneRequiredWithoutCommentNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    other_Comment?: CommentUncheckedUpdateManyWithoutCommentNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TagsUpdateWithoutPostInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TagsUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type puzzle_gameCreateManyRegionInput = {
    id?: number
    gametype?: number | null
    imageurl?: string | null
  }

  export type quiz_gameCreateManyRegionInput = {
    id?: number
    gametype?: number | null
    title: string
    description?: string | null
  }

  export type treasure_gameCreateManyRegionInput = {
    id?: number
    gametype?: number | null
    title?: string | null
    description?: string | null
  }

  export type puzzle_gameUpdateWithoutRegionInput = {
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutPuzzle_gameNestedInput
    game_type?: game_typeUpdateOneWithoutPuzzle_gameNestedInput
    puzzle_pieces?: puzzle_piecesUpdateManyWithoutPuzzle_gameNestedInput
  }

  export type puzzle_gameUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutPuzzle_gameNestedInput
    puzzle_pieces?: puzzle_piecesUncheckedUpdateManyWithoutPuzzle_gameNestedInput
  }

  export type puzzle_gameUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quiz_gameUpdateWithoutRegionInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutQuiz_gameNestedInput
    game_type?: game_typeUpdateOneWithoutQuiz_gameNestedInput
    quiz_game_qa?: quiz_game_qaUpdateManyWithoutQuiz_gameNestedInput
  }

  export type quiz_gameUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutQuiz_gameNestedInput
    quiz_game_qa?: quiz_game_qaUncheckedUpdateManyWithoutQuiz_gameNestedInput
  }

  export type quiz_gameUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type treasure_gameUpdateWithoutRegionInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutTreasure_gameNestedInput
    treasure_connection_cards?: treasure_connection_cardsUpdateManyWithoutTreasure_gameNestedInput
    game_type?: game_typeUpdateOneWithoutTreasure_gameNestedInput
  }

  export type treasure_gameUncheckedUpdateWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutTreasure_gameNestedInput
    treasure_connection_cards?: treasure_connection_cardsUncheckedUpdateManyWithoutTreasure_gameNestedInput
  }

  export type treasure_gameUncheckedUpdateManyWithoutRegionInput = {
    id?: IntFieldUpdateOperationsInput | number
    gametype?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PostUpdateWithoutTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    Comment?: CommentUpdateManyWithoutPostNestedInput
    User?: UserUpdateOneRequiredWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    Comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
  }

  export type AchievementCreateManyUserInput = {
    id?: number
    name: string
    description: string
    stars: number
  }

  export type CommentCreateManyUserInput = {
    id?: number
    postId: number
    content: string
    likes?: number
    dislikes?: number
    parentId?: number | null
  }

  export type PostCreateManyUserInput = {
    id?: number
    title: string
    question: string
    media: JsonNullValueInput | InputJsonValue
  }

  export type RefreshTokenCreateManyUserInput = {
    id: string
    hashedToken: string
    revoked?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    expireAt: Date | string
  }

  export type comment_reactionCreateManyUserInput = {
    id?: number
    comment_id: number
    reaction_type: $Enums.reaction_type_enum
    created_at?: Date | string | null
  }

  export type password_resetsCreateManyUserInput = {
    id?: number
    token: string
    expiresAt: Date | string
  }

  export type AchievementUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
  }

  export type AchievementUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: IntFieldUpdateOperationsInput | number
  }

  export type CommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    Comment?: CommentUpdateOneWithoutOther_CommentNestedInput
    other_Comment?: CommentUpdateManyWithoutCommentNestedInput
    Post?: PostUpdateOneRequiredWithoutCommentNestedInput
    comment_reaction?: comment_reactionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    other_Comment?: CommentUncheckedUpdateManyWithoutCommentNestedInput
    comment_reaction?: comment_reactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    likes?: IntFieldUpdateOperationsInput | number
    dislikes?: IntFieldUpdateOperationsInput | number
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PostUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    Comment?: CommentUpdateManyWithoutPostNestedInput
    Tags?: TagsUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
    Comment?: CommentUncheckedUpdateManyWithoutPostNestedInput
    Tags?: TagsUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    media?: JsonNullValueInput | InputJsonValue
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    hashedToken?: StringFieldUpdateOperationsInput | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expireAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comment_reactionUpdateWithoutUserInput = {
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Comment?: CommentUpdateOneRequiredWithoutComment_reactionNestedInput
  }

  export type comment_reactionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment_id?: IntFieldUpdateOperationsInput | number
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type comment_reactionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    comment_id?: IntFieldUpdateOperationsInput | number
    reaction_type?: Enumreaction_type_enumFieldUpdateOperationsInput | $Enums.reaction_type_enum
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_resetsUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_resetsUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type password_resetsUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type puzzle_gameCreateManyGame_typeInput = {
    id?: number
    regionid?: number | null
    imageurl?: string | null
  }

  export type quiz_gameCreateManyGame_typeInput = {
    id?: number
    regionid?: number | null
    title: string
    description?: string | null
  }

  export type treasure_gameCreateManyGame_typeInput = {
    id?: number
    regionid?: number | null
    title?: string | null
    description?: string | null
  }

  export type puzzle_gameUpdateWithoutGame_typeInput = {
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutPuzzle_gameNestedInput
    Region?: RegionUpdateOneWithoutPuzzle_gameNestedInput
    puzzle_pieces?: puzzle_piecesUpdateManyWithoutPuzzle_gameNestedInput
  }

  export type puzzle_gameUncheckedUpdateWithoutGame_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutPuzzle_gameNestedInput
    puzzle_pieces?: puzzle_piecesUncheckedUpdateManyWithoutPuzzle_gameNestedInput
  }

  export type puzzle_gameUncheckedUpdateManyWithoutGame_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    imageurl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type quiz_gameUpdateWithoutGame_typeInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutQuiz_gameNestedInput
    Region?: RegionUpdateOneWithoutQuiz_gameNestedInput
    quiz_game_qa?: quiz_game_qaUpdateManyWithoutQuiz_gameNestedInput
  }

  export type quiz_gameUncheckedUpdateWithoutGame_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutQuiz_gameNestedInput
    quiz_game_qa?: quiz_game_qaUncheckedUpdateManyWithoutQuiz_gameNestedInput
  }

  export type quiz_gameUncheckedUpdateManyWithoutGame_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type treasure_gameUpdateWithoutGame_typeInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUpdateManyWithoutTreasure_gameNestedInput
    treasure_connection_cards?: treasure_connection_cardsUpdateManyWithoutTreasure_gameNestedInput
    Region?: RegionUpdateOneWithoutTreasure_gameNestedInput
  }

  export type treasure_gameUncheckedUpdateWithoutGame_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    AfterQuestionInformation?: AfterQuestionInformationUncheckedUpdateManyWithoutTreasure_gameNestedInput
    treasure_connection_cards?: treasure_connection_cardsUncheckedUpdateManyWithoutTreasure_gameNestedInput
  }

  export type treasure_gameUncheckedUpdateManyWithoutGame_typeInput = {
    id?: IntFieldUpdateOperationsInput | number
    regionid?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AfterQuestionInformationCreateManyPuzzle_gameInput = {
    id?: number
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
  }

  export type puzzle_piecesCreateManyPuzzle_gameInput = {
    id?: number
    piece_index: number
    x_position?: number | null
    y_position?: number | null
    correct_x: number
    correct_y: number
    image_piece_url?: string | null
  }

  export type AfterQuestionInformationUpdateWithoutPuzzle_gameInput = {
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
    quiz_game?: quiz_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput
    treasure_game?: treasure_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput
  }

  export type AfterQuestionInformationUncheckedUpdateWithoutPuzzle_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationUncheckedUpdateManyWithoutPuzzle_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
  }

  export type puzzle_piecesUpdateWithoutPuzzle_gameInput = {
    piece_index?: IntFieldUpdateOperationsInput | number
    x_position?: NullableIntFieldUpdateOperationsInput | number | null
    y_position?: NullableIntFieldUpdateOperationsInput | number | null
    correct_x?: IntFieldUpdateOperationsInput | number
    correct_y?: IntFieldUpdateOperationsInput | number
    image_piece_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type puzzle_piecesUncheckedUpdateWithoutPuzzle_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    piece_index?: IntFieldUpdateOperationsInput | number
    x_position?: NullableIntFieldUpdateOperationsInput | number | null
    y_position?: NullableIntFieldUpdateOperationsInput | number | null
    correct_x?: IntFieldUpdateOperationsInput | number
    correct_y?: IntFieldUpdateOperationsInput | number
    image_piece_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type puzzle_piecesUncheckedUpdateManyWithoutPuzzle_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    piece_index?: IntFieldUpdateOperationsInput | number
    x_position?: NullableIntFieldUpdateOperationsInput | number | null
    y_position?: NullableIntFieldUpdateOperationsInput | number | null
    correct_x?: IntFieldUpdateOperationsInput | number
    correct_y?: IntFieldUpdateOperationsInput | number
    image_piece_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AfterQuestionInformationCreateManyQuiz_gameInput = {
    id?: number
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
  }

  export type quiz_game_qaCreateManyQuiz_gameInput = {
    id?: number
    question: string
    wrong_answers: JsonNullValueInput | InputJsonValue
    correct_answer: string
  }

  export type AfterQuestionInformationUpdateWithoutQuiz_gameInput = {
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
    puzzle_game?: puzzle_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput
    treasure_game?: treasure_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput
  }

  export type AfterQuestionInformationUncheckedUpdateWithoutQuiz_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationUncheckedUpdateManyWithoutQuiz_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
  }

  export type quiz_game_qaUpdateWithoutQuiz_gameInput = {
    question?: StringFieldUpdateOperationsInput | string
    wrong_answers?: JsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
  }

  export type quiz_game_qaUncheckedUpdateWithoutQuiz_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    wrong_answers?: JsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
  }

  export type quiz_game_qaUncheckedUpdateManyWithoutQuiz_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    wrong_answers?: JsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
  }

  export type AfterQuestionInformationCreateManyTreasure_gameInput = {
    id?: number
    questionNumber: number
    images: JsonNullValueInput | InputJsonValue
    texts: JsonNullValueInput | InputJsonValue
  }

  export type treasure_connection_cardsCreateManyTreasure_gameInput = {
    id?: number
    card_type: $Enums.card_type_enum
    card_value?: string | null
    image_url?: string | null
    pair_id: number
    position?: number | null
  }

  export type AfterQuestionInformationUpdateWithoutTreasure_gameInput = {
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
    puzzle_game?: puzzle_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput
    quiz_game?: quiz_gameUpdateOneRequiredWithoutAfterQuestionInformationNestedInput
  }

  export type AfterQuestionInformationUncheckedUpdateWithoutTreasure_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
  }

  export type AfterQuestionInformationUncheckedUpdateManyWithoutTreasure_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    questionNumber?: IntFieldUpdateOperationsInput | number
    images?: JsonNullValueInput | InputJsonValue
    texts?: JsonNullValueInput | InputJsonValue
  }

  export type treasure_connection_cardsUpdateWithoutTreasure_gameInput = {
    card_type?: Enumcard_type_enumFieldUpdateOperationsInput | $Enums.card_type_enum
    card_value?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pair_id?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type treasure_connection_cardsUncheckedUpdateWithoutTreasure_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_type?: Enumcard_type_enumFieldUpdateOperationsInput | $Enums.card_type_enum
    card_value?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pair_id?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type treasure_connection_cardsUncheckedUpdateManyWithoutTreasure_gameInput = {
    id?: IntFieldUpdateOperationsInput | number
    card_type?: Enumcard_type_enumFieldUpdateOperationsInput | $Enums.card_type_enum
    card_value?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    pair_id?: IntFieldUpdateOperationsInput | number
    position?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}